{
  "problem_id": "job_shop_scheduling_001",
  "metadata": {
    "problem_type": "Job Shop Scheduling Problem",
    "difficulty": "simple"
  },
  "problem_description": "In a sophisticated precision manufacturing facility, five distinct production workflows must be orchestrated through a complex network of specialized processing stations. Each workflow represents a unique product line that undergoes a series of transformation stages, with each stage requiring specific equipment and processing durations. The facility operates under stringent resource constraints where each processing station can only handle one transformation at any given moment, creating intricate interdependencies between workflow execution patterns. The technical specifications for each workflow are as follows: Workflow Alpha begins with Station 1 requiring 12 minutes for substrate preparation, followed by Station 3 needing 8 minutes for precision machining, then Station 2 demanding 15 minutes for heat treatment, subsequently Station 5 requiring 20 minutes for final assembly, and concluding with Station 4 needing 10 minutes for quality inspection. Workflow Beta commences with Station 2 requiring 25 minutes for material processing, then proceeds to Station 1 needing 12 minutes for component fabrication, followed by Station 4 demanding 18 minutes for surface treatment, then Station 3 requiring 14 minutes for precision calibration, and finally Station 5 needing 22 minutes for final packaging. Workflow Gamma starts with Station 3 requiring 16 minutes for initial processing, then moves to Station 5 needing 30 minutes for complex assembly, followed by Station 1 demanding 9 minutes for testing protocols, then Station 2 requiring 12 minutes for finishing touches, and concludes with Station 4 needing 25 minutes for certification processes. Workflow Delta initiates with Station 4 requiring 18 minutes for preprocessing, then advances to Station 2 needing 15 minutes for core manufacturing, followed by Station 5 demanding 12 minutes for integration, then Station 1 requiring 28 minutes for comprehensive testing, and terminates with Station 3 needing 16 minutes for final validation. Workflow Epsilon begins with Station 5 requiring 20 minutes for preparation, then transitions to Station 4 needing 14 minutes for structural assembly, followed by Station 3 demanding 25 minutes for system integration, then Station 2 requiring 16 minutes for optimization, and finishes with Station 1 needing 18 minutes for delivery preparation. The production system must adhere to fundamental operational principles that govern workflow execution and resource allocation. Within each individual workflow, a strict sequential processing protocol requires that transformation stages occur in their predetermined order, ensuring that no subsequent operation may begin until the previous operation has been fully completed. Simultaneously, the resource exclusivity principle mandates that each processing station can only accommodate one operation at any given moment, which prevents temporal overlap between operations regardless of their workflow origin. The facility management's strategic objective focuses on determining the optimal temporal positioning for all transformation stages, aiming to minimize the makespan - calculated as the maximum completion time observed across all workflows - thereby achieving superior resource utilization efficiency and reducing the overall production timeline to its optimal duration.",
  "solution_format_description": "Print the following fields: - initiation_times: start times for each workflow's transformation stages. - production_completion_duration: total time to complete all workflows.",
  "structured_data": {
    "n_workflows": 5,
    "n_processing_stations": 5,
    "processing_durations": [
      [12, 8, 15, 20, 10],
      [25, 12, 18, 14, 22],
      [16, 30, 9, 12, 25],
      [18, 15, 12, 28, 16],
      [20, 14, 25, 16, 18]
    ],
    "station_assignments": [
      [1, 3, 2, 5, 4],
      [2, 1, 4, 3, 5],
      [3, 5, 1, 2, 4],
      [4, 2, 5, 1, 3],
      [5, 4, 3, 2, 1]
    ]
  },
  "reference_solution": {
    "initiation_times": [
      [0, 16, 40, 62, 96],
      [0, 25, 37, 59, 82],
      [0, 20, 50, 59, 71],
      [0, 25, 50, 62, 90],
      [0, 20, 34, 71, 90]
    ],
    "production_completion_duration": 108
  },
  "solver_code": "from cpmpy import *\nimport json\n\nn_workflows = 5\nn_processing_stations = 5\nprocessing_durations = [\n    [12, 8, 15, 20, 10],\n    [25, 12, 18, 14, 22], \n    [16, 30, 9, 12, 25],\n    [18, 15, 12, 28, 16],\n    [20, 14, 25, 16, 18]\n]\nstation_assignments = [\n    [1, 3, 2, 5, 4],\n    [2, 1, 4, 3, 5],\n    [3, 5, 1, 2, 4], \n    [4, 2, 5, 1, 3],\n    [5, 4, 3, 2, 1]\n]\n\nmodel = Model()\n\ninitiation = intvar(0, 200, shape=(n_workflows, n_processing_stations))\nproduction_completion_duration = intvar(0, 200)\n\nfor i in range(n_workflows):\n    for j in range(n_processing_stations - 1):\n        model += initiation[i][j+1] >= initiation[i][j] + processing_durations[i][j]\n\noperations_on_station = {}\nfor i in range(n_workflows):\n    for j in range(n_processing_stations):\n        station_id = station_assignments[i][j]\n        if station_id not in operations_on_station:\n            operations_on_station[station_id] = []\n        operations_on_station[station_id].append((i, j))\n\nfor ops in operations_on_station.values():\n    if len(ops) > 1:\n        for k1 in range(len(ops)):\n            for k2 in range(k1 + 1, len(ops)):\n                i1, j1 = ops[k1]\n                i2, j2 = ops[k2]\n                model += (initiation[i1][j1] + processing_durations[i1][j1] <= initiation[i2][j2]) | (initiation[i2][j2] + processing_durations[i2][j2] <= initiation[i1][j1])\n\nfor i in range(n_workflows):\n    model += production_completion_duration >= initiation[i][n_processing_stations-1] + processing_durations[i][n_processing_stations-1]\n\nmodel.minimize(production_completion_duration)\n\nif model.solve():\n    initiation_times = [[int(initiation[i][j].value()) for j in range(n_processing_stations)] for i in range(n_workflows)]\n    result = {\n        \"initiation_times\": initiation_times,\n        \"production_completion_duration\": int(production_completion_duration.value())\n    }\n    print(json.dumps(result))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"initiation_times\", \"production_completion_duration\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        initiation_times = solution[\"initiation_times\"]\n        production_completion_duration = solution[\"production_completion_duration\"]\n        n_workflows = structured_data[\"n_workflows\"]\n        n_processing_stations = structured_data[\"n_processing_stations\"]\n        processing_durations = structured_data[\"processing_durations\"]\n        station_assignments = structured_data[\"station_assignments\"]\n        errors = []\n        \n        if len(initiation_times) != n_workflows:\n            errors.append(f\"Expected {n_workflows} workflows, got {len(initiation_times)}\")\n        \n        for i, workflow_times in enumerate(initiation_times):\n            if len(workflow_times) != n_processing_stations:\n                errors.append(f\"Workflow {i} has {len(workflow_times)} stages, expected {n_processing_stations}\")\n            if any(t < 0 for t in workflow_times):\n                errors.append(f\"Workflow {i} has negative initiation times\")\n        \n        if errors:\n            return {\"is_valid\": False, \"validation_errors\": errors, \"optimality_score\": 0.0}\n        \n        for i in range(n_workflows):\n            for j in range(n_processing_stations - 1):\n                current_start = initiation_times[i][j]\n                current_duration = processing_durations[i][j]\n                next_start = initiation_times[i][j + 1]\n                if next_start < current_start + current_duration:\n                    errors.append(f\"Workflow {i}: stage {j+1} starts at {next_start} but stage {j} finishes at {current_start + current_duration}\")\n        \n        station_operations = {}\n        for i in range(n_workflows):\n            for j in range(n_processing_stations):\n                station_id = station_assignments[i][j]\n                start_time = initiation_times[i][j]\n                duration = processing_durations[i][j]\n                end_time = start_time + duration\n                \n                if station_id not in station_operations:\n                    station_operations[station_id] = []\n                station_operations[station_id].append((start_time, end_time, i, j))\n        \n        for station_id, ops in station_operations.items():\n            ops_sorted = sorted(ops, key=lambda x: x[0]) \n            for k in range(len(ops_sorted) - 1):\n                current_end = ops_sorted[k][1]\n                next_start = ops_sorted[k + 1][0]\n                if current_end > next_start:\n                    workflow1, stage1 = ops_sorted[k][2], ops_sorted[k][3]\n                    workflow2, stage2 = ops_sorted[k + 1][2], ops_sorted[k + 1][3]\n                    errors.append(f\"Station {station_id}: workflow {workflow1} stage {stage1} ends at {current_end} overlaps with workflow {workflow2} stage {stage2} starting at {next_start}\")\n        \n        if len(errors) == 0:\n            optimal_duration = reference_solution[\"production_completion_duration\"]\n            gap = abs(optimal_duration - production_completion_duration) / optimal_duration\n            optimality_score = max(0, 1 - gap)\n            return {\n                \"is_valid\": True,\n                \"validation_errors\": [],\n                \"optimality_score\": optimality_score\n            }\n        else:\n            return {\n                \"is_valid\": False,\n                \"validation_errors\": errors,\n                \"optimality_score\": 0.0\n            }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}