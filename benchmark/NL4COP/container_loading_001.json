{
  "problem_id": "container_loading_001",
  "metadata": {
    "problem_type": "Container Loading Problem",
    "difficulty": "simple"
  },
  "problem_description": "A logistics coordinator is planning the loading of a small shipping container with two distinct product types to optimize space usage. The container has internal dimensions of 5 units in length, 3 units in width, and 8 units in height. The products to be loaded are: 1. Flat, wide panels (Type ID: 1): Each panel has dimensions 1 unit (length) by 3 units (width) by 4 units (height). There are 4 of these panels available. 2. Rectangular boxes (Type ID: 2): Each box has dimensions 4 units (length) by 2 units (width) by 5 units (height). There are 10 of these boxes available. Products can be rotated in any orientation to fit into the container. The goal is to pack as many products as possible into the container to maximize the volume utilization ratio. Products must be placed so that they are fully inside the container and do not overlap with each other. The coordinator wants to find the best arrangement of these products to make the most efficient use of the available shipping space.",
  "solution_format_description": "Print the following fields: - placements: for each product, list placement with type, x, y, z, oriented_length, oriented_width, oriented_height. - volume_utilization: ratio of used container volume to total volume.",
  "structured_data": {
    "container_dimensions": [5, 3, 8],
    "product_inventory": [
      [1, 3, 4, 4],
      [4, 2, 5, 10]
    ]
  },
  "reference_solution": {
    "placements": [
      [1, [1, 0, 0], [4, 1, 3]],
      [1, [2, 0, 3], [3, 1, 4]],
      [2, [0, 1, 0], [5, 2, 4]],
      [2, [0, 1, 4], [5, 2, 4]]
    ],
    "volume_utilization": 0.8666666666666667
  },
  "solver_code": "from cpmpy import *\nimport json\n\ncontainer_dimensions = [5, 3, 8]\nproduct_inventory = [\n    [1, 3, 4, 4],\n    [4, 2, 5, 10]\n]\n\ncontainer_length, container_width, container_height = container_dimensions\ncontainer_volume = container_length * container_width * container_height\n\nproducts = []\nfor p_idx, product_data in enumerate(product_inventory):\n    length, width, height, available_count = product_data\n    for i in range(available_count):\n        products.append([p_idx + 1, length, width, height])\n\nnum_products = len(products)\n\nb = boolvar(shape=num_products)\nx = intvar(0, container_length, shape=num_products)\ny = intvar(0, container_width, shape=num_products)\nz = intvar(0, container_height, shape=num_products)\nv = intvar(0, 2, shape=num_products)\nhswap = boolvar(shape=num_products)\n\nmax_dim = max(container_length, container_width, container_height)\no_length = intvar(1, max_dim, shape=num_products)\no_width = intvar(1, max_dim, shape=num_products)\no_height = intvar(1, max_dim, shape=num_products)\n\nmodel = Model()\n\nfor i in range(num_products):\n    length, width, height = products[i][1], products[i][2], products[i][3]\n    \n    o_lengths = [width, height, length, height, length, width]\n    o_widths = [height, width, height, length, width, length]\n    o_heights = [length, length, width, width, height, height]\n    \n    orientation_index_expr = v[i] * 2 + hswap[i]\n    model += (o_length[i] == Element(o_lengths, orientation_index_expr))\n    model += (o_width[i] == Element(o_widths, orientation_index_expr))\n    model += (o_height[i] == Element(o_heights, orientation_index_expr))\n\n    model += (x[i] + o_length[i] <= container_length) | (b[i] == 0)\n    model += (y[i] + o_width[i] <= container_width) | (b[i] == 0)\n    model += (z[i] + o_height[i] <= container_height) | (b[i] == 0)\n\nfor i in range(num_products):\n    for j in range(i + 1, num_products):\n        no_x_overlap = (x[i] + o_length[i] <= x[j]) | (x[j] + o_length[j] <= x[i])\n        no_y_overlap = (y[i] + o_width[i] <= y[j]) | (y[j] + o_width[j] <= y[i])\n        no_z_overlap = (z[i] + o_height[i] <= z[j]) | (z[j] + o_height[j] <= z[i])\n        non_overlap = no_x_overlap | no_y_overlap | no_z_overlap\n        model += (b[i] == 0) | (b[j] == 0) | non_overlap\n\nproduct_volumes = [products[i][1] * products[i][2] * products[i][3] for i in range(num_products)]\nmodel.maximize(sum(b[i] * product_volumes[i] for i in range(num_products)))\n\nif model.solve():\n    total_placed_volume = sum(product_volumes[i] for i in range(num_products) if b[i].value())\n    volume_utilization = total_placed_volume / container_volume if container_volume > 0 else 0.0\n    \n    placements = []\n    for i in range(num_products):\n        if b[i].value():\n            placements.append([\n                products[i][0],\n                [int(x[i].value()), int(y[i].value()), int(z[i].value())],\n                [int(o_length[i].value()), int(o_width[i].value()), int(o_height[i].value())]\n            ])\n            \n    result = {\n        \"placements\": placements,\n        \"volume_utilization\": volume_utilization\n    }\n    \n    print(json.dumps(result))\nelse:\n    print(json.dumps({\"placements\": [], \"volume_utilization\": 0.0}))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        if isinstance(candidate_solution, str):\n            solution = json.loads(candidate_solution)\n        else:\n            solution = candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"placements\", \"volume_utilization\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        placements = solution[\"placements\"]\n        volume_utilization = solution[\"volume_utilization\"]\n        shipping_container = structured_data[\"shipping_container\"]\n        product_types = structured_data[\"product_types\"]\n        \n        errors = []\n        \n        product_type_dict = {p[\"product_type_id\"]: p for p in product_types}\n        \n        used_counts = {}\n        placed_boxes = []\n        \n        for placement in placements:\n            if len(placement) != 3:\n                errors.append(\"Invalid placement format\")\n                continue\n                \n            product_type_id, position, oriented_dims = placement\n            \n            if product_type_id not in product_type_dict:\n                errors.append(f\"Unknown product type ID: {product_type_id}\")\n                continue\n            \n            used_counts[product_type_id] = used_counts.get(product_type_id, 0) + 1\n            \n            if len(position) != 3 or len(oriented_dims) != 3:\n                errors.append(f\"Invalid position or dimensions format for product type {product_type_id}\")\n                continue\n                \n            x, y, z = position\n            length, width, height = oriented_dims\n            \n            if x < 0 or y < 0 or z < 0 or length <= 0 or width <= 0 or height <= 0:\n                errors.append(f\"Negative coordinates or non-positive dimensions for product type {product_type_id}\")\n                continue\n                \n            container_length = shipping_container[\"length\"]\n            container_width = shipping_container[\"width\"]\n            container_height = shipping_container[\"height\"]\n            \n            if x + length > container_length or y + width > container_width or z + height > container_height:\n                errors.append(f\"Box of product type {product_type_id} extends outside the container\")\n                continue\n                \n            placed_boxes.append({\n                \"product_type_id\": product_type_id,\n                \"x\": x, \"y\": y, \"z\": z,\n                \"length\": length, \"width\": width, \"height\": height\n            })\n        \n        for product_type_id, count in used_counts.items():\n            if count > product_type_dict[product_type_id][\"available_count\"]:\n                errors.append(f\"Exceeded available count for product type {product_type_id}\")\n        \n        for i in range(len(placed_boxes)):\n            for j in range(i + 1, len(placed_boxes)):\n                box1 = placed_boxes[i]\n                box2 = placed_boxes[j]\n                \n                if (box1[\"x\"] < box2[\"x\"] + box2[\"length\"] and box2[\"x\"] < box1[\"x\"] + box1[\"length\"] and\n                    box1[\"y\"] < box2[\"y\"] + box2[\"width\"] and box2[\"y\"] < box1[\"y\"] + box1[\"width\"] and\n                    box1[\"z\"] < box2[\"z\"] + box2[\"height\"] and box2[\"z\"] < box1[\"z\"] + box1[\"height\"]):\n                    errors.append(f\"Boxes of product types {box1['product_type_id']} and {box2['product_type_id']} overlap\")\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_utilization = reference_solution[\"volume_utilization\"]\n            if optimal_utilization == 0:\n                optimality_score = 1.0 if volume_utilization == 0 else 0.0\n            else:\n                gap = abs(optimal_utilization - volume_utilization) / abs(optimal_utilization)\n                optimality_score = max(0, 1 - gap)\n            \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Format error in solution data: {str(e)}\"], \"optimality_score\": 0.0}"
}