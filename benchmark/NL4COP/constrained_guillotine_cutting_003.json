{
  "problem_id": "constrained_guillotine_cutting_003",
  "metadata": {
    "problem_type": "Constrained Guillotine Cutting Problem",
    "difficulty": "hard"
  },
  "problem_description": "A carpenter has a large rectangular wooden board, 16 meters long and 10 meters wide, and needs to cut out smaller rectangular pieces for a project using a guillotine cutting process. The carpenter wants to maximize the total value of the pieces obtained from this board. Each type of piece has a specific size, value, and a limit on how many can be cut. In guillotine cutting, each cut must be a straight line that goes completely from one edge to another without cutting through any placed piece, and this property must hold recursively for all resulting subregions. Pieces cannot be rotated and must fit entirely within the board without overlapping. The carpenter needs to decide which pieces to cut and how to arrange them to get the highest total value.\n\nHere are the details of the piece types available:\n1. Piece Type 1: Size 8m x 5m, Value 65, Up to 2 pieces can be cut\n2. Piece Type 2: Size 6m x 5m, Value 48, Up to 2 pieces can be cut\n3. Piece Type 3: Size 7m x 4m, Value 42, Up to 2 pieces can be cut\n4. Piece Type 4: Size 4m x 4m, Value 28, Up to 2 pieces can be cut",
  "solution_format_description": "Print the following fields: - total_value: total value of placed pieces. - placements: for each piece, list placements with piece type, x, y, length, width, orientation.",
  "structured_data": {
    "container_dimensions": [16, 10],
    "item_inventory": [
      [8, 5, 2, 65],
      [6, 5, 2, 48],
      [7, 4, 2, 42],
      [4, 4, 2, 28]
    ]
  },
  "reference_solution": {
    "total_value": 254,
    "placements": [
      [4, 0, 6, 4, 4, 0],
      [2, 4, 5, 6, 5, 0],
      [1, 8, 0, 8, 5, 0],
      [1, 0, 0, 8, 5, 0],
      [2, 10, 5, 6, 5, 0]
    ]
  },
  "solver_code": "from cpmpy import *\nimport json\n\ncontainer_dimensions = [16, 10]\nitem_inventory = [\n    [8, 5, 2, 65],\n    [6, 5, 2, 48],\n    [7, 4, 2, 42],\n    [4, 4, 2, 28]\n]\n\nboard_length, board_width = container_dimensions\n\nm = len(item_inventory)\nmax_placements = sum(item[2] for item in item_inventory)\n\npiece_types_vars = [intvar(1, m, name=f\"p_type_{i}\") for i in range(max_placements)]\nx_vars = [intvar(0, board_length, name=f\"x_{i}\") for i in range(max_placements)]\ny_vars = [intvar(0, board_width, name=f\"y_{i}\") for i in range(max_placements)]\nplaced_vars = [boolvar(name=f\"placed_{i}\") for i in range(max_placements)]\n\nmodel = Model()\n\nfor i in range(max_placements):\n    for p in range(m):\n        item = item_inventory[p]\n        model += ((piece_types_vars[i] == p+1) & placed_vars[i]).implies(\n            (x_vars[i] + item[0] <= board_length) & \n            (y_vars[i] + item[1] <= board_width)\n        )\n\nfor i in range(max_placements):\n    for j in range(i+1, max_placements):\n        p1_type, x1, y1, placed1 = piece_types_vars[i], x_vars[i], y_vars[i], placed_vars[i]\n        p2_type, x2, y2, placed2 = piece_types_vars[j], x_vars[j], y_vars[j], placed_vars[j]\n        \n        p1_len = 0\n        p1_wid = 0\n        for p in range(m):\n            p1_len += (p1_type == p+1) * item_inventory[p][0]\n            p1_wid += (p1_type == p+1) * item_inventory[p][1]\n        \n        p2_len = 0\n        p2_wid = 0\n        for p in range(m):\n            p2_len += (p2_type == p+1) * item_inventory[p][0]\n            p2_wid += (p2_type == p+1) * item_inventory[p][1]\n        \n        model += (placed1 & placed2).implies(\n            (x1 + p1_len <= x2) | (x2 + p2_len <= x1) |\n            (y1 + p1_wid <= y2) | (y2 + p2_wid <= y1)\n        )\n\nfor p in range(m):\n    count = 0\n    for i in range(max_placements):\n        count += (piece_types_vars[i] == p+1) & placed_vars[i]\n    model += count <= item_inventory[p][2]\n\ntotal_value = 0\nfor i in range(max_placements):\n    item_value = 0\n    for p in range(m):\n        item_value += (piece_types_vars[i] == p+1) * item_inventory[p][3]\n    total_value += placed_vars[i] * item_value\n\nmodel.maximize(total_value)\n\nif model.solve():\n    solution_placements = []\n    solution_value = 0\n    \n    for i in range(max_placements):\n        if placed_vars[i].value():\n            p_idx = piece_types_vars[i].value() - 1\n            item = item_inventory[p_idx]\n            solution_placements.append([\n                piece_types_vars[i].value(), \n                x_vars[i].value(),           \n                y_vars[i].value(),          \n                item_inventory[p_idx][0],              \n                item_inventory[p_idx][1],              \n                0                          \n            ])\n            solution_value += item_inventory[p_idx][3]\n    \n    result = {\n        \"total_value\": solution_value,\n        \"placements\": solution_placements\n    }\n    print(json.dumps(result))\nelse:\n    print(json.dumps({\"total_value\": 0, \"placements\": []}))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        if isinstance(candidate_solution, str):\n            solution = json.loads(candidate_solution)\n        else:\n            solution = candidate_solution\n    except Exception:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"total_value\", \"placements\"]\n    missing = [f for f in required_fields if f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        total_value = solution[\"total_value\"]\n        placements = solution[\"placements\"]\n        \n        stock_length = structured_data[0][\"stock_length\"]\n        stock_width = structured_data[0][\"stock_width\"]\n        piece_types = structured_data[0][\"piece_types\"]\n        m = len(piece_types)\n        \n        errors = []\n        \n        def is_guillotine(rects, bx, by, ex, ey):\n            if not rects:\n                return True\n            if len(rects) == 1:\n                r = rects[0]\n                if r[0] == bx and r[1] == by and r[2] == ex and r[3] == ey:\n                    return True\n\n            for x in range(bx + 1, ex):\n                if all((r[2] <= x or r[0] >= x) for r in rects):\n                    left_rects = [r for r in rects if r[2] <= x]\n                    right_rects = [r for r in rects if r[0] >= x]\n                    if is_guillotine(left_rects, bx, by, x, ey) and is_guillotine(right_rects, x, by, ex, ey):\n                        return True\n\n            for y in range(by + 1, ey):\n                if all((r[3] <= y or r[1] >= y) for r in rects):\n                    bottom_rects = [r for r in rects if r[3] <= y]\n                    top_rects = [r for r in rects if r[1] >= y]\n                    if is_guillotine(bottom_rects, bx, by, ex, y) and is_guillotine(top_rects, bx, y, ex, ey):\n                        return True\n\n            return False\n\n        computed_value = 0\n        type_counts = [0] * m\n        rects = []\n\n        for idx, placement in enumerate(placements):\n            if not (isinstance(placement, (list, tuple)) and len(placement) == 6):\n                errors.append(f\"Placement {idx} is not a 6-tuple: {placement}\")\n                continue\n\n            try:\n                type_idx = int(placement[0])\n                x = int(placement[1])\n                y = int(placement[2])\n                placed_len = int(placement[3])\n                placed_wid = int(placement[4])\n                orient = int(placement[5])\n            except Exception:\n                errors.append(f\"Non-integer value in placement {idx}: {placement}\")\n                continue\n\n            if type_idx < 1 or type_idx > m:\n                errors.append(f\"Placement {idx} has invalid piece type index {type_idx}\")\n                continue\n\n            if orient != 0:\n                errors.append(f\"Placement {idx} has invalid orientation flag {orient}; rotation is not allowed.\")\n                continue\n\n            piece = piece_types[type_idx - 1]\n            p_length = piece['length']\n            p_width = piece['width']\n            max_allowed = piece['max']\n            p_value = piece['value']\n\n            if placed_len != p_length or placed_wid != p_width:\n                errors.append(f\"Placement {idx} dimensions ({placed_len}, {placed_wid}) do not match expected ({p_length}, {p_width})\")\n                continue\n\n            if x < 0 or y < 0 or (x + placed_len) > stock_length or (y + placed_wid) > stock_width:\n                errors.append(f\"Placement {idx} with rectangle ({x}, {y}, {x + placed_len}, {y + placed_wid}) is out of stock bounds (0,0) to ({stock_length},{stock_width})\")\n                continue\n\n            type_counts[type_idx - 1] += 1\n            computed_value += p_value\n            rects.append((x, y, x + placed_len, y + placed_wid))\n\n        num_rects = len(rects)\n        for i in range(num_rects):\n            for j in range(i + 1, num_rects):\n                r1 = rects[i]\n                r2 = rects[j]\n                dx = min(r1[2], r2[2]) - max(r1[0], r2[0])\n                dy = min(r1[3], r2[3]) - max(r1[1], r2[1])\n                if dx > 0 and dy > 0:\n                    errors.append(f\"Placements {i} and {j} overlap.\")\n\n        for i in range(m):\n            if type_counts[i] > piece_types[i]['max']:\n                errors.append(f\"Piece type {i+1} exceeds allowed count: {type_counts[i]} > {piece_types[i]['max']}\")\n\n        if not is_guillotine(rects, 0, 0, stock_length, stock_width):\n            errors.append(\"Guillotine condition violated: the placement layout is not guillotine separable.\")\n\n        if computed_value != total_value:\n            errors.append(f\"Reported total value {total_value} does not match computed value {computed_value}\")\n\n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_value = reference_solution[\"total_value\"]\n            if optimal_value == 0:\n                optimality_score = 1.0 if total_value == 0 else 0.0\n            else:\n                gap = abs(optimal_value - total_value) / abs(optimal_value)\n                optimality_score = max(0, 1 - gap)\n\n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}