{
  "problem_id": "orienteering_problem_003",
  "metadata": {
    "problem_type": "Orienteering Problem",
    "difficulty": "hard"
  },
  "problem_description": "Jordan is participating in an 80-kilometer cross-country rally race across a vast desert terrain. He must start at the headquarters located at (0, 0) and finish at the final destination located at (45, 45), with all coordinates measured in kilometers. While any two stations can be reached by driving directly in a straight line, each station can be visited at most once, and Jordan needs to determine which stations to include in his route to maximize the total bonus points collected. The headquarters and final destination have no bonus points, while the following stations have their coordinates and bonus values: 1. Forest Trail at (5, 8) worth 15 points; 2. Mountain Pass at (12, 3) worth 22 points; 3. River Crossing at (18, 12) worth 35 points; 4. Desert Oasis at (8, 18) worth 28 points; 5. Canyon View at (25, 7) worth 42 points; 6. Hill Station at (15, 22) worth 38 points; 7. Coastal Road at (30, 15) worth 45 points; 8. Valley Bridge at (22, 28) worth 40 points; 9. Summit Point at (35, 10) worth 48 points; 10. Lake Side at (3, 12) worth 18 points; 11. Meadow Field at (9, 6) worth 25 points; 12. Rock Formation at (20, 4) worth 32 points; 13. Waterfall at (28, 18) worth 43 points; 14. Grassland at (6, 25) worth 30 points; 15. Plateau at (16, 9) worth 36 points; 16. Ridge Line at (11, 16) worth 33 points; 17. Cliff Edge at (24, 12) worth 41 points; 18. Snow Peak at (32, 22) worth 46 points; 19. Stream Bank at (2, 7) worth 20 points; 20. Glacier Point at (26, 25) worth 44 points; 21. Pine Forest at (4, 20) worth 27 points; 22. Volcano Base at (33, 8) worth 47 points; 23. Cave Entrance at (14, 30) worth 39 points; 24. Wind Tunnel at (38, 15) worth 50 points; 25. Prairie Land at (7, 14) worth 29 points; 26. Rocky Path at (19, 19) worth 37 points; 27. High Ground at (29, 6) worth 42 points; 28. Wetlands at (13, 24) worth 34 points; 29. Ice Field at (36, 28) worth 49 points; 30. Trail Head at (1, 10) worth 16 points; 31. Junction Point at (21, 14) worth 35 points; 32. Alpine Zone at (31, 20) worth 45 points; 33. Swamp Area at (10, 28) worth 31 points; 34. Mountain Ridge at (27, 32) worth 48 points; 35. Desert Plateau at (17, 5) worth 38 points; 36. River Bend at (23, 26) worth 43 points; 37. Summit Peak at (40, 18) worth 52 points; 38. Lake Shore at (8, 33) worth 41 points.",
  "solution_format_description": "Print the following fields: - path: sequence of stations visited from start to finish. - visited_stations: visitation status for each station. - total_points: total bonus points. - total_distance: total driving distance.",
  "structured_data": {
    "stations": [
      [0.0, 0.0, 0],
      [5.0, 8.0, 15],
      [12.0, 3.0, 22],
      [18.0, 12.0, 35],
      [8.0, 18.0, 28],
      [25.0, 7.0, 42],
      [15.0, 22.0, 38],
      [30.0, 15.0, 45],
      [22.0, 28.0, 40],
      [35.0, 10.0, 48],
      [3.0, 12.0, 18],
      [9.0, 6.0, 25],
      [20.0, 4.0, 32],
      [28.0, 18.0, 43],
      [6.0, 25.0, 30],
      [16.0, 9.0, 36],
      [11.0, 16.0, 33],
      [24.0, 12.0, 41],
      [32.0, 22.0, 46],
      [2.0, 7.0, 20],
      [26.0, 25.0, 44],
      [4.0, 20.0, 27],
      [33.0, 8.0, 47],
      [14.0, 30.0, 39],
      [38.0, 15.0, 50],
      [7.0, 14.0, 29],
      [19.0, 19.0, 37],
      [29.0, 6.0, 42],
      [13.0, 24.0, 34],
      [36.0, 28.0, 49],
      [1.0, 10.0, 16],
      [21.0, 14.0, 35],
      [31.0, 20.0, 45],
      [10.0, 28.0, 31],
      [27.0, 32.0, 48],
      [17.0, 5.0, 38],
      [23.0, 26.0, 43],
      [40.0, 18.0, 52],
      [8.0, 33.0, 41],
      [45.0, 45.0, 0]
    ],
    "distance_budget": 80
  },
  "reference_solution": {
    "path": [0, 11, 2, 35, 15, 3, 31, 17, 7, 13, 32, 18, 29, 39],
    "visited_stations": [1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1],
    "total_points": 460,
    "total_distance": 77.99
  },
  "solver_code": "",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    import math\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"path\", \"visited_stations\", \"total_points\", \"total_distance\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        path = solution[\"path\"]\n        visited_stations = solution[\"visited_stations\"]\n        total_points = solution[\"total_points\"]\n        total_distance = solution[\"total_distance\"]\n        stations = structured_data[\"stations\"]\n        distance_budget = structured_data[\"distance_budget\"]\n        n = len(stations)\n        \n        errors = []\n        \n        if len(visited_stations) != n:\n            errors.append(f\"Array length mismatch: expected {n}, got {len(visited_stations)}\")\n        \n        if total_distance > distance_budget + 0.01:\n            errors.append(f\"Distance constraint violated: {total_distance} > {distance_budget}\")\n        \n        if not path:\n            errors.append(\"Path cannot be empty\")\n        elif path[0] != 0:\n            errors.append(f\"Path must start at headquarters (0), got {path[0]}\")\n        elif path[-1] != n - 1:\n            errors.append(f\"Path must end at final destination ({n-1}), got {path[-1]}\")\n        \n        if len(path) != len(set(path)):\n            errors.append(\"Path contains duplicate nodes\")\n        \n        path_visited = [0] * n\n        for node in path:\n            if 0 <= node < n:\n                path_visited[node] = 1\n        \n        for i in range(n):\n            if visited_stations[i] != path_visited[i]:\n                errors.append(f\"visited_stations mismatch at index {i}: array={visited_stations[i]}, path={path_visited[i]}\")\n        \n        actual_distance = 0\n        actual_points = 0\n        \n        for i in range(len(path) - 1):\n            curr, next_node = path[i], path[i + 1]\n            if curr < 0 or curr >= n or next_node < 0 or next_node >= n:\n                errors.append(f\"Invalid node in path: {curr} -> {next_node}\")\n                continue\n            dx = stations[curr][0] - stations[next_node][0]\n            dy = stations[curr][1] - stations[next_node][1]\n            actual_distance += math.sqrt(dx*dx + dy*dy)\n        \n        for node in path:\n            if 0 <= node < n:\n                actual_points += stations[node][2]\n        \n        if abs(actual_distance - total_distance) > 0.01:\n            errors.append(f\"Distance inconsistency: calculated {actual_distance:.6f}, declared {total_distance:.6f}\")\n        \n        if actual_points != total_points:\n            errors.append(f\"Points inconsistency: calculated {actual_points}, declared {total_points}\")\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_points = reference_solution[\"total_points\"]\n            if optimal_points == 0:\n                optimality_score = 1.0 if total_points == 0 else 0.0\n            else:\n                gap = abs(optimal_points - total_points) / abs(optimal_points)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}