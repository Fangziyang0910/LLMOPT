{
  "problem_id": "travelling_salesman_problem_001",
  "metadata": {
    "problem_type": "Traveling Salesman Problem",
    "difficulty": "simple"
  },
  "problem_description": "A regional service coordinator is tasked with optimizing a complex multi-stop delivery itinerary across a diverse geographical territory that encompasses approximately 10,000 square kilometers of mixed urban and rural landscape. The operational area is systematically mapped using a精密 grid system where each coordinate increment corresponds to exactly one kilometer of actual ground distance, with the cartographic origin point (0,0) strategically positioned at the southwestern boundary marker of the service jurisdiction. The coordinator's logistical challenge involves orchestrating a comprehensive routing solution that originates from the central dispatch facility situated at coordinates (75, 98), which serves as both the starting point and final destination for the entire field operation. The mission requires the precise execution of nine distinct customer engagements, each representing a unique service delivery point that must be accessed exactly once during the operational cycle before the route concludes back at the dispatch facility. The customer locations are irregularly distributed throughout the territory, reflecting real-world geographical constraints: Customer A's residence is positioned at (62, 90) in the northern sector, Customer B occupies location (41, 77) in the central-west region, Customer C is established at (36, 92) near the northwestern boundary, Customer D's site is found at (23, 65) in the western corridor, Customer E operates from (24, 2) in the southern extremity, Customer F maintains position (36, 10) in the south-central area, Customer G is located at (73, 35) in the eastern sector, Customer H resides at (61, 24) in the southeast quadrant, and Customer I is situated at (30, 57) in the central-western zone. The navigation protocol employs direct point-to-point traversal along optimal straight-line trajectories, with the digital mapping system providing precise kilometer-based distance calculations between any two coordinate pairs. The coordinator must determine the most efficient sequence of customer visits that minimizes total travel distance while completing the required circuit.",
  "solution_format_description": "Print the following fields: - tour: complete route visiting all locations. - total_distance: total travel distance.",  
  "structured_data": {
    "num_nodes": 10,
    "nodes": [[75, 98], [62, 90], [41, 77], [36, 92], [23, 65], [24, 2], [36, 10], [73, 35], [61, 24], [30, 57]]
  },
  "reference_solution": {
    "tour": [0, 7, 8, 6, 5, 9, 4, 2, 3, 1, 0],
    "total_distance": 267.13
  },
  "solver_code": "from cpmpy import *\nimport json\nimport math\n\nnum_nodes = 10\nnodes = [\n    [75, 98], [62, 90], [41, 77], [36, 92], [23, 65],\n    [24, 2], [36, 10], [73, 35], [61, 24], [30, 57]\n]\n\ndist_matrix = [[0.0 for _ in range(num_nodes)] for _ in range(num_nodes)]\nfor i in range(num_nodes):\n    for j in range(num_nodes):\n        if i != j:\n            xi, yi = nodes[i]\n            xj, yj = nodes[j]\n            dist_matrix[i][j] = math.sqrt((xi - xj)**2 + (yi - yj)**2)\n\nmodel = Model()\nx = boolvar(shape=(num_nodes, num_nodes))\n\nfor i in range(num_nodes):\n    model += sum(x[i, j] for j in range(num_nodes) if i != j) == 1\n\nfor j in range(num_nodes):\n    model += sum(x[i, j] for i in range(num_nodes) if i != j) == 1\n\nu = intvar(0, num_nodes - 1, shape=num_nodes)\nfor i in range(1, num_nodes):\n    for j in range(1, num_nodes):\n        if i != j:\n            model += u[i] - u[j] + num_nodes * x[i, j] <= num_nodes - 1\n\nscale_factor = 10000\nscaled_flat_distances = [int(dist_matrix[r][c] * scale_factor) for r in range(num_nodes) for c in range(num_nodes)]\nobjective_expr = sum(x[i, j] * scaled_flat_distances[i * num_nodes + j] for i in range(num_nodes) for j in range(num_nodes) if i != j)\nmodel.minimize(objective_expr)\n\nif model.solve():\n    tour_result = [0]\n    current_city = 0\n    visited = {0}\n    \n    while len(tour_result) < num_nodes:\n        for j in range(num_nodes):\n            if j not in visited and x[current_city, j].value():\n                tour_result.append(j)\n                visited.add(j)\n                current_city = j\n                break\n    \n    tour_result.append(0)\n    \n    solution = {\n        \"tour\": tour_result,\n        \"total_distance\": round(float(objective_expr.value()) / scale_factor, 2)\n    }\n    print(json.dumps(solution))\nelse:\n    print(json.dumps({\"tour\": [], \"total_distance\": -1}))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"tour\", \"total_distance\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        tour = solution[\"tour\"]\n        total_distance = solution[\"total_distance\"]\n        num_nodes = structured_data[\"num_nodes\"]\n        errors = []\n        \n        if not isinstance(tour, list):\n            errors.append(\"Tour must be a list.\")\n        \n        if isinstance(tour, list):\n            if len(tour) == 0 or tour[0] != 0 or tour[-1] != 0:\n                errors.append(\"Tour must start and end at node 0.\")\n            \n            if len(tour) > 0:\n                visited_nodes = set(tour[:-1])\n                expected_nodes = set(range(num_nodes))\n                if visited_nodes != expected_nodes:\n                    errors.append(\"Tour must visit each node exactly once (excluding final return to 0).\")\n        \n        if not isinstance(total_distance, (int, float)):\n            errors.append(\"Total distance must be a number.\")\n        \n        if len(errors) > 0:\n            return {\n                \"is_valid\": False,\n                \"validation_errors\": errors,\n                \"optimality_score\": 0.0\n            }\n        \n        optimal_value = reference_solution[\"total_distance\"]\n        if optimal_value == 0:\n            optimality_score = 1.0 if total_distance == 0 else 0.0\n        else:\n            gap = abs(optimal_value - total_distance) / abs(optimal_value)\n            optimality_score = max(0, 1 - gap)\n            \n        return {\n            \"is_valid\": True,\n            \"validation_errors\": [],\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}