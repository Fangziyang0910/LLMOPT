{
  "problem_id": "unconstrained_guillotine_cutting_002",
  "metadata": {
    "problem_type": "unconstrained guillotine cutting problem",
    "difficulty": "medium"
  },
  "problem_description": "A sophisticated agricultural enterprise is undertaking sequential rectangular bed extraction from a greenhouse measuring length 250 centimeters and width 250 centimeters. This implementation utilizes guillotine cutting methodology characterized by linear edge-to-edge incisions extending from one perimeter boundary to its opposing counterpart across the entire material substrate. The unconstrained framework imposes no limitations on the hierarchical organization or chronological sequencing of cutting operations. The enterprise maintains twenty distinct bed configurations with dimensional parameters and agricultural yield valuations. Certain configurations exhibit fixed orientation constraints while others permit 90-degree rotational adjustment. Greenhouse specifications are length 250 centimeters and width 250 centimeters. Bed inventory encompasses twenty distinct configurations: the first bed has length 120 centimeters and width 133 centimeters with yield of 159.60 hundred dollars and fixed orientation; the second bed has length 135 centimeters and width 186 centimeters with yield of 251.10 hundred dollars and fixed orientation; the third bed has length 86 centimeters and width 75 centimeters with yield of 64.50 hundred dollars and fixed orientation; the fourth bed has length 103 centimeters and width 73 centimeters with yield of 75.19 hundred dollars and fixed orientation; the fifth bed has length 66 centimeters and width 85 centimeters with yield of 56.10 hundred dollars and fixed orientation; the sixth bed has length 135 centimeters and width 97 centimeters with yield of 130.95 hundred dollars and fixed orientation; the seventh bed has length 91 centimeters and width 175 centimeters with yield of 159.25 hundred dollars and fixed orientation; the eighth bed has length 131 centimeters and width 176 centimeters with yield of 230.56 hundred dollars and fixed orientation; the ninth bed has length 71 centimeters and width 176 centimeters with yield of 124.96 hundred dollars and fixed orientation; the tenth bed has length 153 centimeters and width 72 centimeters with yield of 110.16 hundred dollars and fixed orientation; the eleventh bed has length 87 centimeters and width 148 centimeters with yield of 128.76 hundred dollars and can be rotated; the twelfth bed has length 168 centimeters and width 107 centimeters with yield of 179.76 hundred dollars and can be rotated; the thirteenth bed has length 118 centimeters and width 90 centimeters with yield of 106.20 hundred dollars and can be rotated; the fourteenth bed has length 140 centimeters and width 109 centimeters with yield of 152.60 hundred dollars and can be rotated; the fifteenth bed has length 132 centimeters and width 159 centimeters with yield of 209.88 hundred dollars and can be rotated; the sixteenth bed has length 152 centimeters and width 93 centimeters with yield of 141.36 hundred dollars and can be rotated; the seventeenth bed has length 135 centimeters and width 68 centimeters with yield of 91.80 hundred dollars and can be rotated; the eighteenth bed has length 121 centimeters and width 158 centimeters with yield of 191.18 hundred dollars and can be rotated; the nineteenth bed has length 68 centimeters and width 94 centimeters with yield of 63.92 hundred dollars and can be rotated; the twentieth bed has length 155 centimeters and width 76 centimeters with yield of 117.80 hundred dollars and can be rotated. The agricultural enterprise must determine the optimal bed arrangement to maximize total agricultural yield value within the greenhouse boundaries, governed by fundamental constraints that beds must not overlap and must be completely contained within the greenhouse boundaries.",
  "solution_format_description": "Print the following fields: - placements: for each bed, list placement with index, x, y, rotation. - total_yield_value: total value of placed beds.",
  "structured_data": {
    "greenhouse_dimensions": [250, 250],
    "beds": [
      [120, 133, 159.6, 1], 
      [135, 186, 251.1, 1], 
      [86, 75, 64.5, 1], 
      [103, 73, 75.19, 1], 
      [66, 85, 56.1, 1], 
      [135, 97, 130.95, 1], 
      [91, 175, 159.25, 1], 
      [131, 176, 230.56, 1], 
      [71, 176, 124.96, 1], 
      [153, 72, 110.16, 1], 
      [87, 148, 128.76, 0], 
      [168, 107, 179.76, 0], 
      [118, 90, 106.2, 0], 
      [140, 109, 152.6, 0], 
      [132, 159, 209.88, 0], 
      [152, 93, 141.36, 0], 
      [135, 68, 91.8, 0], 
      [121, 158, 191.18, 0], 
      [68, 94, 63.92, 0], 
      [155, 76, 117.8, 0]
    ]
  },
  "reference_solution": {
    "placements": [
      [2, 5, 175, 0], 
      [6, 0, 0, 0], 
      [12, 159, 0, 1], 
      [14, 91, 118, 1], 
      [18, 91, 0, 0]
    ],
    "total_yield_value": 603.75
  },
  "solver_code": "from cpmpy import *\nimport json\n\ngreenhouse_dimensions = [250, 250]\nbeds = [[120, 133, 159.6, 1], [135, 186, 251.1, 1], [86, 75, 64.5, 1], [103, 73, 75.19, 1], [66, 85, 56.1, 1], [135, 97, 130.95, 1], [91, 175, 159.25, 1], [131, 176, 230.56, 1], [71, 176, 124.96, 1], [153, 72, 110.16, 1], [87, 148, 128.76, 0], [168, 107, 179.76, 0], [118, 90, 106.2, 0], [140, 109, 152.6, 0], [132, 159, 209.88, 0], [152, 93, 141.36, 0], [135, 68, 91.8, 0], [121, 158, 191.18, 0], [68, 94, 63.92, 0], [155, 76, 117.8, 0]]\nallow_rotation = 1\nnum_beds = len(beds)\n\nx = intvar(0, greenhouse_dimensions[0], shape=num_beds)\ny = intvar(0, greenhouse_dimensions[1], shape=num_beds)\norientation = boolvar(shape=num_beds) if allow_rotation else [0] * num_beds\nselected = boolvar(shape=num_beds)\n\nconstraints = []\n\nfor i in range(num_beds):\n    length, width, yield_value, fixed_orientation = beds[i]\n    \n    if allow_rotation and fixed_orientation == 0:\n        eff_length = length * (1 - orientation[i]) + width * orientation[i]\n        eff_width = width * (1 - orientation[i]) + length * orientation[i]\n    else:\n        eff_length = length\n        eff_width = width\n        \n    constraints += [selected[i].implies(x[i] + eff_length <= greenhouse_dimensions[0])]\n    constraints += [selected[i].implies(y[i] + eff_width <= greenhouse_dimensions[1])]\n    \n    for j in range(i + 1, num_beds):\n        length_j, width_j, yield_value_j, fixed_orientation_j = beds[j]\n        \n        if allow_rotation and fixed_orientation_j == 0:\n            eff_length_j = length_j * (1 - orientation[j]) + width_j * orientation[j]\n            eff_width_j = width_j * (1 - orientation[j]) + length_j * orientation[j]\n        else:\n            eff_length_j = length_j\n            eff_width_j = width_j\n            \n        constraints += [(selected[i] & selected[j]).implies(\n            (x[i] + eff_length <= x[j]) | (x[j] + eff_length_j <= x[i]) | (y[i] + eff_width <= y[j]) | (y[j] + eff_width_j <= y[i])\n        )]\n\nobjective = sum(selected[i] * beds[i][2] for i in range(num_beds))\n\nmodel = Model(constraints)\nmodel.maximize(objective)\n\nif model.solve():\n    placements = []\n    total_yield_value = 0\n    for i in range(num_beds):\n        if selected[i].value() == 1:\n            if allow_rotation and beds[i][3] == 0:\n                orient = int(orientation[i].value())\n            else:\n                orient = 0\n            placements.append([i, int(x[i].value()), int(y[i].value()), orient])\n            total_yield_value += beds[i][2]\n    \n    result = {\"placements\": placements, \"total_yield_value\": total_yield_value}\n    print(json.dumps(result))\nelse:\n    print(json.dumps({\"placements\": [], \"total_yield_value\": 0}))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        if isinstance(candidate_solution, str):\n            solution = json.loads(candidate_solution)\n        else:\n            solution = candidate_solution\n    except Exception:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n\n    required_fields = [\"placements\", \"total_yield_value\"]\n    missing = [f for f in required_fields if f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n\n    try:\n        placements = solution[\"placements\"]\n        total_yield_value = solution[\"total_yield_value\"]\n        beds = structured_data[\"beds\"]\n        greenhouse_dimensions = structured_data[\"greenhouse_dimensions\"]\n        allow_rotation = 1\n        errors = []\n\n        placed_indices = [p[0] for p in placements]\n        if len(placed_indices) != len(set(placed_indices)):\n            errors.append(\"Duplicate bed placements detected.\")\n\n        for placement in placements:\n            bed_idx, x, y, orientation = placement\n            \n            if not (isinstance(bed_idx, int) and 0 <= bed_idx < len(beds)):\n                errors.append(f\"Invalid bed index {bed_idx}\")\n                continue\n            \n            if not (isinstance(x, int) and isinstance(y, int)):\n                errors.append(f\"Coordinates must be integers for bed {bed_idx}\")\n                continue\n            \n            if orientation not in [0, 1]:\n                errors.append(f\"Invalid orientation {orientation} for bed {bed_idx}\")\n                continue\n            \n            length, width, yield_value, fixed_orientation = beds[bed_idx]\n            if orientation == 0:\n                bed_length, bed_width = length, width\n            else:\n                if not allow_rotation or fixed_orientation == 1:\n                    errors.append(f\"Bed {bed_idx} cannot be rotated\")\n                    continue\n                bed_length, bed_width = width, length\n            \n            if x < 0 or y < 0 or x + bed_length > greenhouse_dimensions[0] or y + bed_width > greenhouse_dimensions[1]:\n                errors.append(f\"Bed {bed_idx} out of boundaries\")\n\n        placed_rects = []\n        for placement in placements:\n            bed_idx, x, y, orientation = placement\n            length, width, _, fixed_orientation = beds[bed_idx]\n            \n            if orientation == 0:\n                bed_length, bed_width = length, width\n            else:\n                bed_length, bed_width = width, length\n            \n            placed_rects.append({\n                \"x\": x, \"y\": y, \n                \"length\": bed_length, \"width\": bed_width,\n                \"idx\": bed_idx\n            })\n        \n        for i in range(len(placed_rects)):\n            for j in range(i + 1, len(placed_rects)):\n                r1, r2 = placed_rects[i], placed_rects[j]\n                if not (r1[\"x\"] + r1[\"length\"] <= r2[\"x\"] or \n                       r2[\"x\"] + r2[\"length\"] <= r1[\"x\"] or\n                       r1[\"y\"] + r1[\"width\"] <= r2[\"y\"] or \n                       r2[\"y\"] + r2[\"width\"] <= r1[\"y\"]):\n                    errors.append(f\"Overlap between bed {r1['idx']} and bed {r2['idx']}\")\n\n        is_valid = len(errors) == 0\n        if is_valid:\n            optimal_value = reference_solution[\"total_yield_value\"]\n            if optimal_value == 0:\n                optimality_score = 1.0 if total_yield_value == 0 else 0.0\n            else:\n                gap = abs(optimal_value - total_yield_value) / abs(optimal_value)\n                optimality_score = max(0, 1 - gap)\n        else:\n            optimality_score = 0.0\n\n        return {\n            \"is_valid\": is_valid,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n\n    except Exception:\n        return {\"is_valid\": False, \"validation_errors\": [\"Evaluation error\"], \"optimality_score\": 0.0}"
}