{
  "problem_id": "assortment_problem_002",
  "metadata": {
    "problem_type": "Assortment Problem",
    "difficulty": "medium"
  },
  "problem_description": "A glass factory needs to cut smaller rectangular glass panels from two available standard sheet sizes to fulfill an order. The factory has two types of standard glass sheets: 1) Large sheets of 80 cm by 73 cm; 2) Medium sheets of 61 cm by 52 cm. They need to produce four types of smaller panels for a project:\n1. Small panels: 26 cm by 25 cm, they need at least 2 and at most 5 of these.\n2. Medium panels: 30 cm by 28 cm, they need at least 2 and at most 6 of these.\n3. Narrow panels: 34 cm by 17 cm, they need at least 1 and at most 3 of these.\n4. Tiny panels: 18 cm by 7 cm, they need at least 2 and at most 4 of these.\n\nThe factory wants to determine how to cut these panels from the standard sheets to minimize material waste. They can use as many sheets of each type as needed, but they want to limit themselves to using at most two different sheet types in their cutting plan. Each panel can be cut with its original orientation or rotated by 90 degrees. All panels must fit completely within the sheets, and no panels can overlap on the same sheet.",
  "solution_format_description": "Print the following fields: - waste_rate: percentage of fabric wasted. - sheet_instances: for each sheet_type, list placements with piece, x, y, orientation. - panel_counts: how many of each panel type are cut. - total_sheet_area: sum of all sheet areas used. - total_used_area: sum of all panel areas.",
  "structured_data": {
    "num_sheets": 2,
    "num_panels": 4,
    "sheets": [
      [80, 73],
      [61, 52]
    ],
    "panels": [
      [26, 25, 2, 5],
      [30, 28, 2, 6],
      [34, 17, 1, 3],
      [18, 7, 2, 4]
    ]
  },
  "reference_solution": {
    "waste_rate": 0.038356164383561646,
    "sheet_instances": [
      [
        [1, 53, 47, 0],
        [1, 27, 48, 0],
        [1, 0, 48, 0],
        [2, 18, 0, 1],
        [2, 52, 17, 1],
        [3, 46, 0, 0],
        [3, 1, 7, 1],
        [3, 18, 30, 0],
        [4, 0, 0, 0],
        [4, 0, 41, 0]
      ]
    ],
    "panel_counts": [3, 2, 3, 2],
    "total_sheet_area": 5840,
    "total_used_area": 5616
  },
  "solver_code": "from cpmpy import *\nimport json\n\nnum_sheets = 2\nnum_panels = 4\n\nsheets = [\n    [80, 73],\n    [61, 52]\n]\n\npanels = [\n    [26, 25, 2, 5],\n    [30, 28, 2, 6],\n    [34, 17, 1, 3],\n    [18, 7, 2, 4]\n]\n\nS = num_sheets\nT = num_panels\n\nsheet_dims = {}\nsheet_area = {}\nfor i, sheet in enumerate(sheets):\n    sheet_dims[i+1] = (sheet[0], sheet[1])\n    sheet_area[i+1] = sheet[0] * sheet[1]\n\npanel_width = [panel[0] for panel in panels]\npanel_height = [panel[1] for panel in panels]\npanel_min = [panel[2] for panel in panels]\npanel_max = [panel[3] for panel in panels]\npanel_area = [panel_width[i] * panel_height[i] for i in range(T)]\n\nmax_sheet_types_in_plan = 2\nM = sum(panel_max)\n\nplacements_per_type = panel_max[:]\ntotal_placements = sum(placements_per_type)\n\nmax_sheet_width = max(w for (w, h) in sheet_dims.values())\nmax_sheet_height = max(h for (w, h) in sheet_dims.values())\n\ntype_of_placement = []\nlocal_index_of_placement = []\nfor t in range(T):\n    for p in range(placements_per_type[t]):\n        type_of_placement.append(t)\n        local_index_of_placement.append(p)\n\nmodel = Model()\n\npanel_count = intvar(min(panel_min), max(panel_max), shape=T, name=\"panel_count\")\nfor i in range(T):\n    model += panel_count[i] >= panel_min[i]\n    model += panel_count[i] <= panel_max[i]\n\nsheet_instance_type = intvar(0, S, shape=M, name=\"sheet_instance_type\")\nnumber_of_sheets_of_type = intvar(0, M, shape=S, name=\"number_of_sheets_of_type\")\nsheet_type_used = boolvar(shape=S, name=\"sheet_type_used\")\n\nplacement_used = boolvar(shape=total_placements, name=\"placement_used\")\nsheet_index_of_placement = intvar(1, M, shape=total_placements, name=\"sheet_index_of_placement\")\nx = intvar(0, max_sheet_width, shape=total_placements, name=\"x\")\ny = intvar(0, max_sheet_height, shape=total_placements, name=\"y\")\norientation = boolvar(shape=total_placements, name=\"orientation\")\n\nplaced_width = intvar(0, max_sheet_width, shape=total_placements, name=\"placed_width\")\nplaced_height = intvar(0, max_sheet_height, shape=total_placements, name=\"placed_height\")\nplacement_area = intvar(0, max(panel_area), shape=total_placements, name=\"placement_area\")\n\nfor t in range(T):\n    indices = [k for k in range(total_placements) if type_of_placement[k] == t]\n    model += sum([placement_used[k] for k in indices]) == panel_count[t]\n\nfor s in range(1, S + 1):\n    model += number_of_sheets_of_type[s - 1] == sum([sheet_instance_type[i] == s for i in range(M)])\n    model += number_of_sheets_of_type[s - 1] >= sheet_type_used[s - 1]\n    model += number_of_sheets_of_type[s - 1] <= M * sheet_type_used[s - 1]\n\nmodel += sum(sheet_type_used) <= max_sheet_types_in_plan\n\nfor i in range(M - 1):\n    model += sheet_instance_type[i] >= sheet_instance_type[i + 1]\n\nnum_declared = intvar(0, M, name=\"num_declared\")\nmodel += num_declared == sum([sheet_instance_type[i] != 0 for i in range(M)])\nmodel += num_declared == sum(number_of_sheets_of_type)\n\nfor k in range(total_placements):\n    model += placement_used[k].implies(sheet_index_of_placement[k] <= num_declared)\n\nfor i in range(M):\n    model += (sheet_instance_type[i] != 0).implies(\n        sum([ (placement_used[k] & (sheet_index_of_placement[k] == i + 1)) for k in range(total_placements)]) >= 1\n    )\n\nwidth_list = [0] + [sheet_dims[s][0] for s in range(1, S+1)]\nheight_list = [0] + [sheet_dims[s][1] for s in range(1, S+1)]\nwidth_of_instance = [Element(width_list, sheet_instance_type[i]) for i in range(M)]\nheight_of_instance = [Element(height_list, sheet_instance_type[i]) for i in range(M)]\n\nfor k in range(total_placements):\n    t = type_of_placement[k]\n    pw = panel_width[t]\n    ph = panel_height[t]\n    model += placed_width[k] == pw + orientation[k] * (ph - pw)\n    model += placed_height[k] == ph + orientation[k] * (pw - ph)\n    model += placement_area[k] == placement_used[k] * panel_area[t]\n\n    for i in range(M):\n        model += (placement_used[k] & (sheet_index_of_placement[k] == i + 1)).implies(\n            x[k] + placed_width[k] <= width_of_instance[i]\n        )\n        model += (placement_used[k] & (sheet_index_of_placement[k] == i + 1)).implies(\n            y[k] + placed_height[k] <= height_of_instance[i]\n        )\n\nfor a in range(total_placements):\n    for b in range(a + 1, total_placements):\n        same_sheet_and_used = placement_used[a] & placement_used[b] & (sheet_index_of_placement[a] == sheet_index_of_placement[b])\n        no_overlap = (\n            (x[a] + placed_width[a] <= x[b])\n            | (x[b] + placed_width[b] <= x[a])\n            | (y[a] + placed_height[a] <= y[b])\n            | (y[b] + placed_height[b] <= y[a])\n        )\n        model += same_sheet_and_used.implies(no_overlap)\n\ntotal_sheet_area = intvar(0, sum(sheet_area.values()) * M, name=\"total_sheet_area\")\nmodel += total_sheet_area == sum([number_of_sheets_of_type[s] * sheet_area[s + 1] for s in range(S)])\ntotal_used_area = intvar(0, sum(panel_area) * M, name=\"total_used_area\")\nmodel += total_used_area == sum(placement_area)\n\nwaste_area = intvar(0, sum(sheet_area.values()) * M, name=\"waste_area\")\nmodel += waste_area == total_sheet_area - total_used_area\n\nmodel.minimize(waste_area)\n\nsolved = model.solve(time_limit=55)\n\nif not solved:\n    result = {\n        \"waste_rate\": 1.0,\n        \"sheet_instances\": [[1, []]],\n        \"panel_counts\": [panel[2] for panel in panels],\n        \"total_sheet_area\": sheets[0][0] * sheets[0][1],\n        \"total_used_area\": 0\n    }\n    print(json.dumps(result))\nelse:\n    panel_count_val = panel_count.value().tolist()\n    sheet_instance_type_val = sheet_instance_type.value().tolist()\n    placement_used_val = [int(b) for b in placement_used.value().tolist()]\n    sheet_index_of_placement_val = sheet_index_of_placement.value().tolist()\n    x_val = x.value().tolist()\n    y_val = y.value().tolist()\n    orientation_val = [int(b) for b in orientation.value().tolist()]\n\n    total_sheet_area_val = int(total_sheet_area.value())\n    total_used_area_val = int(total_used_area.value())\n    waste_area_val = int(waste_area.value())\n    waste_rate = (waste_area_val / total_sheet_area_val) if total_sheet_area_val > 0 else 0.0\n\n    sheet_instances = []\n    for i in range(M):\n        stype = int(sheet_instance_type_val[i])\n        if stype == 0:\n            continue\n        placements = []\n        for k in range(total_placements):\n            if placement_used_val[k] == 1 and sheet_index_of_placement_val[k] == i + 1:\n                piece_id = type_of_placement[k] + 1\n                placements.append([piece_id, int(x_val[k]), int(y_val[k]), int(orientation_val[k])])\n        sheet_instances.append([stype, placements])\n\n    solution = {\n        \"waste_rate\": float(waste_rate),\n        \"sheet_instances\": sheet_instances,\n        \"panel_counts\": [int(c) for c in panel_count_val],\n        \"total_sheet_area\": total_sheet_area_val,\n        \"total_used_area\": total_used_area_val\n    }\n\n    print(json.dumps(solution))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n\n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n\n    required_fields = [\"waste_rate\", \"sheet_instances\", \"panel_counts\", \"total_sheet_area\", \"total_used_area\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n\n    try:\n        waste_rate = solution[\"waste_rate\"]\n        sheet_instances = solution[\"sheet_instances\"]\n        panel_counts = solution[\"panel_counts\"]\n        total_sheet_area = solution[\"total_sheet_area\"]\n        total_used_area = solution[\"total_used_area\"]\n        \n        sheets = structured_data[\"sheets\"]\n        panels = structured_data[\"panels\"]\n        errors = []\n        \n        if len(panel_counts) != len(panels):\n            errors.append(f\"Panel counts length mismatch: expected {len(panels)}, got {len(panel_counts)}\")\n        \n        for i, panel in enumerate(panels):\n            count = panel_counts[i] if i < len(panel_counts) else 0\n            if count < panel[2] or count > panel[3]:\n                errors.append(f\"Panel count violation for panel type {i+1}: count = {count}, required min = {panel[2]}, max = {panel[3]}\")\n        \n        used_sheet_types = set()\n        for instance in sheet_instances:\n            if len(instance) != 2:\n                errors.append(\"Invalid sheet instance structure\")\n                continue\n            \n            sheet_type = instance[0]\n            placements = instance[1]\n            \n            if not (1 <= sheet_type <= len(sheets)):\n                errors.append(f\"Invalid sheet type: {sheet_type}\")\n                continue\n            \n            used_sheet_types.add(sheet_type)\n            \n            for placement in placements:\n                if len(placement) != 4:\n                    errors.append(\"Invalid placement structure\")\n                    continue\n                \n                piece_type = placement[0]\n                if not (1 <= piece_type <= len(panels)):\n                    errors.append(f\"Invalid piece type in placement: {piece_type}\")\n                    continue\n                \n                sheet_data = sheets[sheet_type - 1]\n                piece_data = panels[piece_type - 1]\n                \n                if placement[3] == 0:\n                    piece_len, piece_wid = piece_data[0], piece_data[1]\n                elif placement[3] == 1:\n                    piece_len, piece_wid = piece_data[1], piece_data[0]\n                else:\n                    errors.append(f\"Invalid orientation: {placement[3]}\")\n                    continue\n                \n                if (placement[1] < 0 or placement[2] < 0 or \n                    placement[1] + piece_len > sheet_data[0] or \n                    placement[2] + piece_wid > sheet_data[1]):\n                    errors.append(f\"Piece {piece_type} out of sheet boundaries\")\n        \n        if len(used_sheet_types) > 2:\n            errors.append(f\"More than 2 sheet types used: {len(used_sheet_types)}\")\n        \n        calc_total_used_area = 0\n        actual_piece_counts = [0] * len(panels)\n        \n        for instance in sheet_instances:\n            placements = instance[1]\n            for placement in placements:\n                piece_type = placement[0] - 1\n                piece_data = panels[piece_type]\n                \n                if placement[3] == 0:\n                    area = piece_data[0] * piece_data[1]\n                else:\n                    area = piece_data[1] * piece_data[0]\n                \n                calc_total_used_area += area\n                actual_piece_counts[piece_type] += 1\n        \n        if abs(calc_total_used_area - total_used_area) > 1e-6:\n            errors.append(f\"Used area inconsistency: calculated {calc_total_used_area}, declared {total_used_area}\")\n        \n        for i, (actual, declared) in enumerate(zip(actual_piece_counts, panel_counts)):\n            if actual != declared:\n                errors.append(f\"Panel count inconsistency for type {i+1}: actual {actual}, declared {declared}\")\n        \n        if total_sheet_area > 0:\n            calc_waste_rate = (total_sheet_area - total_used_area) / total_sheet_area\n            if abs(calc_waste_rate - waste_rate) > 1e-6:\n                errors.append(f\"Waste rate inconsistency: calculated {calc_waste_rate}, declared {waste_rate}\")\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_waste_rate = reference_solution[\"waste_rate\"]\n            if optimal_waste_rate == 0:\n                optimality_score = 1.0 if waste_rate == 0 else 0.0\n            else:\n                gap = abs(optimal_waste_rate - waste_rate) / abs(optimal_waste_rate)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}