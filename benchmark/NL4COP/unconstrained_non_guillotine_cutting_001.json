{
  "problem_id": "unconstrained_non_guillotine_cutting_001",
  "metadata": {
    "problem_type": "Unconstrained Non-Guillotine Cutting Problem",
    "difficulty": "simple"
  },
  "problem_description": "An advanced manufacturing optimization facility is addressing a sophisticated spatial arrangement challenge involving non-sequential panel placement on a rectangular workspace measuring 20 by 15 centimeters. This non-guillotine cutting approach allows components to be placed freely anywhere on the board without requiring cuts to follow any specific sequence or extend across the entire workspace. The manufacturing inventory encompasses three distinct fabric categories: Category 1 components with dimensions 5x4 centimeters, valuation of 20 hundred dollars, and maximum allowable quantity of 2 pieces; Category 2 components with dimensions 6x3 centimeters, valuation of 18 hundred dollars, and maximum allowable quantity of 2 pieces; Category 3 components with dimensions 4x4 centimeters, valuation of 16 hundred dollars, and maximum allowable quantity of 2 pieces. Each component permits 90-degree rotational adjustment and can be positioned at any coordinate within the workspace boundaries, provided that spatial overlapping is avoided and complete containment within the perimeter is maintained. Manufacturing engineers must determine how to arrange the components to achieve maximum total value, with no constraints on placement order or cutting sequence.",
  "solution_format_description": "Print the following fields: - placements: for each piece, list placement with type, x, y, rotation. - total_value: total value of placed pieces.",
  "structured_data": {
    "table_dimensions": [20, 15],
    "fabric_types": [[5, 4, 20, 2], [6, 3, 18, 2], [4, 4, 16, 2]]
  },
  "reference_solution": {
    "placements": [
      [0, 6, 8, 0], 
      [0, 2, 0, 0], 
      [1, 0, 10, 0], 
      [1, 6, 12, 0], 
      [2, 12, 9, 1], 
      [2, 9, 4, 1]
    ],
    "total_value": 108
  },
  "solver_code": "from cpmpy import *\nimport json\n\ntable_dimensions = [20, 15]\nfabric_types = [[5, 4, 20, 2], [6, 3, 18, 2], [4, 4, 16, 2]]\nallow_rotation = 1\n\nplacements = []\nfor fabric_type_idx in range(len(fabric_types)):\n    for idx in range(fabric_types[fabric_type_idx][3]):\n        used = boolvar(name=f\"used_{fabric_type_idx}_{idx}\")\n        x = intvar(0, table_dimensions[0], name=f\"x_{fabric_type_idx}_{idx}\")\n        y = intvar(0, table_dimensions[1], name=f\"y_{fabric_type_idx}_{idx}\")\n        orientation = boolvar(name=f\"orientation_{fabric_type_idx}_{idx}\")\n        placements.append((fabric_type_idx, idx, used, x, y, orientation))\n\nmodel = Model()\n\nfor fabric_type_idx, idx, used, x, y, orientation in placements:\n    width, height, value, max_pieces = fabric_types[fabric_type_idx]\n    \n    if allow_rotation and width != height:\n        orig_fits = (orientation == 0) & (x + width <= table_dimensions[0]) & (y + height <= table_dimensions[1])\n        rot_fits = (orientation == 1) & (x + height <= table_dimensions[0]) & (y + width <= table_dimensions[1])\n        model += used.implies(orig_fits | rot_fits)\n    else:\n        model += used.implies((x + width <= table_dimensions[0]) & (y + height <= table_dimensions[1]))\n        if not allow_rotation:\n            model += used.implies(orientation == 0)\n\nfor i in range(len(placements)):\n    for j in range(i + 1, len(placements)):\n        ft1, idx1, used1, x1, y1, orient1 = placements[i]\n        ft2, idx2, used2, x2, y2, orient2 = placements[j]\n        \n        w1, h1, v1, max1 = fabric_types[ft1]\n        w2, h2, v2, max2 = fabric_types[ft2]\n        \n        width1 = w1 * (1 - orient1) + h1 * orient1\n        height1 = h1 * (1 - orient1) + w1 * orient1\n        width2 = w2 * (1 - orient2) + h2 * orient2\n        height2 = h2 * (1 - orient2) + w2 * orient2\n        \n        no_overlap = (x1 + width1 <= x2) | (x2 + width2 <= x1) | (y1 + height1 <= y2) | (y2 + height2 <= y1)\n        \n        model += (used1 & used2).implies(no_overlap)\n\nfabric_type_counts = []\nfor fabric_type_idx in range(len(fabric_types)):\n    fabric_type_counts.append([])\n    \nfor fabric_type_idx, idx, used, x, y, orientation in placements:\n    fabric_type_counts[fabric_type_idx].append(used)\n    \nfor fabric_type_idx in range(len(fabric_types)):\n    used_count = sum(fabric_type_counts[fabric_type_idx])\n    model += used_count <= fabric_types[fabric_type_idx][3]\n\ntotal_value_expr = 0\nfor fabric_type_idx, idx, used, x, y, orientation in placements:\n    total_value_expr += used * fabric_types[fabric_type_idx][2]\n\nmodel.maximize(total_value_expr)\n\nif model.solve():\n    result = {\"placements\": [], \"total_value\": 0}\n    \n    for fabric_type_idx, idx, used, x, y, orientation in placements:\n        if used.value():\n            width, height, value, max_pieces = fabric_types[fabric_type_idx]\n            if orientation.value() == 0:\n                actual_width, actual_height = width, height\n            else:\n                actual_width, actual_height = height, width\n            \n            result[\"placements\"].append([fabric_type_idx, x.value(), y.value(), int(orientation.value())])\n            result[\"total_value\"] += value\n    \n    print(json.dumps(result))\nelse:\n    print(json.dumps({\"placements\": [], \"total_value\": 0}))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"placements\", \"total_value\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        placements = solution[\"placements\"]\n        total_value = solution[\"total_value\"]\n        table_dimensions = structured_data[\"table_dimensions\"]\n        fabric_types = structured_data[\"fabric_types\"]\n        allow_rotation = 1\n        \n        errors = []\n        \n        fabric_usage = [0] * len(fabric_types)\n        \n        for idx, placement in enumerate(placements):\n            if not isinstance(placement, list) or len(placement) != 4:\n                errors.append(f\"Placement {idx} must be an array with 4 elements [fabric_type, x, y, orientation]\")\n                continue\n            \n            fabric_type_idx = placement[0]\n            x = placement[1]\n            y = placement[2]\n            orientation = placement[3]\n            \n            if not isinstance(fabric_type_idx, int) or fabric_type_idx < 0 or fabric_type_idx >= len(fabric_types):\n                errors.append(f\"Placement {idx} has invalid fabric type index {fabric_type_idx}\")\n                continue\n            \n            if not all(isinstance(val, int) for val in [x, y]):\n                errors.append(f\"Placement {idx} has invalid coordinate values\")\n                continue\n            \n            if not isinstance(orientation, int) or orientation not in [0, 1]:\n                errors.append(f\"Placement {idx} has invalid orientation {orientation}\")\n                continue\n            \n            fabric_usage[fabric_type_idx] += 1\n            if fabric_usage[fabric_type_idx] > fabric_types[fabric_type_idx][3]:\n                errors.append(f\"Fabric type {fabric_type_idx} usage exceeds maximum available\")\n            \n            width, height, value, max_pieces = fabric_types[fabric_type_idx]\n            \n            if orientation == 0:\n                actual_width, actual_height = width, height\n            else:\n                if not allow_rotation:\n                    errors.append(f\"Placement {idx} uses rotation but rotation is not allowed\")\n                    continue\n                actual_width, actual_height = height, width\n            \n            if x < 0 or y < 0 or x + actual_width > table_dimensions[0] or y + actual_height > table_dimensions[1]:\n                errors.append(f\"Placement {idx} is out of table boundaries\")\n        \n        n = len(placements)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if i >= len(placements) or j >= len(placements):\n                    break\n                    \n                p1 = placements[i]\n                p2 = placements[j]\n                \n                x1, y1 = p1[1], p1[2]\n                x2, y2 = p2[1], p2[2]\n                ft1 = p1[0]\n                ft2 = p2[0]\n                \n                w1, h1, v1, max1 = fabric_types[ft1]\n                w2, h2, v2, max2 = fabric_types[ft2]\n                \n                width1 = w1 * (1 - p1[3]) + h1 * p1[3]\n                height1 = h1 * (1 - p1[3]) + w1 * p1[3]\n                width2 = w2 * (1 - p2[3]) + h2 * p2[3]\n                height2 = h2 * (1 - p2[3]) + w2 * p2[3]\n                \n                if not (x1 + width1 <= x2 or x2 + width2 <= x1 or y1 + height1 <= y2 or y2 + height2 <= y1):\n                    errors.append(f\"Placements {i} and {j} overlap\")\n        \n        calculated_value = 0\n        for placement in placements:\n            fabric_type_idx = placement[0]\n            calculated_value += fabric_types[fabric_type_idx][2]\n        \n        if abs(calculated_value - total_value) > 1e-6:\n            errors.append(f\"Total value inconsistency: calculated {calculated_value}, declared {total_value}\")\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_value = reference_solution[\"total_value\"]\n            if optimal_value == 0:\n                optimality_score = 1.0 if total_value == 0 else 0.0\n            else:\n                gap = abs(optimal_value - total_value) / abs(optimal_value)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}