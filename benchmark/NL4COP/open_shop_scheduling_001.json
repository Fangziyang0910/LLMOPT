{
  "problem_id": "open_shop_scheduling_001",
  "metadata": {
    "problem_type": "Open Shop Scheduling Problem",
    "difficulty": "simple"
  },
  "problem_description": "In an advanced computational facility, four independent workflows each contain four computational tasks that require uninterrupted processing on dedicated hardware systems. The system must follow several constraints: first, a workflow cannot process multiple tasks at the same time; second, each hardware system can only handle one task at a time from any workflow; third, tasks within each workflow can be processed in any order. The processing requirements are: Workflow Alpha needs GPU-Cluster for 54 minutes, CPU-Node for 34 minutes, Memory-Array for 61 minutes, and I/O-Subsystem for 2 minutes; Workflow Beta needs Memory-Array for 9 minutes, CPU-Node for 15 minutes, I/O-Subsystem for 89 minutes, and GPU-Cluster for 70 minutes; Workflow Gamma needs CPU-Node for 38 minutes, I/O-Subsystem for 19 minutes, GPU-Cluster for 28 minutes, and Memory-Array for 87 minutes; Workflow Delta needs CPU-Node for 95 minutes, GPU-Cluster for 34 minutes, I/O-Subsystem for 7 minutes, and Memory-Array for 29 minutes. How should we schedule the start time for each task to minimize the time when all workflows are completed?",
  "solution_format_description": "Print the following fields: - start_times: start time for each workflow's task. - makespan: total completion time.",  
  "structured_data": {
    "n_workflows": 4,
    "n_hardware_systems": 4,
    "task_durations": [
      [54, 34, 61, 2],
      [9, 15, 89, 70],
      [38, 19, 28, 87],
      [95, 34, 7, 29]
    ],
    "hardware_assignments": [
      [3, 1, 4, 2],
      [4, 1, 2, 3],
      [1, 2, 3, 4],
      [1, 3, 2, 4]
    ]
  },
  "reference_solution": {
    "start_times": [
      [34, 0, 116, 186],
      [182, 167, 0, 89],
      [129, 167, 0, 29],
      [34, 159, 129, 0]
    ],
    "makespan": 193
  },
  "solver_code": "from cpmpy import *\nimport json\n\nn_workflows = 4\nn_hardware_systems = 4\ntask_durations = [\n    [54, 34, 61, 2],\n    [9, 15, 89, 70],\n    [38, 19, 28, 87],\n    [95, 34, 7, 29]\n]\nhardware_assignments = [\n    [3, 1, 4, 2],\n    [4, 1, 2, 3],\n    [1, 2, 3, 4],\n    [1, 3, 2, 4]\n]\n\nmodel = Model()\n\nstart = intvar(0, sum(sum(row) for row in task_durations), shape=(n_workflows, n_hardware_systems))\n\nmakespan = intvar(0, sum(sum(row) for row in task_durations))\n\nfor i in range(n_workflows):\n    for j1 in range(n_hardware_systems):\n        for j2 in range(j1 + 1, n_hardware_systems):\n            model += (\n                (start[i][j1] + task_durations[i][j1] <= start[i][j2]) |\n                (start[i][j2] + task_durations[i][j2] <= start[i][j1])\n            )\n\nhardware_tasks = {}\nfor i in range(n_workflows):\n    for j in range(n_hardware_systems):\n        hardware_id = hardware_assignments[i][j]\n        if hardware_id not in hardware_tasks:\n            hardware_tasks[hardware_id] = []\n        hardware_tasks[hardware_id].append((i, j))\n\nfor tasks in hardware_tasks.values():\n    if len(tasks) > 1:\n        for idx1 in range(len(tasks)):\n            for idx2 in range(idx1 + 1, len(tasks)):\n                i1, j1 = tasks[idx1]\n                i2, j2 = tasks[idx2]\n                model += (\n                    (start[i1][j1] + task_durations[i1][j1] <= start[i2][j2]) |\n                    (start[i2][j2] + task_durations[i2][j2] <= start[i1][j1])\n                )\n\nfor i in range(n_workflows):\n    for j in range(n_hardware_systems):\n        model += makespan >= start[i][j] + task_durations[i][j]\n\nmodel.minimize(makespan)\n\nif model.solve():\n    start_times_solution = [[start[i][j].value() for j in range(n_hardware_systems)] for i in range(n_workflows)]\n    makespan_solution = makespan.value()\n    \n    result = {\n        \"start_times\": start_times_solution,\n        \"makespan\": int(makespan_solution)\n    }\n    \n    print(json.dumps(result))\nelse:\n    print(json.dumps({\"error\": \"No solution found\"}))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"start_times\", \"makespan\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        start_times = solution[\"start_times\"]\n        makespan = solution[\"makespan\"]\n        n_workflows = structured_data[\"n_workflows\"]\n        n_hardware_systems = structured_data[\"n_hardware_systems\"]\n        task_durations = structured_data[\"task_durations\"]\n        hardware_assignments = structured_data[\"hardware_assignments\"]\n        errors = []\n        \n        if len(start_times) != n_workflows:\n            errors.append(f\"Workflows count mismatch: expected {n_workflows}, got {len(start_times)}\")\n            return {\"is_valid\": False, \"validation_errors\": errors, \"optimality_score\": 0.0}\n            \n        for i in range(n_workflows):\n            if len(start_times[i]) != n_hardware_systems:\n                errors.append(f\"Tasks count mismatch for workflow {i}: expected {n_hardware_systems}, got {len(start_times[i])}\")\n                return {\"is_valid\": False, \"validation_errors\": errors, \"optimality_score\": 0.0}\n                \n        for i in range(n_workflows):\n            for j in range(n_hardware_systems):\n                if not isinstance(start_times[i][j], int) or start_times[i][j] < 0:\n                    errors.append(f\"Invalid start time at workflow {i}, task {j}: {start_times[i][j]}\")\n\n        for i in range(n_workflows):\n            for j1 in range(n_hardware_systems):\n                for j2 in range(j1 + 1, n_hardware_systems):\n                    st1 = start_times[i][j1]\n                    st2 = start_times[i][j2]\n                    et1 = st1 + task_durations[i][j1]\n                    et2 = st2 + task_durations[i][j2]\n                    if not (et1 <= st2 or et2 <= st1):\n                        errors.append(f\"Overlapping tasks in workflow {i}: tasks {j1} and {j2}\")\n\n        hardware_schedules = {}\n        for i in range(n_workflows):\n            for j in range(n_hardware_systems):\n                hardware_id = hardware_assignments[i][j]\n                st = start_times[i][j]\n                et = st + task_durations[i][j]\n                if hardware_id not in hardware_schedules:\n                    hardware_schedules[hardware_id] = []\n                hardware_schedules[hardware_id].append((st, et, i, j))\n        \n        for hardware_id, tasks in hardware_schedules.items():\n            tasks_sorted = sorted(tasks, key=lambda x: x[0])\n            for k in range(1, len(tasks_sorted)):\n                prev_st, prev_et, prev_i, prev_j = tasks_sorted[k - 1]\n                curr_st, curr_et, curr_i, curr_j = tasks_sorted[k]\n                if prev_et > curr_st:\n                    errors.append(f\"Hardware {hardware_id} conflict: workflow {prev_i} task {prev_j} overlaps with workflow {curr_i} task {curr_j}\")\n        \n        if len(errors) == 0:\n            optimal_makespan = reference_solution[\"makespan\"]\n            if optimal_makespan == 0:\n                optimality_score = 1.0 if makespan == 0 else 0.0\n            else:\n                gap = abs(optimal_makespan - makespan) / abs(optimal_makespan)\n                optimality_score = max(0, 1 - gap)\n        else:\n            optimality_score = 0.0\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}