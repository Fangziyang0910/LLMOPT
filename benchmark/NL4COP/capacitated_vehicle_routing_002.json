{
  "problem_id": "capacitated_vehicle_routing_002",
  "metadata": {
    "problem_type": "Capacitated Vehicle Routing Problem",
    "difficulty": "medium"
  },
  "problem_description": "A regional food distribution company needs to deliver fresh supplies to 13 restaurants from their central distribution center using 3 delivery trucks, each with a capacity of 60 tons. All locations are directly accessible by road, with coordinates measured in kilometers using the city center as the origin point (0, 0). The distribution center is at coordinates (50, 50). Table 1 shows restaurant coordinates and supply requirements: [Restaurant ID: (X, Y) | Demand in tons] - 1: (25, 85) | 8; 2: (35, 25) | 12; 3: (85, 75) | 10; 4: (15, 15) | 10; 5: (75, 35) | 12; 6: (65, 85) | 7; 7: (45, 65) | 9; 8: (65, 25) | 10; 9: (35, 45) | 11; 10: (85, 15) | 10; 11: (20, 70) | 12; 12: (80, 80) | 8; 13: (30, 30) | 12. Trucks depart from the distribution center and return after delivering all supplies. Each restaurant must be served by exactly one truck. How should the company plan the routes to minimize total travel distance without exceeding the truck capacity?",
  "solution_format_description": "Print the following fields: - routes: restaurant visiting sequence for each truck. - total_distance: total travel distance across all routes.",
  "structured_data": {
    "num_vehicles": 3,
    "vehicle_capacity": 60,
    "depot": [50, 50],
    "customers": [
      [25, 85, 8],
      [35, 25, 12],
      [85, 75, 10],
      [15, 15, 10],
      [75, 35, 12],
      [65, 85, 7],
      [45, 65, 9],
      [65, 25, 10],
      [35, 45, 11],
      [85, 15, 10],
      [20, 70, 12],
      [80, 80, 8],
      [30, 30, 12]
    ]
  },
  "reference_solution": {
    "routes": [
      [8, 10, 5], 
      [9, 13, 4, 2], 
      [7, 11, 1, 6, 12, 3]
    ], 
    "total_distance": 370.39
  },
  "solver_code": "from cpmpy import *\nimport json\nimport math\n\ndata = {\n    \"num_vehicles\": 3,\n    \"vehicle_capacity\": 60,\n    \"depot\": [50, 50],\n    \"customers\": [\n        [25, 85, 8],\n        [35, 25, 12],\n        [85, 75, 10],\n        [15, 15, 10],\n        [75, 35, 12],\n        [65, 85, 7],\n        [45, 65, 9],\n        [65, 25, 10],\n        [35, 45, 11],\n        [85, 15, 10],\n        [20, 70, 12],\n        [80, 80, 8],\n        [30, 30, 12]\n    ]\n}\n\nnum_vehicles = data[\"num_vehicles\"]\nvehicle_capacity = data[\"vehicle_capacity\"]\ndepot = data[\"depot\"]\ncustomers = data[\"customers\"]\nnum_customers = len(customers)\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\nlocations = [depot] + [[c[0], c[1]] for c in customers]\ndist_matrix = [[distance(locations[i], locations[j]) for j in range(len(locations))] for i in range(len(locations))]\n\nx = boolvar(shape=(num_customers + 1, num_customers + 1, num_vehicles))\ny = boolvar(shape=(num_customers + 1, num_vehicles))\norder = intvar(0, num_customers, shape=(num_customers + 1, num_vehicles))\n\nmodel = Model()\n\nfor i in range(1, num_customers + 1):\n    model += sum(y[i][k] for k in range(num_vehicles)) == 1\n\nfor k in range(num_vehicles):\n    total_demand = sum(customers[i-1][2] * y[i][k] for i in range(1, num_customers + 1))\n    model += total_demand <= vehicle_capacity\n\nfor i in range(1, num_customers + 1):\n    for k in range(num_vehicles):\n        model += sum(x[j][i][k] for j in range(num_customers + 1) if j != i) == y[i][k]\n        model += sum(x[i][j][k] for j in range(num_customers + 1) if j != i) == y[i][k]\n\nfor k in range(num_vehicles):\n    model += sum(x[0][j][k] for j in range(1, num_customers + 1)) <= 1\n\nfor k in range(num_vehicles):\n    model += sum(x[i][0][k] for i in range(1, num_customers + 1)) <= 1\n\nfor k in range(num_vehicles):\n    leaves_depot = sum(x[0][j][k] for j in range(1, num_customers + 1))\n    returns_to_depot = sum(x[i][0][k] for i in range(1, num_customers + 1))\n    model += leaves_depot == returns_to_depot\n\nfor k in range(num_vehicles):\n    for i in range(1, num_customers + 1):\n        for j in range(1, num_customers + 1):\n            if i != j:\n                model += order[i][k] + 1 <= order[j][k] + num_customers * (1 - x[i][j][k])\n\nfor k in range(num_vehicles):\n    for i in range(1, num_customers + 1):\n        model += order[i][k] <= num_customers * y[i][k]\n\nfor k in range(num_vehicles):\n    for i in range(num_customers + 1):\n        model += x[i][i][k] == 0\n\ntotal_distance = sum(dist_matrix[i][j] * x[i][j][k] \n                   for i in range(num_customers + 1) \n                   for j in range(num_customers + 1) \n                   for k in range(num_vehicles))\n\nmodel.minimize(total_distance)\n\ns = SolverLookup.get(\"ortools\", model)\n\nif s.solve():\n    routes = []\n    x_val = x.value()\n    \n    for k in range(num_vehicles):\n        route = []\n        current = 0\n        \n        while True:\n            found = False\n            for j in range(1, num_customers + 1):\n                if x_val[current][j][k]:\n                    route.append(j)\n                    current = j\n                    found = True\n                    break\n            \n            if not found or current == 0:\n                break\n        \n        if route:\n            routes.append(route)\n    \n    actual_distance = 0\n    for k, route in enumerate(routes):\n        if route:\n            actual_distance += dist_matrix[0][route[0]]\n            \n            for i in range(len(route) - 1):\n                actual_distance += dist_matrix[route[i]][route[i + 1]]\n            \n            actual_distance += dist_matrix[route[-1]][0]\n    \n    result = {\n        \"routes\": routes,\n        \"total_distance\": round(actual_distance, 2)\n    }\n    \n    print(json.dumps(result, indent=2))\nelse:\n    print(\"No solution found\")",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"routes\", \"total_distance\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        routes = solution[\"routes\"]\n        total_distance = solution[\"total_distance\"]\n        customers = structured_data[\"customers\"]\n        vehicle_capacity = structured_data[\"vehicle_capacity\"]\n        num_vehicles = structured_data[\"num_vehicles\"]\n        num_customers = len(customers)\n        errors = []\n        \n        if len(routes) > num_vehicles:\n            errors.append(f\"Too many routes: expected max {num_vehicles}, got {len(routes)}\")\n        \n        visited_customers = set()\n        for route in routes:\n            for customer_id in route:\n                if customer_id < 1 or customer_id > num_customers:\n                    errors.append(f\"Invalid customer ID: {customer_id}\")\n                elif customer_id in visited_customers:\n                    errors.append(f\"Customer {customer_id} visited multiple times\")\n                else:\n                    visited_customers.add(customer_id)\n        \n        if len(visited_customers) != num_customers:\n            errors.append(f\"Not all customers visited: missing {set(range(1, num_customers + 1)) - visited_customers}\")\n        \n        for i, route in enumerate(routes):\n            if route:\n                route_demand = sum(customers[cust_id - 1][2] for cust_id in route)\n                if route_demand > vehicle_capacity:\n                    errors.append(f\"Route {i+1} exceeds capacity: {route_demand} > {vehicle_capacity}\")\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_distance = reference_solution[\"total_distance\"]\n            if optimal_distance == 0:\n                optimality_score = 1.0 if total_distance == 0 else 0.0\n            else:\n                gap = abs(optimal_distance - total_distance) / abs(optimal_distance)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}