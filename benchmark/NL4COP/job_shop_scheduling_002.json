{
  "problem_id": "job_shop_scheduling_002",
  "metadata": {
    "problem_type": "Job Shop Scheduling Problem",
    "difficulty": "medium"
  },
  "problem_description": "In an advanced quantum research facility, ten experimental protocols must be orchestrated through specialized analytical instrumentation. Each protocol comprises ten sequential phases requiring designated instruments for precise durations. The facility operates ten specialized instruments with unique methodological capabilities. The facility management seeks to achieve optimal temporal coordination of all experimental phases, thereby minimizing the comprehensive experimental completion timeframe. The experimental orchestration must adhere to sequential processing requirements within protocols and resource exclusivity principles across instruments. Protocol specifications: Protocol Alpha begins with Instrument 3 requiring 40 minutes, followed by Instrument 4 needing 36 minutes, then Instrument 10 demanding 19 minutes, subsequently Instrument 2 requiring 21 minutes, then Instrument 9 needing 8 minutes, followed by Instrument 1 demanding 19 minutes, then Instrument 5 requiring 40 minutes, subsequently Instrument 8 needing 20 minutes, then Instrument 7 demanding 43 minutes, and concluding with Instrument 6 requiring 2 minutes; Protocol Beta commences with Instrument 10 requiring 19 minutes, then proceeds to Instrument 6 needing 32 minutes, followed by Instrument 5 demanding 46 minutes, then Instrument 2 requiring 9 minutes, followed by Instrument 4 needing 44 minutes, then Instrument 8 demanding 27 minutes, followed by Instrument 7 requiring 23 minutes, then Instrument 3 needing 3 minutes, followed by Instrument 1 demanding 30 minutes, and concluding with Instrument 9 requiring 28 minutes; Protocol Gamma begins with Instrument 5 requiring 43 minutes, followed by Instrument 3 needing 18 minutes, then Instrument 9 demanding 48 minutes, subsequently Instrument 1 requiring 12 minutes, then Instrument 10 needing 16 minutes, followed by Instrument 8 demanding 27 minutes, then Instrument 2 requiring 35 minutes, followed by Instrument 7 needing 12 minutes, then Instrument 6 demanding 10 minutes, and concluding with Instrument 4 requiring 26 minutes; Protocol Delta initiates with Instrument 7 requiring 13 minutes, followed by Instrument 6 needing 4 minutes, then Instrument 5 demanding 26 minutes, subsequently Instrument 9 requiring 15 minutes, then Instrument 1 needing 35 minutes, followed by Instrument 8 demanding 1 minute, then Instrument 10 requiring 28 minutes, followed by Instrument 4 needing 47 minutes, then Instrument 3 demanding 27 minutes, and concluding with Instrument 2 requiring 29 minutes; Protocol Epsilon commences with Instrument 5 requiring 23 minutes, then proceeds to Instrument 10 needing 47 minutes, followed by Instrument 8 demanding 44 minutes, then Instrument 1 requiring 3 minutes, followed by Instrument 3 demanding 47 minutes, then Instrument 4 needing 2 minutes, followed by Instrument 7 requiring 34 minutes, then Instrument 9 needing 9 minutes, followed by Instrument 6 demanding 16 minutes, and concluding with Instrument 2 requiring 49 minutes; Protocol Zeta begins with Instrument 1 requiring 34 minutes, followed by Instrument 4 needing 41 minutes, then Instrument 7 demanding 25 minutes, subsequently Instrument 8 needing 33 minutes, then Instrument 2 requiring 41 minutes, followed by Instrument 10 needing 9 minutes, then Instrument 9 requiring 30 minutes, followed by Instrument 5 needing 12 minutes, then Instrument 3 demanding 9 minutes, and concluding with Instrument 6 requiring 10 minutes; Protocol Eta initiates with Instrument 2 requiring 11 minutes, followed by Instrument 8 needing 12 minutes, then Instrument 3 demanding 47 minutes, subsequently Instrument 6 needing 46 minutes, then Instrument 4 requiring 25 minutes, followed by Instrument 5 demanding 33 minutes, then Instrument 10 needing 23 minutes, followed by Instrument 7 requiring 46 minutes, then Instrument 9 needing 38 minutes, and concluding with Instrument 1 requiring 41 minutes; Protocol Theta commences with Instrument 4 requiring 24 minutes, then proceeds to Instrument 8 needing 18 minutes, followed by Instrument 2 requiring 1 minute, then Instrument 3 demanding 37 minutes, followed by Instrument 5 needing 50 minutes, then Instrument 10 requiring 31 minutes, followed by Instrument 1 needing 40 minutes, then Instrument 7 requiring 29 minutes, then Instrument 9 needing 23 minutes, and concluding with Instrument 6 requiring 40 minutes; Protocol Iota begins with Instrument 8 requiring 31 minutes, followed by Instrument 7 needing 31 minutes, then Instrument 3 demanding 25 minutes, subsequently Instrument 2 needing 18 minutes, then Instrument 4 requiring 30 minutes, followed by Instrument 1 needing 38 minutes, then Instrument 9 requiring 20 minutes, followed by Instrument 5 needing 23 minutes, then Instrument 10 demanding 49 minutes, and concluding with Instrument 6 requiring 42 minutes; Protocol Kappa initiates with Instrument 8 requiring 43 minutes, followed by Instrument 10 needing 35 minutes, then Instrument 5 demanding 16 minutes, subsequently Instrument 9 requiring 25 minutes, then Instrument 7 needing 24 minutes, followed by Instrument 4 needing 38 minutes, then Instrument 6 requiring 42 minutes, followed by Instrument 1 needing 18 minutes, then Instrument 2 requiring 40 minutes, and concluding with Instrument 3 demanding 34 minutes. Determine optimal temporal positioning for all experimental phases to minimize total completion duration.",
  "solution_format_description": "Print the following fields: - phase_initiation_times: start times for each protocol's phases. - experimental_completion_duration: total time to complete all protocols.",
  "structured_data": {
    "n_protocols": 10,
    "n_instruments": 10,
    "phase_durations": [
      [40, 36, 19, 21, 8, 19, 40, 20, 43, 2],
      [19, 32, 46, 9, 44, 27, 23, 3, 30, 28],
      [43, 18, 48, 12, 16, 27, 35, 12, 10, 26],
      [13, 4, 26, 15, 35, 1, 28, 47, 27, 29],
      [23, 47, 44, 3, 47, 2, 34, 9, 16, 49],
      [34, 41, 25, 33, 41, 9, 30, 12, 9, 10],
      [11, 12, 47, 46, 25, 33, 23, 46, 38, 41],
      [24, 18, 1, 37, 50, 31, 40, 29, 23, 40],
      [31, 31, 25, 18, 30, 38, 20, 23, 49, 42],
      [43, 35, 16, 25, 24, 38, 42, 18, 40, 34]
    ],
    "instrument_assignments": [
      [3, 4, 10, 2, 9, 1, 5, 8, 7, 6],
      [10, 6, 5, 2, 4, 8, 7, 3, 1, 9],
      [5, 3, 9, 1, 10, 8, 2, 7, 6, 4],
      [7, 6, 5, 9, 1, 8, 10, 4, 3, 2],
      [5, 10, 8, 1, 3, 4, 7, 9, 6, 2],
      [1, 4, 7, 8, 2, 10, 9, 5, 3, 6],
      [2, 8, 3, 6, 4, 5, 10, 7, 9, 1],
      [4, 8, 2, 3, 5, 10, 1, 7, 9, 6],
      [8, 7, 3, 2, 4, 1, 9, 5, 10, 6],
      [8, 10, 5, 9, 7, 4, 6, 1, 2, 3]
    ]
  },
  "reference_solution": {
    "phase_initiation_times": [
      [0, 75, 125, 144, 181, 193, 255, 325, 368, 427],
      [0, 19, 158, 243, 254, 298, 333, 356, 359, 389],
      [0, 43, 133, 181, 193, 209, 252, 356, 375, 385],
      [0, 13, 66, 92, 107, 202, 209, 298, 359, 396],
      [43, 78, 125, 169, 172, 222, 224, 282, 291, 307],
      [0, 34, 75, 169, 202, 243, 252, 295, 307, 316],
      [0, 61, 99, 146, 197, 222, 255, 287, 335, 389],
      [0, 43, 61, 62, 108, 158, 212, 258, 312, 335],
      [73, 104, 146, 171, 224, 254, 292, 312, 335, 385],
      [0, 43, 92, 108, 135, 159, 197, 292, 356, 396]
    ],
    "experimental_completion_duration": 430
  },
  "solver_code": "from cpmpy import *\nimport json\n\nn_protocols = 10\nn_instruments = 10\nphase_durations = [\n    [40, 36, 19, 21, 8, 19, 40, 20, 43, 2],\n    [19, 32, 46, 9, 44, 27, 23, 3, 30, 28],\n    [43, 18, 48, 12, 16, 27, 35, 12, 10, 26],\n    [13, 4, 26, 15, 35, 1, 28, 47, 27, 29],\n    [23, 47, 44, 3, 47, 2, 34, 9, 16, 49],\n    [34, 41, 25, 33, 41, 9, 30, 12, 9, 10],\n    [11, 12, 47, 46, 25, 33, 23, 46, 38, 41],\n    [24, 18, 1, 37, 50, 31, 40, 29, 23, 40],\n    [31, 31, 25, 18, 30, 38, 20, 23, 49, 42],\n    [43, 35, 16, 25, 24, 38, 42, 18, 40, 34]\n]\ninstrument_assignments = [\n    [3, 4, 10, 2, 9, 1, 5, 8, 7, 6],\n    [10, 6, 5, 2, 4, 8, 7, 3, 1, 9],\n    [5, 3, 9, 1, 10, 8, 2, 7, 6, 4],\n    [7, 6, 5, 9, 1, 8, 10, 4, 3, 2],\n    [5, 10, 8, 1, 3, 4, 7, 9, 6, 2],\n    [1, 4, 7, 8, 2, 10, 9, 5, 3, 6],\n    [2, 8, 3, 6, 4, 5, 10, 7, 9, 1],\n    [4, 8, 2, 3, 5, 10, 1, 7, 9, 6],\n    [8, 7, 3, 2, 4, 1, 9, 5, 10, 6],\n    [8, 10, 5, 9, 7, 4, 6, 1, 2, 3]\n]\n\nmax_protocol_time = max(sum(phase_durations[i]) for i in range(n_protocols))\ninstrument_loads = {}\nfor i in range(n_protocols):\n    for j in range(n_instruments):\n        inst_id = instrument_assignments[i][j]\n        instrument_loads[inst_id] = instrument_loads.get(inst_id, 0) + phase_durations[i][j]\nmax_instrument_load = max(instrument_loads.values())\nlower_bound = max(max_protocol_time, max_instrument_load)\nupper_bound = sum(sum(phase_durations[i]) for i in range(n_protocols))\n\nif lower_bound > upper_bound:\n    lower_bound = upper_bound\n\nmodel = Model()\n\ninitiation = intvar(0, upper_bound, shape=(n_protocols, n_instruments))\nexperimental_completion_duration = intvar(lower_bound, upper_bound)\n\nfor i in range(n_protocols):\n    for j in range(n_instruments - 1):\n        model += initiation[i][j+1] >= initiation[i][j] + phase_durations[i][j]\n\nphases_on_instrument = {}\nfor i in range(n_protocols):\n    for j in range(n_instruments):\n        inst_id = instrument_assignments[i][j]\n        if inst_id not in phases_on_instrument:\n            phases_on_instrument[inst_id] = []\n        phases_on_instrument[inst_id].append((i, j))\n\nfor ops in phases_on_instrument.values():\n    if len(ops) > 1:\n        for k1 in range(len(ops)):\n            for k2 in range(k1 + 1, len(ops)):\n                i1, j1 = ops[k1]\n                i2, j2 = ops[k2]\n                model += (initiation[i1][j1] + phase_durations[i1][j1] <= initiation[i2][j2]) | (initiation[i2][j2] + phase_durations[i2][j2] <= initiation[i1][j1])\n\nfor i in range(n_protocols):\n    model += experimental_completion_duration >= initiation[i][n_instruments-1] + phase_durations[i][n_instruments-1]\n\nmodel.minimize(experimental_completion_duration)\n\nif model.solve():\n    phase_initiation_times = [[int(initiation[i][j].value()) for j in range(n_instruments)] for i in range(n_protocols)]\n    result = {\n        \"phase_initiation_times\": phase_initiation_times,\n        \"experimental_completion_duration\": int(experimental_completion_duration.value())\n    }\n    print(json.dumps(result))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"phase_initiation_times\", \"experimental_completion_duration\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        phase_initiation_times = solution[\"phase_initiation_times\"]\n        experimental_completion_duration = solution[\"experimental_completion_duration\"]\n        n_protocols = structured_data[\"n_protocols\"]\n        n_instruments = structured_data[\"n_instruments\"]\n        phase_durations = structured_data[\"phase_durations\"]\n        instrument_assignments = structured_data[\"instrument_assignments\"]\n        errors = []\n        \n        if len(phase_initiation_times) != n_protocols:\n            errors.append(f\"Expected {n_protocols} protocols, got {len(phase_initiation_times)}\")\n        \n        for i, protocol_times in enumerate(phase_initiation_times):\n            if len(protocol_times) != n_instruments:\n                errors.append(f\"Protocol {i} has {len(protocol_times)} phases, expected {n_instruments}\")\n            if any(t < 0 for t in protocol_times):\n                errors.append(f\"Protocol {i} has negative initiation times\")\n        \n        if errors:\n            return {\"is_valid\": False, \"validation_errors\": errors, \"optimality_score\": 0.0}\n        \n        for i in range(n_protocols):\n            for j in range(n_instruments - 1):\n                current_start = phase_initiation_times[i][j]\n                current_duration = phase_durations[i][j]\n                next_start = phase_initiation_times[i][j + 1]\n                if next_start < current_start + current_duration:\n                    errors.append(f\"Protocol {i}: phase {j+1} starts at {next_start} but phase {j} finishes at {current_start + current_duration}\")\n        \n        instrument_operations = {}\n        for i in range(n_protocols):\n            for j in range(n_instruments):\n                instrument_id = instrument_assignments[i][j]\n                start_time = phase_initiation_times[i][j]\n                duration = phase_durations[i][j]\n                end_time = start_time + duration\n                \n                if instrument_id not in instrument_operations:\n                    instrument_operations[instrument_id] = []\n                instrument_operations[instrument_id].append((start_time, end_time, i, j))\n        \n        for instrument_id, ops in instrument_operations.items():\n            ops_sorted = sorted(ops, key=lambda x: x[0]) \n            for k in range(len(ops_sorted) - 1):\n                current_end = ops_sorted[k][1]\n                next_start = ops_sorted[k + 1][0]\n                if current_end > next_start:\n                    protocol1, phase1 = ops_sorted[k][2], ops_sorted[k][3]\n                    protocol2, phase2 = ops_sorted[k + 1][2], ops_sorted[k + 1][3]\n                    errors.append(f\"Instrument {instrument_id}: protocol {protocol1} phase {phase1} ends at {current_end} overlaps with protocol {protocol2} phase {phase2} starting at {next_start}\")\n        \n        if len(errors) == 0:\n            optimal_duration = reference_solution[\"experimental_completion_duration\"]\n            gap = abs(optimal_duration - experimental_completion_duration) / optimal_duration\n            optimality_score = max(0, 1 - gap)\n            return {\n                \"is_valid\": True,\n                \"validation_errors\": [],\n                \"optimality_score\": optimality_score\n            }\n        else:\n            return {\n                \"is_valid\": False,\n                \"validation_errors\": errors,\n                \"optimality_score\": 0.0\n            }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}