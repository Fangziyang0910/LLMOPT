{
  "problem_id": "container_loading_with_weight_restrictions_003",
  "metadata": {
    "problem_type": "Container Loading with Weight Restrictions Problem",
    "difficulty": "hard"
  },
  "problem_description": "An international moving company is loading a shipping container measuring 200×150×180 cm for overseas transport. The cargo includes four types of items: Type 1 items (12 units available, each 80×60×50 cm, weighing 40 kg), Type 2 items (10 units available, each 50×40×30 cm, weighing 25 kg), Type 3 items (8 units available, each 30×25×20 cm, weighing 15 kg), and Type 4 items (10 units available, each 20×15×10 cm, weighing 5 kg). Each item can be placed in one of three orientations by rotating its dimensions. Items must be placed such that they do not extend beyond the container boundaries in any dimension. Additionally, items cannot overlap with each other in the container space. The objective is to maximize the total volume of items loaded into the container, thereby achieving the highest possible space utilization rate.",
  "solution_format_description": "Print the following fields: - package_placements: for each package, list placement with type, x, y, z, length, width, height. - space_utilization: ratio of used container space to total space. - total_volume_used: total volume of placed packages. - container_volume: total container volume.",
  "structured_data": {
    "container_dimensions": [200, 150, 180],
    "box_inventory": [
      [80, 60, 50, 12, 40],
      [50, 40, 30, 10, 25],
      [30, 25, 20, 8, 15],
      [20, 15, 10, 10, 5]
    ]
  },
  "reference_solution": {
    "package_placements": [
      [1, [131, 0, 0], [60, 50, 80]],
      [1, [0, 84, 80], [80, 60, 50]],
      [1, [1, 22, 62], [80, 60, 50]],
      [1, [80, 2, 0], [50, 80, 60]],
      [1, [82, 0, 111], [50, 80, 60]],
      [1, [132, 0, 80], [60, 50, 80]],
      [1, [140, 100, 0], [60, 50, 80]],
      [1, [150, 50, 120], [50, 80, 60]],
      [1, [131, 50, 0], [60, 50, 80]],
      [1, [0, 83, 0], [60, 50, 80]],
      [1, [30, 3, 0], [50, 80, 60]],
      [1, [80, 100, 41], [60, 50, 80]],
      [2, [0, 34, 131], [30, 50, 40]],
      [2, [0, 86, 130], [40, 30, 50]],
      [2, [0, 116, 130], [40, 30, 50]],
      [2, [40, 43, 131], [30, 50, 40]],
      [2, [80, 82, 0], [30, 50, 40]],
      [2, [110, 100, 0], [30, 50, 40]],
      [2, [140, 65, 80], [30, 50, 40]],
      [2, [170, 65, 80], [30, 50, 40]],
      [2, [0, 33, 2], [30, 50, 40]],
      [2, [100, 81, 121], [50, 40, 30]],
      [3, [105, 92, 151], [30, 25, 20]],
      [3, [133, 130, 130], [25, 20, 30]],
      [3, [81, 130, 122], [25, 20, 30]],
      [3, [108, 130, 122], [25, 20, 30]],
      [3, [158, 115, 90], [20, 30, 25]],
      [3, [81, 120, 152], [20, 30, 25]],
      [3, [104, 121, 160], [30, 25, 20]],
      [3, [170, 130, 131], [25, 20, 30]],
      [4, [134, 130, 160], [15, 10, 20]],
      [4, [170, 130, 161], [10, 20, 15]],
      [4, [180, 130, 161], [10, 20, 15]],
      [4, [190, 130, 161], [10, 20, 15]],
      [4, [133, 50, 80], [20, 15, 10]],
      [4, [132, 31, 161], [10, 20, 15]],
      [4, [91, 100, 160], [10, 20, 15]],
      [4, [118, 84, 101], [15, 10, 20]],
      [4, [149, 130, 160], [20, 15, 10]],
      [4, [149, 130, 170], [20, 15, 10]]
    ],
    "space_utilization": 0.672,
    "total_volume_used": 3630000,
    "container_volume": 5400000
  },
  "solver_code": "from cpmpy import *\nimport json\n\ncontainer_dimensions = [200, 150, 180]\nbox_inventory = [\n    [80, 60, 50, 12, 40],\n    [50, 40, 30, 10, 25],\n    [30, 25, 20, 8, 15],\n    [20, 15, 10, 10, 5]\n]\n\ncontainer_length, container_width, container_height = container_dimensions\ncontainer_volume = container_length * container_width * container_height\n\nboxes = []\nfor box_idx, (length, width, height, available, weight) in enumerate(box_inventory):\n    for i in range(available):\n        boxes.append([box_idx + 1, length, width, height])\n\nnum_boxes = len(boxes)\n\nused = boolvar(shape=num_boxes)\nx = intvar(0, container_length, shape=num_boxes)\ny = intvar(0, container_width, shape=num_boxes)\nz = intvar(0, container_height, shape=num_boxes)\norientation = intvar(1, 3, shape=num_boxes)\n\no_length = intvar(1, max(container_length, container_width, container_height), shape=num_boxes)\no_width = intvar(1, max(container_length, container_width, container_height), shape=num_boxes)\no_height = intvar(1, max(container_length, container_width, container_height), shape=num_boxes)\n\nmodel = Model()\n\nfor i in range(num_boxes):\n    box_type, length, width, height = boxes[i]\n    \n    model += (orientation[i] == 1).implies(o_length[i] == length)\n    model += (orientation[i] == 1).implies(o_width[i] == width)\n    model += (orientation[i] == 1).implies(o_height[i] == height)\n    \n    model += (orientation[i] == 2).implies(o_length[i] == width)\n    model += (orientation[i] == 2).implies(o_width[i] == height)\n    model += (orientation[i] == 2).implies(o_height[i] == length)\n    \n    model += (orientation[i] == 3).implies(o_length[i] == height)\n    model += (orientation[i] == 3).implies(o_width[i] == length)\n    model += (orientation[i] == 3).implies(o_height[i] == width)\n    \n    model += used[i].implies(x[i] + o_length[i] <= container_length)\n    model += used[i].implies(y[i] + o_width[i] <= container_width)\n    model += used[i].implies(z[i] + o_height[i] <= container_height)\n\nfor i in range(num_boxes):\n    for j in range(i + 1, num_boxes):\n        no_x_overlap = (x[i] + o_length[i] <= x[j]) | (x[j] + o_length[j] <= x[i])\n        no_y_overlap = (y[i] + o_width[i] <= y[j]) | (y[j] + o_width[j] <= y[i])\n        no_z_overlap = (z[i] + o_height[i] <= z[j]) | (z[j] + o_height[j] <= z[i])\n        non_overlap = no_x_overlap | no_y_overlap | no_z_overlap\n        model += (used[i] & used[j]).implies(non_overlap)\n\nbox_volumes = [boxes[i][1] * boxes[i][2] * boxes[i][3] for i in range(num_boxes)]\nmodel.maximize(sum(used[i] * box_volumes[i] for i in range(num_boxes)))\n\nif model.solve():\n    total_volume_used = sum(box_volumes[i] for i in range(num_boxes) if used[i].value())\n    space_utilization = total_volume_used / container_volume\n    \n    package_placements = []\n    for i in range(num_boxes):\n        if used[i].value():\n            package_placements.append([\n                boxes[i][0],\n                [int(x[i].value()), int(y[i].value()), int(z[i].value())],\n                [int(o_length[i].value()), int(o_width[i].value()), int(o_height[i].value())]\n            ])\n    \n    result = {\n        \"package_placements\": package_placements,\n        \"space_utilization\": round(space_utilization, 3),\n        \"total_volume_used\": total_volume_used,\n        \"container_volume\": container_volume\n    }\n    \n    print(json.dumps(result))\nelse:\n    print(json.dumps({\n        \"package_placements\": [],\n        \"space_utilization\": 0.0,\n        \"total_volume_used\": 0,\n        \"container_volume\": container_volume\n    }))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"package_placements\", \"space_utilization\", \"total_volume_used\", \"container_volume\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        placements = solution[\"package_placements\"]\n        space_utilization = solution[\"space_utilization\"]\n        total_volume_used = solution[\"total_volume_used\"]\n        container_volume = solution[\"container_volume\"]\n        \n        container = structured_data[\"container_dimensions\"]\n        items = structured_data[\"items\"]\n        \n        errors = []\n        \n        if container_volume != container[\"length\"] * container[\"width\"] * container[\"height\"]:\n            errors.append(f\"Container volume mismatch: expected {container['length'] * container['width'] * container['height']}, got {container_volume}\")\n        \n        type_to_index = {}\n        for idx, item in enumerate(items):\n            type_to_index[item[\"type\"]] = idx\n        \n        item_usage = [0] * len(items)\n        \n        for i, placement in enumerate(placements):\n            if len(placement) != 3:\n                errors.append(f\"Placement {i} should have 3 elements: [type, [x,y,z], [length,width,height]]\")\n                continue\n            \n            item_type, position, dimensions = placement\n            x, y, z = position\n            length, width, height = dimensions\n            \n            if item_type not in type_to_index:\n                errors.append(f\"Invalid item type {item_type} in placement {i}\")\n                continue\n            \n            item_idx = type_to_index[item_type]\n            item_usage[item_idx] += 1\n            \n            if item_usage[item_idx] > items[item_idx][\"quantity\"]:\n                errors.append(f\"Exceeded available quantity for item type {item_type}\")\n            \n            if x < 0 or y < 0 or z < 0:\n                errors.append(f\"Negative coordinates in placement {i}\")\n            \n            if x + length > container[\"length\"]:\n                errors.append(f\"Item {i} exceeds container length: {x} + {length} > {container['length']}\")\n            \n            if y + width > container[\"width\"]:\n                errors.append(f\"Item {i} exceeds container width: {y} + {width} > {container['width']}\")\n            \n            if z + height > container[\"height\"]:\n                errors.append(f\"Item {i} exceeds container height: {z} + {height} > {container['height']}\")\n        \n        for i in range(len(placements)):\n            for j in range(i + 1, len(placements)):\n                if items_overlap(placements[i], placements[j]):\n                    errors.append(f\"Items {i} and {j} overlap\")\n        \n        calc_volume = 0\n        for placement in placements:\n            item_type = placement[0]\n            if item_type in type_to_index:\n                item_idx = type_to_index[item_type]\n                item = items[item_idx]\n                calc_volume += item[\"size\"][\"length\"] * item[\"size\"][\"width\"] * item[\"size\"][\"height\"]\n        \n        if abs(calc_volume - total_volume_used) > 1e-6:\n            errors.append(f\"Volume calculation mismatch: calculated {calc_volume}, declared {total_volume_used}\")\n        \n        calc_utilization = calc_volume / container_volume if container_volume > 0 else 0\n        if abs(calc_utilization - space_utilization) > 1e-6:\n            errors.append(f\"Utilization calculation mismatch: calculated {calc_utilization}, declared {space_utilization}\")\n        \n        optimal_volume = reference_solution[\"total_volume_used\"]\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            if optimal_volume == 0:\n                optimality_score = 1.0 if total_volume_used == 0 else 0.0\n            else:\n                gap = abs(optimal_volume - total_volume_used) / abs(optimal_volume)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Format error in solution data: {str(e)}\"], \"optimality_score\": 0.0}\n\ndef items_overlap(placement1, placement2):\n    _, pos1, dim1 = placement1\n    _, pos2, dim2 = placement2\n    \n    x1, y1, z1 = pos1\n    x2, y2, z2 = pos2\n    l1, w1, h1 = dim1\n    l2, w2, h2 = dim2\n    \n    if x1 + l1 <= x2 or x2 + l2 <= x1:\n        return False\n    if y1 + w1 <= y2 or y2 + w2 <= y1:\n        return False\n    if z1 + h1 <= z2 or z2 + h2 <= z1:\n        return False\n    \n    return True"
}