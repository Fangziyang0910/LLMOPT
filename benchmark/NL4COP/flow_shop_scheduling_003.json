{
  "problem_id": "flow_shop_scheduling_003",
  "metadata": {
    "problem_type": "Flow Shop Scheduling Problem",
    "difficulty": "hard"
  },
  "problem_description": "Within the intricate operational framework of a multinational semiconductor manufacturing conglomerate, twenty distinct advanced microprocessor architectures require systematic fabrication through a quintet of specialized wafer processing modules operating under stringent temporal constraints. Each architecture must traverse the entire fabrication pipeline in a predetermined technological sequence, where each module possesses exclusive processing capabilities that cannot be simultaneously allocated to multiple architectures. The fabrication paradigm enforces a strict precedence relationship: architectures cannot commence processing at subsequent modules until completion at the preceding module, while each module maintains unitary processing capacity at any given temporal interval. The processing requirements exhibit significant heterogeneity across both architectures and modules, creating a complex multidimensional optimization landscape. Architecture Alpha-001 requires fifty-four minutes at the photolithography module, seventy-nine minutes at the etching module, sixteen minutes at the deposition module, sixty-six minutes at the ion implantation module, and fifty-eight minutes at the metallization module. Architecture Beta-002 demonstrates extended processing demands with eighty-three minutes at photolithography, three minutes at etching, eighty-nine minutes at deposition, fifty-eight minutes at ion implantation, and fifty-six minutes at metallization respectively across the sequential modules. Architecture Gamma-003 exhibits intermediate processing characteristics with fifteen minutes at photolithography, eleven minutes at etching, forty-nine minutes at deposition, thirty-one minutes at ion implantation, and twenty minutes at metallization. Architecture Delta-004's processing profile encompasses seventy-one minutes at photolithography, ninety-nine minutes at etching, fifteen minutes at deposition, sixty-eight minutes at ion implantation, and eighty-five minutes at metallization, while Architecture Epsilon-005 requires seventy-seven minutes at photolithography, fifty-six minutes at etching, eighty-nine minutes at deposition, seventy-eight minutes at ion implantation, and fifty-three minutes at metallization across the fabrication sequence. Architecture Zeta-006 demonstrates elevated processing demands with thirty-six minutes at photolithography, seventy minutes at etching, forty-five minutes at deposition, ninety-one minutes at ion implantation, and thirty-five minutes at metallization. Architecture Eta-007's processing requirements escalate to fifty-three minutes at photolithography, ninety-nine minutes at etching, sixty minutes at deposition, thirteen minutes at ion implantation, and fifty-three minutes at metallization. Architecture Theta-008 exhibits substantial processing intensity with thirty-eight minutes at photolithography, sixty minutes at etching, twenty-three minutes at deposition, fifty-nine minutes at ion implantation, and forty-one minutes at metallization. Architecture Iota-009 requires twenty-seven minutes at photolithography, five minutes at etching, fifty-seven minutes at deposition, forty-nine minutes at ion implantation, and sixty-nine minutes at metallization, while Architecture Kappa-010 demonstrates extended processing characteristics with eighty-seven minutes at photolithography, fifty-six minutes at etching, sixty-four minutes at deposition, eighty-five minutes at ion implantation, and thirteen minutes at metallization across the sequential fabrication modules. Architecture Lambda-011 exhibits complex processing patterns with seventy-six minutes at photolithography, three minutes at etching, seven minutes at deposition, thirty-nine minutes at ion implantation, and eighty-six minutes at metallization. Architecture Mu-012's processing requirements encompass ninety-one minutes at photolithography, sixty-one minutes at etching, one minute at deposition, forty-one minutes at ion implantation, and seventy-two minutes at metallization. Architecture Nu-013 demonstrates varied processing demands with fourteen minutes at photolithography, seventy-three minutes at etching, sixty-three minutes at deposition, fifty-six minutes at ion implantation, and eight minutes at metallization. Architecture Xi-014's processing profile includes twenty-nine minutes at photolithography, seventy-five minutes at etching, forty-one minutes at deposition, forty minutes at ion implantation, and forty-nine minutes at metallization. Architecture Omicron-015 requires twelve minutes at photolithography, forty-seven minutes at etching, sixty-three minutes at deposition, fifty-four minutes at ion implantation, and forty-seven minutes at metallization. Architecture Pi-016 demonstrates substantial processing requirements with seventy-seven minutes at photolithography, fourteen minutes at etching, forty-seven minutes at deposition, forty minutes at ion implantation, and eighty-seven minutes at metallization. Architecture Rho-017 exhibits intermediate processing characteristics with thirty-two minutes at photolithography, twenty-one minutes at etching, twenty-six minutes at deposition, fifty-four minutes at ion implantation, and fifty-eight minutes at metallization. Architecture Sigma-018's processing demands escalate to eighty-seven minutes at photolithography, eighty-six minutes at etching, seventy-five minutes at deposition, seventy-seven minutes at ion implantation, and eighteen minutes at metallization. Architecture Tau-019 requires sixty-eight minutes at photolithography, five minutes at etching, seventy-seven minutes at deposition, fifty-one minutes at ion implantation, and sixty-eight minutes at metallization. Architecture Upsilon-020 demonstrates the highest processing complexity with ninety-four minutes at photolithography, seventy-seven minutes at etching, forty minutes at deposition, thirty-one minutes at ion implantation, and twenty-eight minutes at metallization across the sequential fabrication modules. How should the conglomerate's manufacturing coordination optimize the processing sequence of these twenty microprocessor architectures through the fabrication pipeline to achieve the minimum possible total fabrication completion time for the entire production batch?",
  "solution_format_description": "Print the following fields: - architecture_sequence: processing order for microprocessor architectures. - total_fabrication_time: total time to complete all fabrication.",
  "structured_data": {
    "architectures": 20,
    "fabrication_modules": 5,
    "processing_time_matrix": [
      [54, 79, 16, 66, 58],
      [83, 3, 89, 58, 56],
      [15, 11, 49, 31, 20],
      [71, 99, 15, 68, 85],
      [77, 56, 89, 78, 53],
      [36, 70, 45, 91, 35],
      [53, 99, 60, 13, 53],
      [38, 60, 23, 59, 41],
      [27, 5, 57, 49, 69],
      [87, 56, 64, 85, 13],
      [76, 3, 7, 39, 86],
      [91, 61, 1, 41, 72],
      [14, 73, 63, 56, 8],
      [29, 75, 41, 40, 49],
      [12, 47, 63, 54, 47],
      [77, 14, 47, 40, 87],
      [32, 21, 26, 54, 58],
      [87, 86, 75, 77, 18],
      [68, 5, 77, 51, 68],
      [94, 77, 40, 31, 28]
    ]
  },
  "reference_solution": {
    "architecture_sequence": [15, 3, 9, 17, 13, 14, 6, 8, 7, 1, 19, 4, 2, 11, 18, 5, 16, 10, 20, 12],
    "total_fabrication_time": 1296
  },
  "solver_code": "from cpmpy import *\nimport json\n\narchitectures = 20\nfabrication_modules = 5\nprocessing_time_matrix = [\n    [54, 79, 16, 66, 58],\n    [83, 3, 89, 58, 56],\n    [15, 11, 49, 31, 20],\n    [71, 99, 15, 68, 85],\n    [77, 56, 89, 78, 53],\n    [36, 70, 45, 91, 35],\n    [53, 99, 60, 13, 53],\n    [38, 60, 23, 59, 41],\n    [27, 5, 57, 49, 69],\n    [87, 56, 64, 85, 13],\n    [76, 3, 7, 39, 86],\n    [91, 61, 1, 41, 72],\n    [14, 73, 63, 56, 8],\n    [29, 75, 41, 40, 49],\n    [12, 47, 63, 54, 47],\n    [77, 14, 47, 40, 87],\n    [32, 21, 26, 54, 58],\n    [87, 86, 75, 77, 18],\n    [68, 5, 77, 51, 68],\n    [94, 77, 40, 31, 28]\n]\n\narchitecture_sequence = intvar(1, architectures, shape=architectures)\n\nmodel = Model()\n\nmodel += AllDifferent(architecture_sequence)\n\ncompletion = [[intvar(0, 10000) for _ in range(fabrication_modules)] for _ in range(architectures)]\n\nfor i in range(architectures):\n    for j in range(fabrication_modules):\n        architecture_idx = architecture_sequence[i] - 1\n        proc_time = Element([processing_time_matrix[a][j] for a in range(architectures)], architecture_idx)\n        \n        if i == 0 and j == 0:\n            model += (completion[i][j] == proc_time)\n        elif i == 0:\n            model += (completion[i][j] == completion[i][j-1] + proc_time)\n        elif j == 0:\n            model += (completion[i][j] == completion[i-1][j] + proc_time)\n        else:\n            model += (completion[i][j] == max(completion[i-1][j], completion[i][j-1]) + proc_time)\n\ntotal_fabrication_time = completion[architectures-1][fabrication_modules-1]\n\nmodel.minimize(total_fabrication_time)\n\nif model.solve():\n    result = {\n        \"architecture_sequence\": [int(architecture_sequence[i].value()) for i in range(architectures)],\n        \"total_fabrication_time\": int(total_fabrication_time.value())\n    }\n    print(json.dumps(result))\nelse:\n    print(\"No solution found\")",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"architecture_sequence\", \"total_fabrication_time\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        architecture_sequence = solution[\"architecture_sequence\"]\n        candidate_total_time = solution[\"total_fabrication_time\"]\n        \n        architectures = structured_data[\"architectures\"]\n        fabrication_modules = structured_data[\"fabrication_modules\"]\n        processing_time_matrix = structured_data[\"processing_time_matrix\"]\n        errors = []\n        \n        if len(architecture_sequence) != architectures:\n            errors.append(f\"architecture_sequence length mismatch: expected {architectures}, got {len(architecture_sequence)}\")\n        \n        expected_set = set(range(1, architectures + 1))\n        actual_set = set(architecture_sequence)\n        if actual_set != expected_set:\n            missing = expected_set - actual_set\n            extra = actual_set - expected_set\n            if missing:\n                errors.append(f\"Missing architecture IDs: {sorted(list(missing))}\")\n            if extra:\n                errors.append(f\"Extra architecture IDs: {sorted(list(extra))}\")\n        \n        if len(errors) > 0:\n            return {\"is_valid\": False, \"validation_errors\": errors, \"optimality_score\": 0.0}\n        \n        seq_zero = [architecture - 1 for architecture in architecture_sequence]\n        completion = [[0] * fabrication_modules for _ in range(architectures)]\n        \n        for i in range(architectures):\n            for j in range(fabrication_modules):\n                proc_time = processing_time_matrix[seq_zero[i]][j]\n                if i == 0 and j == 0:\n                    completion[i][j] = proc_time\n                elif i == 0:\n                    completion[i][j] = completion[i][j - 1] + proc_time\n                elif j == 0:\n                    completion[i][j] = completion[i - 1][j] + proc_time\n                else:\n                    completion[i][j] = max(completion[i - 1][j], completion[i][j - 1]) + proc_time\n        \n        calculated_total_time = completion[-1][-1]\n        \n        if abs(calculated_total_time - candidate_total_time) > 1e-6:\n            errors.append(f\"Total fabrication time inconsistency: calculated {calculated_total_time}, declared {candidate_total_time}\")\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_value = reference_solution[\"total_fabrication_time\"]\n            if optimal_value == 0:\n                optimality_score = 1.0 if candidate_total_time == 0 else 0.0\n            else:\n                gap = abs(optimal_value - candidate_total_time) / abs(optimal_value)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}