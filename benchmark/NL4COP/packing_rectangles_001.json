{
  "problem_id": "packing_rectangles_001",
  "metadata": {
    "problem_type": "Rectangle Packing Problem",
    "difficulty": "simple"
  },
  "problem_description": "In a quantum computing data center, engineers are implementing a thermal management system for a cylindrical cryogenic container with center coordinates (30, 36) and radius 42 millimeters. The system requires strategic placement of ten heat dissipation modules with different specifications: module 1 is a superconducting qubit array with length 11 millimeters and width 16 millimeters; module 2 is a quantum error correction processor with length 22 millimeters and width 11 millimeters; module 3 is a quantum memory unit with length 17 millimeters and width 15 millimeters; module 4 is a quantum gate array with length 18 millimeters and width 26 millimeters; module 5 is a quantum annealing processor with length 27 millimeters and width 26 millimeters; module 6 is a quantum sensor matrix with length 32 millimeters and width 22 millimeters; module 7 is a quantum communication interface with length 30 millimeters and width 35 millimeters; module 8 is a quantum simulation engine with length 37 millimeters and width 34 millimeters; module 9 is a quantum cryptography module with length 46 millimeters and width 34 millimeters; and module 10 is a quantum metrology system with length 38 millimeters and width 48 millimeters. Each module can be either activated or remain inactive, with no partial activation allowed. When activated, a module must be positioned completely within the cylindrical container boundaries to maintain quantum coherence. No two activated modules may overlap to prevent electromagnetic interference. The team seeks to determine the optimal module selection and positioning to maximize the number of operational modules while preserving system performance, ensuring modules cannot be rotated and all coordinates must be integer values.",
  "solution_format_description": "Print the following fields: - activated: for each activated module, list placement with module ID, x, y. - total_activated: total number of activated modules.",  
  "structured_data": {
    "vessel_center": [30, 36],
    "vessel_radius": 42,
    "module_dimensions": [[11, 16], [22, 11], [17, 15], [18, 26], [27, 26], [32, 22], [30, 35], [37, 34], [46, 34], [38, 48]]
  },
  "reference_solution": {
    "activated": [[0, 1, 6], [1, 45, 22], [2, 21, 32], [3, -9, 22], [4, 38, 33], [5, 6, 48], [6, 15, -3]],
    "total_activated": 7
  },
  "solver_code": "from cpmpy import *\nimport json\n\nn = 10\ncx, cy = 30, 36\nR = 42\nitems = [[11, 16], [22, 11], [17, 15], [18, 26], [27, 26], [32, 22], [30, 35], [37, 34], [46, 34], [38, 48]]\n\nmodel = Model()\nselected = boolvar(shape=n)\nx = intvar(cx - R, cx + R, shape=n)\ny = intvar(cy - R, cy + R, shape=n)\n\nfor i in range(n):\n    l, w = items[i]\n    half_l, half_w = l // 2, w // 2\n    corners_x = [x[i] - half_l, x[i] - half_l, x[i] + half_l, x[i] + half_l]\n    corners_y = [y[i] - half_w, y[i] + half_w, y[i] - half_w, y[i] + half_w]\n    for cx_corner, cy_corner in zip(corners_x, corners_y):\n        dist_sq = (cx_corner - cx)**2 + (cy_corner - cy)**2\n        model += selected[i].implies(dist_sq <= R**2)\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        l1, w1 = items[i]\n        l2, w2 = items[j]\n        x1_min, x1_max = x[i] - l1//2, x[i] + l1//2\n        y1_min, y1_max = y[i] - w1//2, y[i] + w1//2\n        x2_min, x2_max = x[j] - l2//2, x[j] + l2//2\n        y2_min, y2_max = y[j] - w2//2, y[j] + w2//2\n        no_overlap = (x1_max <= x2_min) | (x2_max <= x1_min) | (y1_max <= y2_min) | (y2_max <= y1_min)\n        model += (selected[i] & selected[j]).implies(no_overlap)\n\nmodel.maximize(sum(selected))\n\nif model.solve():\n    packed = []\n    for i in range(n):\n        if selected[i].value():\n            packed.append([i, int(x[i].value()), int(y[i].value())])\n    result = {\"activated\": packed, \"total_activated\": len(packed)}\n    print(json.dumps(result))\nelse:\n    print(json.dumps({\"error\": \"No solution found\"}))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    import math\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"activated\", \"total_activated\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        activated = solution[\"activated\"]\n        total_activated = solution[\"total_activated\"]\n        errors = []\n        \n        cx, cy = structured_data[\"vessel_center\"][0], structured_data[\"vessel_center\"][1]\n        R = structured_data[\"vessel_radius\"]\n        items = structured_data[\"module_dimensions\"]\n        \n        for module_id, x, y in activated:\n            if module_id >= len(items):\n                errors.append(f\"Module {module_id} index out of range\")\n                continue\n                \n            w, h = items[module_id]\n            half_w, half_h = w // 2, h // 2\n            \n            corners = [(x - half_w, y - half_h), (x - half_w, y + half_h), \n                      (x + half_w, y - half_h), (x + half_w, y + half_h)]\n            for corner_x, corner_y in corners:\n                dist_sq = (corner_x - cx)**2 + (corner_y - cy)**2\n                if dist_sq > R**2:\n                    errors.append(f\"Module {module_id} exceeds vessel boundaries\")\n                    break\n        \n        for i, (module_id_i, x_i, y_i) in enumerate(activated):\n            if module_id_i >= len(items):\n                continue\n                \n            w_i, h_i = items[module_id_i]\n            \n            for j in range(i + 1, len(activated)):\n                module_id_j, x_j, y_j = activated[j]\n                if module_id_j >= len(items):\n                    continue\n                    \n                w_j, h_j = items[module_id_j]\n                \n                if not (x_i + w_i//2 <= x_j - w_j//2 or x_j + w_j//2 <= x_i - w_i//2 or\n                        y_i + h_i//2 <= y_j - h_j//2 or y_j + h_j//2 <= y_i - h_i//2):\n                    errors.append(f\"Modules {module_id_i} and {module_id_j} overlap\")\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_value = reference_solution[\"total_activated\"]\n            if optimal_value == 0:\n                optimality_score = 1.0 if total_activated == 0 else 0.0\n            else:\n                gap = abs(optimal_value - total_activated) / abs(optimal_value)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}