{
  "problem_id": "period_vehicle_routing_001",
  "metadata": {
    "problem_type": "Period Vehicle Routing Problem",
    "difficulty": "simple"
  },
  "problem_description": "A drone delivery service operates from a central hub at coordinates (30.0, 40.0) and needs to plan routes for delivery drones over 2 days. Day 1 has 2 drones available, and Day 2 has 3 drones available. Each drone can carry up to 160.0 kilograms per day. The service delivers to 10 locations with different demand levels and delivery preferences. Each location must be assigned exactly one delivery schedule, and daily routes must be planned to minimize total travel distance while ensuring all routes start and end at the central hub. Location details: Location Alpha at (37.0, 52.0) needs 7.0 kg and can be delivered either on Day 1 only or Day 2 only; Location Beta at (49.0, 49.0) needs 30.0 kg and can be delivered either on Day 1 only or Day 2 only; Location Gamma at (52.0, 64.0) needs 16.0 kg and can be delivered either on Day 1 only or Day 2 only; Location Delta at (20.0, 26.0) needs 9.0 kg and can be delivered either on Day 1 only or Day 2 only; Location Epsilon at (40.0, 30.0) needs 21.0 kg and can be delivered either on Day 1 only or Day 2 only; Location Zeta at (21.0, 47.0) needs 15.0 kg and requires delivery on both days; Location Eta at (17.0, 63.0) needs 19.0 kg and requires delivery on both days; Location Theta at (31.0, 62.0) needs 23.0 kg and can be delivered on Day 1 only; Location Iota at (52.0, 33.0) needs 11.0 kg and can be delivered on Day 2 only; Location Kappa at (51.0, 21.0) needs 5.0 kg and can be delivered on Day 2 only. Each location receives exactly one delivery per scheduled day, and no drone can exceed 160.0 kg capacity per day.",  
  "solution_format_description": "Print the following fields: - location_delivery_schedules: delivery schedule for each location. - drone_flight_paths: flight paths for each day. - total_flight_distance: total flight distance.",
  "structured_data": {
    "planning_horizon_days": 2,
    "daily_drone_availability": [2, 3],
    "drone_payload_capacity_kg": 160,
    "central_hub": [30, 40],
    "delivery_locations": [
      [37, 52, 7, [[1, 0], [0, 1]]],
      [49, 49, 30, [[1, 0], [0, 1]]],
      [52, 64, 16, [[1, 0], [0, 1]]],
      [20, 26, 9, [[1, 0], [0, 1]]],
      [40, 30, 21, [[1, 0], [0, 1]]],
      [21, 47, 15, [[1, 1]]],
      [17, 63, 19, [[1, 1]]],
      [31, 62, 23, [[1, 0]]],
      [52, 33, 11, [[0, 1]]],
      [51, 21, 5, [[0, 1]]]
    ]
  },
  "reference_solution": {
    "location_delivery_schedules": [
      [1, 0],
      [0, 1],
      [0, 1],
      [0, 1],
      [0, 1],
      [1, 1],
      [1, 1],
      [1, 0],
      [0, 1],
      [0, 1]
    ],
    "drone_flight_paths": [
      [[0, 6, 7, 8, 1, 0]],
      [[0, 6, 7, 3, 2, 9, 10, 5, 4, 0]]
    ],
    "total_flight_distance": 225.8235256413845
  },
  "solver_code": "from cpmpy import *\nimport json\nimport math\n\nplanning_horizon_days = 2\ndaily_drone_availability = [2, 3]\ndrone_payload_capacity_kg = 160\ncentral_hub = [30, 40]\ndelivery_locations = [\n    [37, 52, 7, [[1, 0], [0, 1]]],\n    [49, 49, 30, [[1, 0], [0, 1]]],\n    [52, 64, 16, [[1, 0], [0, 1]]],\n    [20, 26, 9, [[1, 0], [0, 1]]],\n    [40, 30, 21, [[1, 0], [0, 1]]],\n    [21, 47, 15, [[1, 1]]],\n    [17, 63, 19, [[1, 1]]],\n    [31, 62, 23, [[1, 0]]],\n    [52, 33, 11, [[0, 1]]],\n    [51, 21, 5, [[0, 1]]]\n]\n\ndelivery_coords = [[loc[0], loc[1]] for loc in delivery_locations]\nall_locations = [central_hub] + delivery_coords\nnum_delivery_locations = len(delivery_locations)\nnum_locations = len(all_locations)\n\ndef euclidean_distance(loc1, loc2):\n    return math.sqrt((loc1[0] - loc2[0])**2 + (loc1[1] - loc2[1])**2)\n\ndistance_matrix = [[euclidean_distance(all_locations[i], all_locations[j]) \n                   for j in range(num_locations)] for i in range(num_locations)]\n\nmodel = Model()\n\nschedule_selection = {}\nfor idx, location in enumerate(delivery_locations, 1):\n    if len(location[3]) == 1:\n        schedule_selection[idx] = location[3][0]\n    elif location[3] == [[1, 0], [0, 1]]:\n        schedule_selection[idx] = intvar(0, 1)\n    else:\n        schedule_selection[idx] = intvar(0, len(location[3]) - 1)\n\nx = {}\nfor day in range(planning_horizon_days):\n    max_drones = daily_drone_availability[day]\n    for k in range(max_drones):\n        for i in range(num_locations):\n            for j in range(num_locations):\n                if i != j:\n                    x[(day, k, i, j)] = boolvar()\n\nfor day in range(planning_horizon_days):\n    max_drones = daily_drone_availability[day]\n    \n    for k in range(max_drones):\n        model += sum(x[(day, k, 0, j)] for j in range(1, num_locations)) <= 1\n        model += sum(x[(day, k, i, 0)] for i in range(1, num_locations)) <= 1\n\nfor day in range(planning_horizon_days):\n    max_drones = daily_drone_availability[day]\n    for i in range(1, num_locations):\n        location = delivery_locations[i-1]\n        \n        if isinstance(schedule_selection[i], list):\n            visit_expr = schedule_selection[i][day]\n        elif location[3] == [[1, 0], [0, 1]]:\n            if day == 0:\n                visit_expr = (1 - schedule_selection[i])\n            else:\n                visit_expr = schedule_selection[i]\n        else:\n            visit_expr = 0\n            for idx, schedule in enumerate(location[3]):\n                if schedule[day] == 1:\n                    visit_expr += (schedule_selection[i] == idx)\n        \n        model += sum(x[(day, k, i, j)] for k in range(max_drones) \n                    for j in range(num_locations) if i != j) == visit_expr\n\nfor day in range(planning_horizon_days):\n    max_drones = daily_drone_availability[day]\n    for k in range(max_drones):\n        for i in range(num_locations):\n            model += sum(x[(day, k, i, j)] for j in range(num_locations) if i != j) == \\\n                     sum(x[(day, k, j, i)] for j in range(num_locations) if i != j)\n\nfor day in range(planning_horizon_days):\n    max_drones = daily_drone_availability[day]\n    for k in range(max_drones):\n        for i in range(num_locations):\n            model += sum(x[(day, k, i, j)] for j in range(num_locations) if i != j) <= 1\n\nfor day in range(planning_horizon_days):\n    max_drones = daily_drone_availability[day]\n    for k in range(max_drones):\n        route_demand = 0\n        for i in range(1, num_locations):\n            location = delivery_locations[i-1]\n            \n            if isinstance(schedule_selection[i], list):\n                day_demand = schedule_selection[i][day] * location[2]\n            elif location[3] == [[1, 0], [0, 1]]:\n                if day == 0:\n                    day_demand = (1 - schedule_selection[i]) * location[2]\n                else:\n                    day_demand = schedule_selection[i] * location[2]\n            else:\n                day_demand = 0\n                for idx, schedule in enumerate(location[3]):\n                    if schedule[day] == 1:\n                        day_demand += (schedule_selection[i] == idx) * location[2]\n            \n            route_demand += day_demand * sum(x[(day, k, j, i)] for j in range(num_locations) if j != i)\n        model += route_demand <= drone_payload_capacity_kg\n\nu = {}\nfor day in range(planning_horizon_days):\n    max_drones = daily_drone_availability[day]\n    for k in range(max_drones):\n        for i in range(1, num_locations):\n            u[(day, k, i)] = intvar(1, num_locations-1)\n        \n        for i in range(1, num_locations):\n            for j in range(1, num_locations):\n                if i != j:\n                    model += u[(day, k, i)] + 1 <= u[(day, k, j)] + (num_locations) * (1 - x[(day, k, i, j)])\n\ntotal_spatial_displacement_expenditure = 0\nfor day in range(planning_horizon_days):\n    max_drones = daily_drone_availability[day]\n    for k in range(max_drones):\n        for i in range(num_locations):\n            for j in range(num_locations):\n                if i != j:\n                    total_spatial_displacement_expenditure += distance_matrix[i][j] * x[(day, k, i, j)]\n\nmodel.minimize(total_spatial_displacement_expenditure)\n\nif model.solve():\n    location_delivery_schedules = []\n    for idx, location in enumerate(delivery_locations, 1):\n        if isinstance(schedule_selection[idx], list):\n            location_delivery_schedules.append(schedule_selection[idx])\n        elif location[3] == [[1, 0], [0, 1]]:\n            selected = schedule_selection[idx].value()\n            schedule = [0] * planning_horizon_days\n            schedule[selected] = 1\n            location_delivery_schedules.append(schedule)\n        else:\n            selected_idx = schedule_selection[idx].value()\n            location_delivery_schedules.append(location[3][selected_idx])\n    \n    drone_flight_paths = []\n    for day in range(planning_horizon_days):\n        day_trajectories = []\n        max_drones = daily_drone_availability[day]\n        \n        for k in range(max_drones):\n            trajectory = [0]\n            current = 0\n            \n            while True:\n                next_loc = -1\n                for j in range(num_locations):\n                    if j != current and x[(day, k, current, j)].value() == 1:\n                        next_loc = j\n                        break\n                \n                if next_loc == -1 or next_loc == 0:\n                    break\n                \n                trajectory.append(next_loc)\n                current = next_loc\n            \n            if len(trajectory) > 1:\n                trajectory.append(0)\n                day_trajectories.append(trajectory)\n        \n        drone_flight_paths.append(day_trajectories)\n    \n    calculated_distance = 0\n    for day_trajectories in drone_flight_paths:\n        for trajectory in day_trajectories:\n            for i in range(len(trajectory) - 1):\n                calculated_distance += distance_matrix[trajectory[i]][trajectory[i + 1]]\n    \n    result = {\n        \"location_delivery_schedules\": location_delivery_schedules,\n        \"drone_flight_paths\": drone_flight_paths,\n        \"total_flight_distance\": calculated_distance\n    }\n    \n    print(json.dumps(result))\nelse:\n    print(\"No solution found\")",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    import math\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"location_delivery_schedules\", \"drone_flight_paths\", \"total_flight_distance\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        location_delivery_schedules = solution[\"location_delivery_schedules\"]\n        drone_flight_paths = solution[\"drone_flight_paths\"]\n        total_flight_distance = solution[\"total_flight_distance\"]\n        \n        planning_horizon_days = structured_data[\"planning_horizon_days\"]\n        daily_drone_availability = structured_data[\"daily_drone_availability\"]\n        drone_payload_capacity_kg = structured_data[\"drone_payload_capacity_kg\"]\n        delivery_locations = structured_data[\"delivery_locations\"]\n        \n        errors = []\n        \n        if len(location_delivery_schedules) != len(delivery_locations):\n            errors.append(f\"Schedule count mismatch\")\n        \n        for day_idx in range(planning_horizon_days):\n            if day_idx >= len(drone_flight_paths):\n                errors.append(f\"Missing trajectories for cycle {day_idx}\")\n                continue\n                \n            day_trajectories = drone_flight_paths[day_idx]\n            drones_available = daily_drone_availability[day_idx]\n            \n            if len(day_trajectories) > drones_available:\n                errors.append(f\"Too many trajectories in cycle {day_idx}\")\n            \n            visited_today = set()\n            \n            for trajectory in day_trajectories:\n                if len(trajectory) < 3 or trajectory[0] != 0 or trajectory[-1] != 0:\n                    errors.append(f\"Invalid trajectory in cycle {day_idx}\")\n                    continue\n                \n                route_demand = sum(delivery_locations[vertex][2] for vertex in trajectory[1:-1] if 0 <= vertex < len(delivery_locations))\n                \n                if route_demand > drone_payload_capacity_kg:\n                    errors.append(f\"Payload exceeded in cycle {day_idx}\")\n                \n                for vertex in trajectory[1:-1]:\n                    if 0 <= vertex < len(delivery_locations):\n                        if vertex in visited_today:\n                            errors.append(f\"Node {vertex} visited multiple times in cycle {day_idx}\")\n                        visited_today.add(vertex)\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_distance = reference_solution[\"total_flight_distance\"]\n            if optimal_distance == 0:\n                optimality_score = 1.0 if total_flight_distance == 0 else 0.0\n            else:\n                gap = abs(optimal_distance - total_flight_distance) / abs(optimal_distance)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error\"], \"optimality_score\": 0.0}"
}