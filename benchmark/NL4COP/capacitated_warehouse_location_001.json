{ 
  "problem_id": "capacitated_warehouse_location_001", 
  "metadata": { 
    "problem_type": "Capacitated Warehouse Location Problem", 
    "difficulty": "simple" 
  }, 
  "problem_description": "A retail company is expanding its distribution network to serve five major store locations in the region. The company has identified two potential warehouse sites to establish distribution centers. Each warehouse site has different setup costs and storage capacities. The company needs to decide which warehouses to open and how to distribute the store orders among them to minimize total expenses while ensuring all stores receive their required inventory. The stores have varying order quantities, and the transportation costs differ depending on which warehouse supplies each store. The company wants to find the most cost-effective way to meet all store demands without exceeding any warehouse's storage limit.\n\nWarehouse details:\n1. Site A: Can store up to 100 units, requires $5000 to set up\n2. Site B: Can store up to 150 units, requires $7000 to set up\n\nStore order requirements and transportation costs:\n1. Store 1: Needs 50 units, costs $10/unit from Site A or $15/unit from Site B\n2. Store 2: Needs 70 units, costs $12/unit from Site A or $8/unit from Site B\n3. Store 3: Needs 40 units, costs $20/unit from Site A or $18/unit from Site B\n4. Store 4: Needs 60 units, costs $14/unit from Site A or $11/unit from Site B\n5. Store 5: Needs 30 units, costs $18/unit from Site A or $16/unit from Site B\n\nEach store's entire order must be fulfilled, but it can be split between the two warehouses if that reduces total costs. The company aims to minimize the sum of warehouse setup costs and transportation costs while ensuring no warehouse receives more orders than it can handle.", 
  "solution_format_description": "Print the following fields: - total_cost: total cost including setup and transportation. - distribution_center_open: which warehouses are open. - order_allocations: how much each store orders from each warehouse.", 
  "structured_data": { 
    "warehouse_capacities": [100, 150], 
    "warehouse_setup_costs": [5000, 7000], 
    "store_demands": [50, 70, 40, 60, 30], 
    "transportation_costs": [ 
      [10, 15], 
      [12, 8], 
      [20, 18], 
      [14, 11], 
      [18, 16] 
    ] 
  }, 
  "reference_solution": {
    "total_cost": 15020,
    "distribution_center_open": [1, 1],
    "order_allocations": [[50, 0], [0, 70], [20, 20], [0, 60], [30, 0]]
  }, 
  "solver_code": "from cpmpy import *\nimport json\n\nwarehouse_capacities = [100, 150]\nwarehouse_setup_costs = [5000, 7000]\nstore_demands = [50, 70, 40, 60, 30]\ntransportation_costs = [[10, 15], [12, 8], [20, 18], [14, 11], [18, 16]]\n\nm = len(warehouse_capacities)\nn = len(store_demands)\n\ncapacities = warehouse_capacities\nfixed_costs = warehouse_setup_costs\ndemands = store_demands\ncosts = transportation_costs\n\nmodel = Model()\n\ndistribution_center_open = boolvar(shape=m)\norder_allocations = [intvar(shape=m, lb=0, ub=max(demands)) for _ in range(n)]\n\nfor j in range(n):\n    model += sum(order_allocations[j]) == demands[j]\n\nfor j in range(n):\n    for i in range(m):\n        model += order_allocations[j][i] <= demands[j] * distribution_center_open[i]\n\nfor i in range(m):\n    model += sum(order_allocations[j][i] for j in range(n)) <= capacities[i] * distribution_center_open[i]\n\ntotal_cost = sum(fixed_costs[i] * distribution_center_open[i] for i in range(m))\ntotal_cost += sum(order_allocations[j][i] * costs[j][i] for j in range(n) for i in range(m))\n\nmodel.minimize(total_cost)\n\nif model.solve():\n    result = {\n        \"total_cost\": total_cost.value(),\n        \"distribution_center_open\": [int(distribution_center_open[i].value()) for i in range(m)],\n        \"order_allocations\": [[order_allocations[j][i].value() for i in range(m)] for j in range(n)]\n    }\n    print(json.dumps(result))\nelse:\n    print(\"No solution found\")",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"total_cost\", \"distribution_center_open\", \"order_allocations\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        total_cost = solution[\"total_cost\"]\n        distribution_center_open = solution[\"distribution_center_open\"]\n        order_allocations = solution[\"order_allocations\"]\n        distribution_centers = structured_data[\"distribution_centers\"]\n        stores = structured_data[\"stores\"]\n        errors = []\n        \n        m = len(distribution_centers)\n        n = len(stores)\n        \n        if len(distribution_center_open) != m:\n            errors.append(f\"distribution_center_open length mismatch: expected {m}, got {len(distribution_center_open)}\")\n        \n        if len(order_allocations) != n:\n            errors.append(f\"order_allocations length mismatch: expected {n}, got {len(order_allocations)}\")\n        \n        for i in range(n):\n            if len(order_allocations[i]) != m:\n                errors.append(f\"order_allocations[{i}] length mismatch: expected {m}, got {len(order_allocations[i])}\")\n        \n        for i in range(m):\n            if distribution_center_open[i] not in [0, 1]:\n                errors.append(f\"distribution_center_open[{i}] must be 0 or 1, got {distribution_center_open[i]}\")\n        \n        calculated_total_cost = 0\n        \n        for i in range(m):\n            if distribution_center_open[i] == 1:\n                calculated_total_cost += distribution_centers[i][\"setup_cost\"]\n        \n        for j in range(n):\n            store_order = stores[j][\"order_quantity\"]\n            allocated_amount = sum(order_allocations[j])\n            \n            if abs(allocated_amount - store_order) > 1e-6:\n                errors.append(f\"Store {j} order violation: allocated {allocated_amount}, required {store_order}\")\n            \n            for i in range(m):\n                allocation = order_allocations[j][i]\n                \n                if allocation < 0:\n                    errors.append(f\"Negative allocation: store {j}, distribution center {i}: {allocation}\")\n                \n                if allocation > 0 and distribution_center_open[i] != 1:\n                    errors.append(f\"Allocation to closed distribution center: store {j}, distribution center {i}: {allocation}\")\n                \n                calculated_total_cost += allocation * stores[j][\"transportation_costs\"][i]\n        \n        for i in range(m):\n            total_allocated = sum(order_allocations[j][i] for j in range(n))\n            if distribution_center_open[i] == 1 and total_allocated > distribution_centers[i][\"storage_capacity\"] + 1e-6:\n                excess = total_allocated - distribution_centers[i][\"storage_capacity\"]\n                errors.append(f\"Distribution center {i} capacity exceeded by {excess}\")\n        \n        if abs(calculated_total_cost - total_cost) > 1e-6:\n            errors.append(f\"Cost inconsistency: calculated {calculated_total_cost}, declared {total_cost}\")\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_cost = reference_solution[\"total_cost\"]\n            if optimal_cost == 0:\n                optimality_score = 1.0 if total_cost == 0 else 0.0\n            else:\n                gap = abs(optimal_cost - total_cost) / abs(optimal_cost)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}" 
} 
