{
  "problem_id": "period_vehicle_routing_002",
  "metadata": {
    "problem_type": "Period Vehicle Routing Problem",
    "difficulty": "medium"
  },
  "problem_description": "A waste collection service operates from a processing facility at coordinates (50.0, 50.0) and needs to plan routes for collection trucks over 3 days. Day 1 has 3 trucks available, Day 2 has 4 trucks available, and Day 3 has 3 trucks available. Each truck can carry up to 200.0 kilograms of waste per day. The service serves 10 collection zones with different waste amounts and collection preferences. Each zone must be assigned exactly one collection schedule, and daily routes must be planned to minimize total travel distance while ensuring all routes start and end at the processing facility. Zone details: Zone A at (25.0, 35.0) generates 15.0 kg and can be collected either on Monday only, Tuesday only, Wednesday only, or on both Monday and Tuesday; Zone B at (35.0, 20.0) generates 22.0 kg and can be collected either on Monday only, Tuesday only, Wednesday only, or on both Monday and Wednesday; Zone C at (45.0, 15.0) generates 18.0 kg and can be collected either on Monday only, Tuesday only, Wednesday only, or on both Tuesday and Wednesday; Zone D at (65.0, 25.0) generates 25.0 kg and can be collected either on Monday only, Tuesday only, Wednesday only, or on both Monday and Tuesday; Zone E at (75.0, 40.0) generates 12.0 kg and can be collected either on Monday only, Tuesday only, Wednesday only, or on both Monday and Wednesday; Zone F at (70.0, 65.0) generates 20.0 kg and can be collected either on Monday only, Tuesday only, Wednesday only, or on both Tuesday and Wednesday; Zone G at (55.0, 75.0) generates 16.0 kg and can be collected either on Monday only, Tuesday only, Wednesday only, or on both Monday and Tuesday; Zone H at (35.0, 70.0) generates 28.0 kg and can be collected either on Monday only, Tuesday only, Wednesday only, or on both Monday and Wednesday; Zone I at (20.0, 55.0) generates 14.0 kg and can be collected either on Monday only, Tuesday only, Wednesday only, or on both Tuesday and Wednesday; Zone J at (40.0, 45.0) generates 19.0 kg and can be collected either on Monday only, Tuesday only, Wednesday only, or on both Monday and Tuesday.",
  "solution_format_description": "Print the following fields: - zone_collection_plans: collection schedule for each zone. - daily_truck_routes: daily routes starting/ending at facility. - total_travel_distance: total distance traveled.",
  "structured_data": {
    "planning_horizon_days": 3,
    "daily_truck_availability": [3, 4, 3],
    "truck_load_capacity_kg": 200,
    "waste_processing_plant": [50, 50],
    "waste_collection_zones": [
      [25, 35, 15, [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0]]],
      [35, 20, 22, [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 0, 1]]],
      [45, 15, 18, [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 1, 1]]],
      [65, 25, 25, [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0]]],
      [75, 40, 12, [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 0, 1]]],
      [70, 65, 20, [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 1, 1]]],
      [55, 75, 16, [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0]]],
      [35, 70, 28, [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 0, 1]]],
      [20, 55, 14, [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 1, 1]]],
      [40, 45, 19, [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0]]]
    ]
  },
  "reference_solution": {
    "zone_collection_plans": [
      [1, 0, 0],
      [1, 0, 0],
      [1, 0, 0],
      [1, 0, 0],
      [1, 0, 0],
      [1, 0, 0],
      [1, 0, 0],
      [1, 0, 0],
      [1, 0, 0],
      [1, 0, 0]
    ],
    "daily_truck_routes": [
      [[0, 10, 9, 1, 2, 3, 4, 5, 6, 7, 8, 0]],
      [],
      []
    ],
    "total_travel_distance": 212.89146228109405
  },
  "solver_code": "from cpmpy import *\nimport json\nimport math\n\nplanning_horizon_days = 3\ndaily_truck_availability = [3, 4, 3]\ntruck_load_capacity_kg = 200\nwaste_processing_plant = [50, 50]\nwaste_collection_zones = [\n    [25, 35, 15, [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0]]],\n    [35, 20, 22, [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 0, 1]]],\n    [45, 15, 18, [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 1, 1]]],\n    [65, 25, 25, [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0]]],\n    [75, 40, 12, [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 0, 1]]],\n    [70, 65, 20, [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 1, 1]]],\n    [55, 75, 16, [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0]]],\n    [35, 70, 28, [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 0, 1]]],\n    [20, 55, 14, [[1, 0, 0], [0, 1, 0], [0, 0, 1], [0, 1, 1]]],\n    [40, 45, 19, [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0]]]\n]\n\nall_locations = [waste_processing_plant] + waste_collection_zones\nnum_zones = len(waste_collection_zones)\nnum_locations = len(all_locations)\n\ndef euclidean_distance(loc1, loc2):\n    return math.sqrt((loc1[0] - loc2[0])**2 + (loc1[1] - loc2[1])**2)\n\ndistance_matrix = [[euclidean_distance(all_locations[i], all_locations[j]) \n                   for j in range(num_locations)] for i in range(num_locations)]\n\nmodel = Model()\n\nschedule_selection = {}\nfor idx, zone in enumerate(waste_collection_zones, 1):\n    if len(zone[3]) == 1:\n        schedule_selection[idx] = zone[3][0]\n    elif zone[3] == [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0]]:\n        schedule_selection[idx] = intvar(0, 1)\n    else:\n        schedule_selection[idx] = intvar(0, len(zone[3]) - 1)\n\nx = {}\nfor day in range(planning_horizon_days):\n    max_trucks = daily_truck_availability[day]\n    for k in range(max_trucks):\n        for i in range(num_locations):\n            for j in range(num_locations):\n                if i != j:\n                    x[(day, k, i, j)] = boolvar()\n\nfor day in range(planning_horizon_days):\n    max_trucks = daily_truck_availability[day]\n    \n    for k in range(max_trucks):\n        model += sum(x[(day, k, 0, j)] for j in range(1, num_locations)) <= 1\n        model += sum(x[(day, k, i, 0)] for i in range(1, num_locations)) <= 1\n\nfor day in range(planning_horizon_days):\n    max_trucks = daily_truck_availability[day]\n    for i in range(1, num_locations):\n        zone = waste_collection_zones[i-1]\n        \n        if isinstance(schedule_selection[i], list):\n            visit_expr = schedule_selection[i][day]\n        elif zone[3] == [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0]]:\n            if day == 0:\n                visit_expr = (1 - schedule_selection[i])\n            else:\n                visit_expr = schedule_selection[i]\n        else:\n            visit_expr = 0\n            for idx, schedule in enumerate(zone[3]):\n                if schedule[day] == 1:\n                    visit_expr += (schedule_selection[i] == idx)\n        \n        model += sum(x[(day, k, i, j)] for k in range(max_trucks) \n                    for j in range(num_locations) if i != j) == visit_expr\n\nfor day in range(planning_horizon_days):\n    max_trucks = daily_truck_availability[day]\n    for k in range(max_trucks):\n        for i in range(num_locations):\n            model += sum(x[(day, k, i, j)] for j in range(num_locations) if i != j) == \\\n                     sum(x[(day, k, j, i)] for j in range(num_locations) if i != j)\n\nfor day in range(planning_horizon_days):\n    max_trucks = daily_truck_availability[day]\n    for k in range(max_trucks):\n        for i in range(num_locations):\n            model += sum(x[(day, k, i, j)] for j in range(num_locations) if i != j) <= 1\n\nfor day in range(planning_horizon_days):\n    max_trucks = daily_truck_availability[day]\n    for k in range(max_trucks):\n        route_demand = 0\n        for i in range(1, num_locations):\n            zone = waste_collection_zones[i-1]\n            \n            if isinstance(schedule_selection[i], list):\n                day_demand = schedule_selection[i][day] * zone[2]\n            elif zone[3] == [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0]]:\n                if day == 0:\n                    day_demand = (1 - schedule_selection[i]) * zone[2]\n                else:\n                    day_demand = schedule_selection[i] * zone[2]\n            else:\n                day_demand = 0\n                for idx, schedule in enumerate(zone[3]):\n                    if schedule[day] == 1:\n                        day_demand += (schedule_selection[i] == idx) * zone[2]\n            \n            route_demand += day_demand * sum(x[(day, k, j, i)] for j in range(num_locations) if j != i)\n        model += route_demand <= truck_load_capacity_kg\n\nu = {}\nfor day in range(planning_horizon_days):\n    max_trucks = daily_truck_availability[day]\n    for k in range(max_trucks):\n        for i in range(1, num_locations):\n            u[(day, k, i)] = intvar(1, num_locations-1)\n        \n        for i in range(1, num_locations):\n            for j in range(1, num_locations):\n                if i != j:\n                    model += u[(day, k, i)] + 1 <= u[(day, k, j)] + (num_locations) * (1 - x[(day, k, i, j)])\n\ntotal_distance = 0\nfor day in range(planning_horizon_days):\n    max_trucks = daily_truck_availability[day]\n    for k in range(max_trucks):\n        for i in range(num_locations):\n            for j in range(num_locations):\n                if i != j:\n                    total_distance += distance_matrix[i][j] * x[(day, k, i, j)]\n\nmodel.minimize(total_distance)\n\nif model.solve():\n    zone_collection_plans = []\n    for idx, zone in enumerate(waste_collection_zones, 1):\n        if isinstance(schedule_selection[idx], list):\n            zone_collection_plans.append(schedule_selection[idx])\n        elif zone[3] == [[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 0]]:\n            selected = schedule_selection[idx].value()\n            if selected == 0:\n                zone_collection_plans.append([1, 0, 0])\n            else:\n                zone_collection_plans.append([0, 1, 0])\n        else:\n            selected_idx = schedule_selection[idx].value()\n            zone_collection_plans.append(zone[3][selected_idx])\n    \n    daily_truck_routes = []\n    for day in range(planning_horizon_days):\n        day_routes = []\n        max_trucks = daily_truck_availability[day]\n        \n        for k in range(max_trucks):\n            route = [0]\n            current = 0\n            \n            while True:\n                next_loc = -1\n                for j in range(num_locations):\n                    if j != current and x[(day, k, current, j)].value() == 1:\n                        next_loc = j\n                        break\n                \n                if next_loc == -1 or next_loc == 0:\n                    break\n                \n                route.append(next_loc)\n                current = next_loc\n            \n            if len(route) > 1:\n                route.append(0)\n                day_routes.append(route)\n        \n        daily_truck_routes.append(day_routes)\n    \n    calculated_distance = 0\n    for day_routes in daily_truck_routes:\n        for route in day_routes:\n            for i in range(len(route) - 1):\n                calculated_distance += distance_matrix[route[i]][route[i + 1]]\n    \n    result = {\n        \"zone_collection_plans\": zone_collection_plans,\n        \"daily_truck_routes\": daily_truck_routes,\n        \"total_travel_distance\": calculated_distance\n    }\n    \n    print(json.dumps(result))\nelse:\n    print(\"No solution found\")",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    import math\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"zone_collection_plans\", \"daily_truck_routes\", \"total_travel_distance\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        zone_collection_plans = solution[\"zone_collection_plans\"]\n        daily_truck_routes = solution[\"daily_truck_routes\"]\n        total_travel_distance = solution[\"total_travel_distance\"]\n        \n        planning_horizon_days = structured_data[\"planning_horizon_days\"]\n        daily_truck_availability = structured_data[\"daily_truck_availability\"]\n        truck_load_capacity_kg = structured_data[\"truck_load_capacity_kg\"]\n        waste_processing_plant = structured_data[\"waste_processing_plant\"]\n        waste_collection_zones = structured_data[\"waste_collection_zones\"]\n        \n        errors = []\n        \n        all_locations = [waste_processing_plant] + waste_collection_zones\n        \n        def euclidean_distance(loc1, loc2):\n            return math.sqrt((loc1[0] - loc2[0])**2 + (loc1[1] - loc2[1])**2)\n        \n        if len(zone_collection_plans) != len(waste_collection_zones):\n            errors.append(f\"Schedule count mismatch\")\n        \n        for day_idx in range(planning_horizon_days):\n            if day_idx >= len(daily_truck_routes):\n                errors.append(f\"Missing routes for day {day_idx}\")\n                continue\n                \n            day_routes = daily_truck_routes[day_idx]\n            trucks_available = daily_truck_availability[day_idx]\n            \n            if len(day_routes) > trucks_available:\n                errors.append(f\"Too many routes on day {day_idx}\")\n            \n            visited_today = set()\n            \n            for route in day_routes:\n                if len(route) < 3 or route[0] != 0 or route[-1] != 0:\n                    errors.append(f\"Invalid route on day {day_idx}\")\n                    continue\n                \n                route_demand = sum(waste_collection_zones[vertex][2] for vertex in route[1:-1] if 0 <= vertex < len(waste_collection_zones))\n                \n                if route_demand > truck_load_capacity_kg:\n                    errors.append(f\"Capacity exceeded on day {day_idx}\")\n                \n                for vertex in route[1:-1]:\n                    if 0 <= vertex < len(waste_collection_zones):\n                        if vertex in visited_today:\n                            errors.append(f\"Zone {vertex} visited multiple times on day {day_idx}\")\n                        visited_today.add(vertex)\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_distance = reference_solution[\"total_travel_distance\"]\n            if optimal_distance == 0:\n                optimality_score = 1.0 if total_travel_distance == 0 else 0.0\n            else:\n                gap = abs(optimal_distance - total_travel_distance) / abs(optimal_distance)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error\"], \"optimality_score\": 0.0}"
}