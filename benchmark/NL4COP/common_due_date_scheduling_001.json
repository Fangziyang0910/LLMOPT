{
  "problem_id": "common_due_date_scheduling_001",
  "metadata": {
    "problem_type": "Single Machine Common Due Date Scheduling Problem",
    "difficulty": "simple"
  },
  "problem_description": "A university's IT department needs to schedule the maintenance of 6 critical servers on a single technician's workstation to minimize disruption costs related to a target completion date. The target date is determined as 60% of the total estimated time required to maintain all servers. Finishing significantly before this date might lead to premature system exposure or resource idleness (earliness penalty), while finishing after it would risk system downtime or security vulnerabilities (tardiness penalty). Each server has a specific estimated maintenance time and associated penalties for deviating from the target date. The department wants to determine the optimal sequence for maintaining these servers to minimize the total penalty. The details of the 6 servers are as follows:\n1. Server 1: Maintenance 9h, Early Penalty $4/h, Late Penalty $12/h\n2. Server 2: Maintenance 4h, Early Penalty $3/h, Late Penalty $12/h\n3. Server 3: Maintenance 13h, Early Penalty $1/h, Late Penalty $10/h\n4. Server 4: Maintenance 10h, Early Penalty $2/h, Late Penalty $5/h\n5. Server 5: Maintenance 7h, Early Penalty $4/h, Late Penalty $4/h\n6. Server 6: Maintenance 19h, Early Penalty $8/h, Late Penalty $14/h",
  "solution_format_description": "Print the following fields: - server_sequence: optimal maintenance order for servers. - total_cost: total penalty cost for the schedule.",
  "structured_data": {
    "servers": [
      [9, 4, 12],
      [4, 3, 12],
      [13, 1, 10],
      [10, 2, 5],
      [7, 4, 4],
      [19, 8, 14]
    ],
    "target_date_factor": 0.6
  },
  "reference_solution": {
    "server_sequence": [3, 6, 2, 1, 5, 4],
    "total_cost": 346.2
  },
  "solver_code": "from cpmpy import *\nimport json\n\nservers = [\n    [9, 4, 12],\n    [4, 3, 12],\n    [13, 1, 10],\n    [10, 2, 5],\n    [7, 4, 4],\n    [19, 8, 14]\n]\ntarget_date_factor = 0.6\n\nnum_servers = len(servers)\n\nmaintenance_times = [server[0] for server in servers]\nearliness_penalties = [server[1] for server in servers]\ntardiness_penalties = [server[2] for server in servers]\n\ntotal_maintenance_time = sum(maintenance_times)\nscale = 10\ntarget_date = int(total_maintenance_time * target_date_factor * scale)\n\nserver_sequence = intvar(1, num_servers, shape=num_servers)\n\nmodel = Model()\n\nmodel += AllDifferent(server_sequence)\n\ncumulative_time_vars = [intvar(0, total_maintenance_time * scale) for _ in range(num_servers)]\n\ntotal_penalty = intvar(0, 1000000) \n\nfor i in range(num_servers):\n    if i == 0:\n        server_id_at_pos_0 = server_sequence[0] - 1  \n        time_at_pos_0 = Element(maintenance_times, server_id_at_pos_0)\n        model += (cumulative_time_vars[0] == time_at_pos_0 * scale)\n    else:\n        server_id_at_pos_i = server_sequence[i] - 1 \n        time_at_pos_i = Element(maintenance_times, server_id_at_pos_i)\n        model += (cumulative_time_vars[i] == cumulative_time_vars[i-1] + time_at_pos_i * scale)\n\npenalty_terms = []\nfor i in range(num_servers):\n    server_id_at_pos_i = server_sequence[i] - 1 \n    \n    earliness_coeff_at_pos_i = Element(earliness_penalties, server_id_at_pos_i)\n    tardiness_coeff_at_pos_i = Element(tardiness_penalties, server_id_at_pos_i)\n    \n    earliness_component = intvar(0, 100000)\n    tardiness_component = intvar(0, 100000)\n    \n    diff_earliness_helper = intvar(-total_maintenance_time * scale, total_maintenance_time * scale)\n    diff_tardiness_helper = intvar(-total_maintenance_time * scale, total_maintenance_time * scale)\n    \n    model += (diff_earliness_helper == target_date - cumulative_time_vars[i])\n    model += (diff_tardiness_helper == cumulative_time_vars[i] - target_date)\n    \n    model += (earliness_component == earliness_coeff_at_pos_i * Maximum([0, diff_earliness_helper]))\n    model += (tardiness_component == tardiness_coeff_at_pos_i * Maximum([0, diff_tardiness_helper]))\n    \n    penalty_terms.append(earliness_component + tardiness_component)\n\nmodel += (total_penalty == sum(penalty_terms))\n\nmodel.minimize(total_penalty)\n\nif model.solve():\n    solution_sequence = [int(server_sequence[i].value()) for i in range(num_servers)]\n    \n    cumulative_time = 0\n    total_cost = 0\n    \n    for i, server_id in enumerate(solution_sequence):\n        server_idx = server_id - 1\n        maintenance_time = maintenance_times[server_idx]\n        earliness_penalty = earliness_penalties[server_idx]\n        tardiness_penalty = tardiness_penalties[server_idx]\n        \n        cumulative_time += maintenance_time\n        \n        target_date_float = total_maintenance_time * target_date_factor\n        earliness = max(0, target_date_float - cumulative_time)\n        tardiness = max(0, cumulative_time - target_date_float)\n        \n        early_cost = earliness * earliness_penalty\n        late_cost = tardiness * tardiness_penalty\n        total_cost += early_cost + late_cost\n    \n    result = {\n        \"server_sequence\": solution_sequence,\n        \"total_cost\": total_cost\n    }\n    print(json.dumps(result))\nelse:\n    print(\"No solution found\")",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n\n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n\n    if not solution or \"server_sequence\" not in solution:\n        return {\"is_valid\": False, \"validation_errors\": [\"Missing required field: 'server_sequence'\"], \"optimality_score\": 0.0}\n\n    try:\n        server_sequence = solution[\"server_sequence\"]\n        servers_data = structured_data[\"servers\"]\n        \n        num_servers = len(servers_data)\n        errors = []\n\n        if len(server_sequence) != num_servers:\n            errors.append(f\"Invalid sequence length: expected {num_servers}, got {len(server_sequence)}\")\n            return {\"is_valid\": False, \"validation_errors\": errors, \"optimality_score\": 0.0}\n\n        expected_set = set(range(1, num_servers + 1))\n        actual_set = set(server_sequence)\n        if actual_set != expected_set:\n             missing = expected_set - actual_set\n             extra = actual_set - expected_set\n             if missing:\n                 errors.append(f\"Missing server IDs: {sorted(list(missing))}\")\n             if extra:\n                 errors.append(f\"Extra server IDs: {sorted(list(extra))}\")\n             return {\"is_valid\": False, \"validation_errors\": errors, \"optimality_score\": 0.0}\n\n        if \"total_cost\" in solution:\n            total_candidate_penalty = solution[\"total_cost\"]\n        else:\n            return {\"is_valid\": False, \"validation_errors\": [\"Missing required field: 'total_cost'\"], \"optimality_score\": 0.0}\n\n        total_reference_penalty = reference_solution[\"total_cost\"]\n\n        if total_reference_penalty == 0:\n            if total_candidate_penalty == 0:\n                optimality_score = 1.0\n            else:\n                optimality_score = 0.0 \n        else:\n            gap = abs(total_candidate_penalty - total_reference_penalty) / abs(total_reference_penalty)\n            optimality_score = max(0, 1 - gap)\n\n        is_valid = (len(errors) == 0)\n        return {\n            \"is_valid\": is_valid,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n\n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Format error in solution data or an unexpected error occurred during evaluation: {str(e)}\"], \"optimality_score\": 0.0}"
}