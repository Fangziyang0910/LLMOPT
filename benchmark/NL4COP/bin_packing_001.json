{
  "problem_id": "bin_packing_001",
  "metadata": {
    "problem_type": "Bin Packing Problem",
    "difficulty": "simple"
  },
  "problem_description": "A logistics company needs to pack a set of parcels into delivery trucks for an upcoming shipment. Each parcel has a specific volume, and all trucks have the same cargo capacity. To minimize fuel costs and the number of trips, the company wants to use as few trucks as possible while ensuring that the total volume of parcels in each truck does not exceed its capacity.\n\nThe company has prepared the following 10 parcels for loading:\n1. Parcel A: 45 cubic units\n2. Parcel B: 30 cubic units\n3. Parcel C: 25 cubic units\n4. Parcel D: 40 cubic units\n5. Parcel E: 35 cubic units\n6. Parcel F: 20 cubic units\n7. Parcel G: 15 cubic units\n8. Parcel H: 50 cubic units\n9. Parcel I: 10 cubic units\n10. Parcel J: 20 cubic units\n\nEach truck has a cargo capacity of 100 cubic units. The company needs to determine how to assign these 10 parcels to the trucks such that the total number of trucks used is minimized, and no truck exceeds its capacity. Each parcel must be loaded into exactly one truck.",
  "solution_format_description": "Print the following fields: - num_trucks: total number of trucks used. - truck_loads: parcel indices assigned to each truck.",
  "structured_data": {
    "truck_capacity": 100,
    "num_parcels": 10,
    "parcel_volumes": [45, 30, 25, 40, 35, 20, 15, 50, 10, 20]
  },
  "reference_solution": {
    "num_trucks": 3,
    "truck_loads": [
      [5, 7, 8],
      [1, 3, 6, 9],
      [2, 4, 10]
    ]
  },
  "solver_code": "from cpmpy import *\nimport json\n\ndata = {\n    \"truck_capacity\": 100,\n    \"num_parcels\": 10,\n    \"parcel_volumes\": [45, 30, 25, 40, 35, 20, 15, 50, 10, 20]\n}\n\ntruck_capacity = data['truck_capacity']\nnum_parcels = data['num_parcels']\nparcel_volumes = data['parcel_volumes']\n\ny = boolvar(shape=num_parcels, name=\"y\") \nx = boolvar(shape=(num_parcels, num_parcels), name=\"x\")\n\nmodel = Model()\n\nfor i in range(num_parcels):\n    model += sum(x[i][j] for j in range(num_parcels)) == 1\n\nfor j in range(num_parcels):\n    model += sum(x[i][j] * parcel_volumes[i] for i in range(num_parcels)) <= truck_capacity * y[j]\n\nfor j in range(num_parcels - 1):\n    model += y[j] >= y[j+1]\n\nmodel.minimize(sum(y[j] for j in range(num_parcels)))\n\nif model.solve():\n    trucks_used = sum(int(y[j].value()) for j in range(num_parcels))\n\n    truck_loads = []\n    for j in range(num_parcels):\n        if y[j].value():\n            load = [i + 1 for i in range(num_parcels) if x[i][j].value()]\n            truck_loads.append(load)\n            \n    result = {\n        \"num_trucks\": trucks_used,\n        \"truck_loads\": truck_loads[:trucks_used]\n    }\n    print(json.dumps(result))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Invalid JSON format: {e}\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"num_trucks\", \"truck_loads\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        num_trucks = solution[\"num_trucks\"]\n        truck_loads = solution[\"truck_loads\"]\n        truck_capacity = structured_data[\"truck_capacity\"]\n        num_parcels = structured_data[\"num_parcels\"]\n        parcel_volumes = structured_data[\"parcel_volumes\"]\n        errors = []\n        \n        if not isinstance(num_trucks, int) or num_trucks < 0:\n             errors.append(f\"num_trucks must be a non-negative integer, got {type(num_trucks)} with value {num_trucks}.\")\n             return {\n                \"is_valid\": False,\n                \"validation_errors\": errors,\n                \"optimality_score\": 0.0\n             }\n             \n        if not isinstance(truck_loads, list):\n             errors.append(f\"truck_loads must be a list, got {type(truck_loads)}.\")\n        else:\n            if len(truck_loads) != num_trucks:\n                errors.append(f\"Length of 'truck_loads' list ({len(truck_loads)}) does not match 'num_trucks' ({num_trucks}).\")\n            \n            parcel_counts = [0] * (num_parcels + 1)\n            for truck_index, load in enumerate(truck_loads, start=1):\n                if not isinstance(load, list):\n                    errors.append(f\"Truck {truck_index} load must be a list of parcel indices, got {type(load)}.\")\n                    continue\n                    \n                load_total = 0\n                for parcel_idx in load:\n                    if not isinstance(parcel_idx, int) or parcel_idx < 1 or parcel_idx > num_parcels:\n                        errors.append(f\"Truck {truck_index} contains an invalid parcel index: {parcel_idx}. Indices must be integers between 1 and {num_parcels}.\")\n                        continue\n                    load_total += parcel_volumes[parcel_idx - 1]\n                    parcel_counts[parcel_idx] += 1\n                if load_total > truck_capacity:\n                    errors.append(f\"Truck {truck_index} exceeds capacity: total volume {load_total} > capacity {truck_capacity}.\")\n\n            for i in range(1, num_parcels + 1):\n                if parcel_counts[i] != 1:\n                    errors.append(f\"Parcel {i} appears {parcel_counts[i]} times (expected exactly once).\")\n\n        is_valid = len(errors) == 0\n        \n        if not is_valid:\n            optimality_score = 0.0\n        else:\n            optimal_trucks = reference_solution[\"num_trucks\"]\n            candidate_num_trucks = num_trucks\n            if optimal_trucks == 0:\n                optimality_score = 1.0 if candidate_num_trucks == 0 else 0.0\n            else:\n                gap = abs(optimal_trucks - candidate_num_trucks) / abs(optimal_trucks)\n                optimality_score = max(0.0, 1.0 - gap)\n\n        \n        return {\n            \"is_valid\": is_valid,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Unexpected error during evaluation: {e}\"], \"optimality_score\": 0.0}"
}