{
  "problem_id": "minimum_cut_001",
  "metadata": {
    "problem_type": "Minimum Cut Problem",
    "difficulty": "simple"
  },
  "problem_description": "A city's water distribution system consists of 10 junction points: a main water supply station, 8 intermediate junctions, and a residential area. These junctions are connected by 12 directional pipes, each with a specific flow capacity where water can only flow in the specified direction, and each pipe must either be fully open or fully closed. The network connections are structured as follows: From the main supply station, water flows to junction 1 through a pipe with capacity 5 cubic meters per minute and to junction 2 through a pipe with capacity 8 cubic meters per minute. In the next layer, junction 1 connects to junction 3 with a pipe capacity of 3 and to junction 4 with a pipe capacity of 6. Junction 2 connects to junction 4 with a pipe capacity of 4 and to junction 5 with a pipe capacity of 7. In the following layer, junction 3 connects to junction 6 with a pipe capacity of 5. Junction 4 connects to junction 6 with a pipe capacity of 2 and to junction 7 with a pipe capacity of 8. Junction 5 connects to junction 7 with a pipe capacity of 6. Finally, junction 6 connects to the residential area with a pipe capacity of 9, and junction 7 also connects to the residential area with a pipe capacity of 7. Due to an emergency maintenance situation in the residential area, the city engineer needs to identify which pipes to temporarily close to completely cut off all water flow from the supply station to the residential area, while ensuring the total capacity of the closed pipes is as small as possible to minimize disruption to other parts of the water system.",
  "solution_format_description": "Print the following fields: - critical_pipes: pipes to cut for minimum cut. - min_cut_capacity: total capacity of cut pipes.",
  "structured_data": {
    "num_junctions": 10,
    "pipes": [
      [0, 1, 5],
      [0, 2, 8],
      [1, 3, 3],
      [1, 4, 6],
      [2, 4, 4],
      [2, 5, 7],
      [3, 6, 5],
      [4, 6, 2],
      [4, 7, 8],
      [5, 7, 6],
      [6, 9, 9],
      [7, 9, 7]
    ]
  },
  "reference_solution": {
    "critical_pipes": [2, 7, 11],
    "min_cut_capacity": 12
  },
  "solver_code": "from cpmpy import *\nimport json\n\nnum_junctions = 10\npipes = [\n    [0, 1, 5],\n    [0, 2, 8],\n    [1, 3, 3],\n    [1, 4, 6],\n    [2, 4, 4],\n    [2, 5, 7],\n    [3, 6, 5],\n    [4, 6, 2],\n    [4, 7, 8],\n    [5, 7, 6],\n    [6, 9, 9],\n    [7, 9, 7]\n]\n\nsource = 0\nsink = 9\n\npipe_in_cut = boolvar(shape=len(pipes))\njunction_side = boolvar(shape=num_junctions)\n\nmodel = Model()\nmodel += junction_side[source] == 0\nmodel += junction_side[sink] == 1\n\nfor i, (u, v, capacity) in enumerate(pipes):\n    model += pipe_in_cut[i] == (junction_side[u] != junction_side[v])\n\ntotal_cut_capacity = sum(pipes[i][2] * pipe_in_cut[i] for i in range(len(pipes)))\nmodel.minimize(total_cut_capacity)\n\nif model.solve():\n    critical_pipes = [i for i in range(len(pipes)) if pipe_in_cut[i].value()]\n    result = {\n        \"critical_pipes\": critical_pipes,\n        \"min_cut_capacity\": total_cut_capacity.value()\n    }\n    print(json.dumps(result))\nelse:\n    print(\"No solution found\")",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"critical_pipes\", \"min_cut_capacity\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        critical_pipes = solution[\"critical_pipes\"]\n        min_cut_capacity = solution[\"min_cut_capacity\"]\n        pipes = structured_data[\"pipes\"]\n        num_junctions = structured_data[\"num_junctions\"]\n        \n        errors = []\n        \n        if not isinstance(critical_pipes, list):\n            errors.append(\"critical_pipes must be an array\")\n        \n        if not isinstance(min_cut_capacity, (int, float)):\n            errors.append(\"min_cut_capacity must be a number\")\n        \n        for pipe_idx in critical_pipes:\n            if not isinstance(pipe_idx, int) or pipe_idx < 0 or pipe_idx >= len(pipes):\n                errors.append(f\"Invalid pipe index: {pipe_idx}\")\n        \n        calculated_capacity = sum(pipes[i][2] for i in critical_pipes if 0 <= i < len(pipes))\n        if abs(calculated_capacity - min_cut_capacity) > 1e-6:\n            errors.append(f\"Capacity inconsistency: calculated {calculated_capacity}, declared {min_cut_capacity}\")\n        \n        adjacency = [[] for _ in range(num_junctions)]\n        for i, (u, v, capacity) in enumerate(pipes):\n            if i not in critical_pipes:\n                adjacency[u].append(v)\n        \n        from collections import deque\n        visited = [False] * num_junctions\n        queue = deque([0])\n        visited[0] = True\n        found_path = False\n        \n        while queue and not found_path:\n            node = queue.popleft()\n            if node == num_junctions - 1:\n                found_path = True\n                break\n            for neighbor in adjacency[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n        \n        if found_path:\n            errors.append(\"Cut does not separate source from sink - path still exists\")\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_capacity = reference_solution[\"min_cut_capacity\"]\n            if optimal_capacity == 0:\n                optimality_score = 1.0 if min_cut_capacity == 0 else 0.0\n            else:\n                gap = abs(optimal_capacity - min_cut_capacity) / abs(optimal_capacity)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}