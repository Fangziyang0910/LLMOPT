{
  "problem_id": "period_vehicle_routing_003",
  "metadata": {
    "problem_type": "Period Vehicle Routing Problem",
    "difficulty": "hard"
  },
  "problem_description": "A school meal delivery service operates from a central kitchen at coordinates (30.0, 40.0) and needs to plan efficient routes over a 5-day period. Every day has 2 delivery vans, each van can carry up to 160.0 kilograms of meals per day. The service delivers to 5 schools with different meal requirements and delivery preferences. Each school must be assigned exactly one delivery schedule, and daily routes must be planned to minimize total travel distance while ensuring all routes start and end at the central kitchen. School Alpha at (37.0, 52.0) needs 7.0 kg meals and can be delivered either on Monday only, Tuesday only, Wednesday only, Thursday only, or Friday only; School Beta at (49.0, 49.0) needs 30.0 kg meals and requires delivery every day; School Gamma at (52.0, 64.0) needs 16.0 kg meals and can be delivered either on Monday and Wednesday, Tuesday and Thursday, or Wednesday and Friday; School Delta at (20.0, 26.0) needs 9.0 kg meals and can be delivered either on Monday only, Tuesday only, Wednesday only, Thursday only, or Friday only; School Epsilon at (40.0, 30.0) needs 21.0 kg meals and can be delivered either on Monday and Wednesday, Tuesday and Thursday, or Wednesday and Friday.",  
  "solution_format_description": "Print the following fields: - selected_temporal_engagement_schedules: delivery schedule for each school. - autonomous_vehicle_trajectories: daily routes for each vehicle. - total_spatial_displacement_expenditure: total travel distance.",
  "structured_data": {
    "temporal_cycle_length": 5,
    "autonomous_vehicles_per_temporal_cycle": [2, 2, 2, 2, 2],
    "payload_capacity_kilograms": 160,
    "central_command_hub": [30, 40],
    "service_nodes": [
      [37, 52, 7, [[1,0,0,0,0], [0,1,0,0,0], [0,0,1,0,0], [0,0,0,1,0], [0,0,0,0,1]]],
      [49, 49, 30, [[1,1,1,1,1]]],
      [52, 64, 16, [[1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,1]]],
      [20, 26, 9, [[1,0,0,0,0], [0,1,0,0,0], [0,0,1,0,0], [0,0,0,1,0], [0,0,0,0,1]]],
      [40, 30, 21, [[1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,1]]]
    ]
  },
  "reference_solution": {
    "selected_temporal_engagement_schedules": [
      [0, 0, 0, 1, 0],
      [1, 1, 1, 1, 1],
      [0, 1, 0, 1, 0],
      [0, 0, 1, 0, 0],
      [1, 0, 1, 0, 0]
    ],
    "autonomous_vehicle_trajectories": [
      [[0, 4, 1, 0]],
      [[0, 2, 0]],
      [[0, 3, 4, 1, 0]],
      [[0, 1, 2, 3, 0]],
      [[0, 1, 0]]
    ],
    "total_spatial_displacement_expenditure": 316.18680752072095
  },
  "solver_code": "from cpmpy import *\nimport json\nimport math\n\ntemporal_cycle_length = 5\nautonomous_vehicles_per_temporal_cycle = [2, 2, 2, 2, 2]\npayload_capacity_kilograms = 160\ncentral_command_hub = [30, 40]\nservice_nodes = [\n    [37, 52, 7, [[1,0,0,0,0], [0,1,0,0,0], [0,0,1,0,0], [0,0,0,1,0], [0,0,0,0,1]]],\n    [49, 49, 30, [[1,1,1,1,1]]],\n    [52, 64, 16, [[1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,1]]],\n    [20, 26, 9, [[1,0,0,0,0], [0,1,0,0,0], [0,0,1,0,0], [0,0,0,1,0], [0,0,0,0,1]]],\n    [40, 30, 21, [[1,0,1,0,0], [0,1,0,1,0], [0,0,1,0,1]]]\n]\n\nall_locations = [central_command_hub] + service_nodes\nnum_service_nodes = len(service_nodes)\nnum_locations = len(all_locations)\n\ndef euclidean_distance(loc1, loc2):\n    return math.sqrt((loc1[0] - loc2[0])**2 + (loc1[1] - loc2[1])**2)\n\ndistance_matrix = [[euclidean_distance(all_locations[i], all_locations[j]) \n                   for j in range(num_locations)] for i in range(num_locations)]\n\nmodel = Model()\n\nschedule_selection = {}\nfor idx, node in enumerate(service_nodes, 1):\n    if len(node[3]) == 1:\n        schedule_selection[idx] = node[3][0]\n    elif node[3] == [[1,0,0,0,0], [0,1,0,0,0], [0,0,1,0,0], [0,0,0,1,0], [0,0,0,0,1]]:\n        schedule_selection[idx] = intvar(0, 4)\n    else:\n        schedule_selection[idx] = intvar(0, len(node[3]) - 1)\n\nx = {}\nfor day in range(temporal_cycle_length):\n    max_vehicles = autonomous_vehicles_per_temporal_cycle[day]\n    for k in range(max_vehicles):\n        for i in range(num_locations):\n            for j in range(num_locations):\n                if i != j:\n                    x[(day, k, i, j)] = boolvar()\n\nfor day in range(temporal_cycle_length):\n    max_vehicles = autonomous_vehicles_per_temporal_cycle[day]\n    \n    for k in range(max_vehicles):\n        model += sum(x[(day, k, 0, j)] for j in range(1, num_locations)) <= 1\n        model += sum(x[(day, k, i, 0)] for i in range(1, num_locations)) <= 1\n\nfor day in range(temporal_cycle_length):\n    max_vehicles = autonomous_vehicles_per_temporal_cycle[day]\n    for i in range(1, num_locations):\n        node = service_nodes[i-1]\n        \n        if isinstance(schedule_selection[i], list):\n            visit_expr = schedule_selection[i][day]\n        elif node[3] == [[1,0,0,0,0], [0,1,0,0,0], [0,0,1,0,0], [0,0,0,1,0], [0,0,0,0,1]]:\n            visit_expr = (schedule_selection[i] == day)\n        else:\n            visit_expr = 0\n            for idx, schedule in enumerate(node[3]):\n                if schedule[day] == 1:\n                    visit_expr += (schedule_selection[i] == idx)\n        \n        model += sum(x[(day, k, i, j)] for k in range(max_vehicles) \n                    for j in range(num_locations) if i != j) == visit_expr\n\nfor day in range(temporal_cycle_length):\n    max_vehicles = autonomous_vehicles_per_temporal_cycle[day]\n    for k in range(max_vehicles):\n        for i in range(num_locations):\n            model += sum(x[(day, k, i, j)] for j in range(num_locations) if i != j) == \\\n                     sum(x[(day, k, j, i)] for j in range(num_locations) if i != j)\n\nfor day in range(temporal_cycle_length):\n    max_vehicles = autonomous_vehicles_per_temporal_cycle[day]\n    for k in range(max_vehicles):\n        for i in range(num_locations):\n            model += sum(x[(day, k, i, j)] for j in range(num_locations) if i != j) <= 1\n\nfor day in range(temporal_cycle_length):\n    max_vehicles = autonomous_vehicles_per_temporal_cycle[day]\n    for k in range(max_vehicles):\n        route_demand = 0\n        for i in range(1, num_locations):\n            node = service_nodes[i-1]\n            \n            if isinstance(schedule_selection[i], list):\n                day_demand = schedule_selection[i][day] * node[2]\n            elif node[3] == [[1,0,0,0,0], [0,1,0,0,0], [0,0,1,0,0], [0,0,0,1,0], [0,0,0,0,1]]:\n                day_demand = (schedule_selection[i] == day) * node[2]\n            else:\n                day_demand = 0\n                for idx, schedule in enumerate(node[3]):\n                    if schedule[day] == 1:\n                        day_demand += (schedule_selection[i] == idx) * node[2]\n            \n            route_demand += day_demand * sum(x[(day, k, j, i)] for j in range(num_locations) if j != i)\n        model += route_demand <= payload_capacity_kilograms\n\nu = {}\nfor day in range(temporal_cycle_length):\n    max_vehicles = autonomous_vehicles_per_temporal_cycle[day]\n    for k in range(max_vehicles):\n        for i in range(1, num_locations):\n            u[(day, k, i)] = intvar(1, num_locations-1)\n        \n        for i in range(1, num_locations):\n            for j in range(1, num_locations):\n                if i != j:\n                    model += u[(day, k, i)] + 1 <= u[(day, k, j)] + (num_locations) * (1 - x[(day, k, i, j)])\n\ntotal_spatial_displacement_expenditure = 0\nfor day in range(temporal_cycle_length):\n    max_vehicles = autonomous_vehicles_per_temporal_cycle[day]\n    for k in range(max_vehicles):\n        for i in range(num_locations):\n            for j in range(num_locations):\n                if i != j:\n                    total_spatial_displacement_expenditure += distance_matrix[i][j] * x[(day, k, i, j)]\n\nmodel.minimize(total_spatial_displacement_expenditure)\n\nif model.solve():\n    selected_temporal_engagement_schedules = []\n    for idx, node in enumerate(service_nodes, 1):\n        if isinstance(schedule_selection[idx], list):\n            selected_temporal_engagement_schedules.append(schedule_selection[idx])\n        elif node[3] == [[1,0,0,0,0], [0,1,0,0,0], [0,0,1,0,0], [0,0,0,1,0], [0,0,0,0,1]]:\n            selected = schedule_selection[idx].value()\n            schedule = [0] * temporal_cycle_length\n            schedule[selected] = 1\n            selected_temporal_engagement_schedules.append(schedule)\n        else:\n            selected_idx = schedule_selection[idx].value()\n            selected_temporal_engagement_schedules.append(node[3][selected_idx])\n    \n    autonomous_vehicle_trajectories = []\n    for day in range(temporal_cycle_length):\n        day_trajectories = []\n        max_vehicles = autonomous_vehicles_per_temporal_cycle[day]\n        \n        for k in range(max_vehicles):\n            trajectory = [0]\n            current = 0\n            \n            while True:\n                next_loc = -1\n                for j in range(num_locations):\n                    if j != current and x[(day, k, current, j)].value() == 1:\n                        next_loc = j\n                        break\n                \n                if next_loc == -1 or next_loc == 0:\n                    break\n                \n                trajectory.append(next_loc)\n                current = next_loc\n            \n            if len(trajectory) > 1:\n                trajectory.append(0)\n                day_trajectories.append(trajectory)\n        \n        autonomous_vehicle_trajectories.append(day_trajectories)\n    \n    calculated_distance = 0\n    for day_trajectories in autonomous_vehicle_trajectories:\n        for trajectory in day_trajectories:\n            for i in range(len(trajectory) - 1):\n                calculated_distance += distance_matrix[trajectory[i]][trajectory[i + 1]]\n    \n    result = {\n        \"selected_temporal_engagement_schedules\": selected_temporal_engagement_schedules,\n        \"autonomous_vehicle_trajectories\": autonomous_vehicle_trajectories,\n        \"total_spatial_displacement_expenditure\": calculated_distance\n    }\n    \n    print(json.dumps(result))\nelse:\n    print(\"No solution found\")",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    import math\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"selected_temporal_engagement_schedules\", \"autonomous_vehicle_trajectories\", \"total_spatial_displacement_expenditure\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        selected_temporal_engagement_schedules = solution[\"selected_temporal_engagement_schedules\"]\n        autonomous_vehicle_trajectories = solution[\"autonomous_vehicle_trajectories\"]\n        total_spatial_displacement_expenditure = solution[\"total_spatial_displacement_expenditure\"]\n        \n        temporal_cycle_length = structured_data[\"temporal_cycle_length\"]\n        autonomous_vehicles_per_temporal_cycle = structured_data[\"autonomous_vehicles_per_temporal_cycle\"]\n        payload_capacity_kilograms = structured_data[\"payload_capacity_kilograms\"]\n        service_nodes = structured_data[\"service_nodes\"]\n        \n        errors = []\n        \n        if len(selected_temporal_engagement_schedules) != len(service_nodes):\n            errors.append(f\"Schedule count mismatch\")\n        \n        for day_idx in range(temporal_cycle_length):\n            if day_idx >= len(autonomous_vehicle_trajectories):\n                errors.append(f\"Missing trajectories for cycle {day_idx}\")\n                continue\n                \n            day_trajectories = autonomous_vehicle_trajectories[day_idx]\n            vehicles_available = autonomous_vehicles_per_temporal_cycle[day_idx]\n            \n            if len(day_trajectories) > vehicles_available:\n                errors.append(f\"Too many trajectories in cycle {day_idx}\")\n            \n            visited_today = set()\n            \n            for trajectory in day_trajectories:\n                if len(trajectory) < 3 or trajectory[0] != 0 or trajectory[-1] != 0:\n                    errors.append(f\"Invalid trajectory in cycle {day_idx}\")\n                    continue\n                \n                trajectory_demand = sum(service_nodes[vertex][2] for vertex in trajectory[1:-1] if 0 <= vertex < len(service_nodes))\n                \n                if trajectory_demand > payload_capacity_kilograms:\n                    errors.append(f\"Payload exceeded in cycle {day_idx}\")\n                \n                for vertex in trajectory[1:-1]:\n                    if 0 <= vertex < len(service_nodes):\n                        if vertex in visited_today:\n                            errors.append(f\"Node {vertex} visited multiple times in cycle {day_idx}\")\n                        visited_today.add(vertex)\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_distance = reference_solution[\"total_spatial_displacement_expenditure\"]\n            if optimal_distance == 0:\n                optimality_score = 1.0 if total_spatial_displacement_expenditure == 0 else 0.0\n            else:\n                gap = abs(optimal_distance - total_spatial_displacement_expenditure) / abs(optimal_distance)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error\"], \"optimality_score\": 0.0}"
}