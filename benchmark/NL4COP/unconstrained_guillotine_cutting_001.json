{
  "problem_id": "unconstrained_guillotine_cutting_001",
  "metadata": {
    "problem_type": "unconstrained guillotine cutting problem",
    "difficulty": "simple"
  },
  "problem_description": "An advanced industrial manufacturing enterprise is confronting a sophisticated spatial optimization challenge involving sequential rectangular sprite extraction from a premium material screen measuring length 250 centimeters and width 250 centimeters. This process employs guillotine cutting methodology where each incision must extend linearly from one edge to the opposite edge across the entire material. The unconstrained framework permits 90-degree rotational adjustment of sprites and imposes no limitations on the hierarchical organization or chronological sequencing of cutting operations. Manufacturing engineers must determine the optimal configuration and sequential cutting strategy to maximize total design points within the established guillotine cutting framework, governed by fundamental constraints that sprites must not overlap and must be completely contained within the designated screen boundaries. Screen specifications: length 250 centimeters and width 250 centimeters. Sprite inventory encompasses ten distinct configurations: 1) length 167 centimeters and width 184 centimeters, design points 30728 units; 2) length 114 centimeters and width 118 centimeters, design points 13452 units; 3) length 167 centimeters and width 152 centimeters, design points 25384 units; 4) length 83 centimeters and width 140 centimeters, design points 11620 units; 5) length 70 centimeters and width 86 centimeters, design points 6020 units; 6) length 143 centimeters and width 166 centimeters, design points 23738 units; 7) length 120 centimeters and width 160 centimeters, design points 19200 units; 8) length 66 centimeters and width 148 centimeters, design points 9768 units; 9) length 87 centimeters and width 141 centimeters, design points 12267 units; 10) length 69 centimeters and width 165 centimeters, design points 11385 units.",
  "solution_format_description": "Print the following fields: - placements: for each sprite, list placement with index, x, y, rotation. - total_design_points: total value of placed sprites.",
  "structured_data": {
    "screen_dimensions": [250, 250],
    "sprites": [
      [167, 184, 30728], 
      [114, 118, 13452], 
      [167, 152, 25384], 
      [83, 140, 11620], 
      [70, 86, 6020], 
      [143, 166, 23738], 
      [120, 160, 19200], 
      [66, 148, 9768], 
      [87, 141, 12267], 
      [69, 165, 11385]
    ]
  },
  "reference_solution": {
    "placements": [
      [0, 0, 0, 0], 
      [3, 167, 86, 0], 
      [4, 167, 0, 0], 
      [7, 1, 184, 1]
    ],
    "total_design_points": 58136
  },
  "solver_code": "from cpmpy import *\nimport json\n\nscreen_dimensions = [250, 250]\nsprites = [[167, 184, 30728], [114, 118, 13452], [167, 152, 25384], [83, 140, 11620], [70, 86, 6020], [143, 166, 23738], [120, 160, 19200], [66, 148, 9768], [87, 141, 12267], [69, 165, 11385]]\nallow_rotation = 1\nnum_sprites = len(sprites)\n\nx = intvar(0, screen_dimensions[0], shape=num_sprites)\ny = intvar(0, screen_dimensions[1], shape=num_sprites)\norientation = boolvar(shape=num_sprites) if allow_rotation else [0] * num_sprites\nselected = boolvar(shape=num_sprites)\n\nconstraints = []\n\nfor i in range(num_sprites):\n    w, h, design_points = sprites[i]\n    \n    if allow_rotation:\n        eff_w = w * (1 - orientation[i]) + h * orientation[i]\n        eff_h = h * (1 - orientation[i]) + w * orientation[i]\n    else:\n        eff_w = w\n        eff_h = h\n        \n    constraints += [selected[i].implies(x[i] + eff_w <= screen_dimensions[0])]\n    constraints += [selected[i].implies(y[i] + eff_h <= screen_dimensions[1])]\n    \n    for j in range(i + 1, num_sprites):\n        w_j, h_j, design_points_j = sprites[j]\n        \n        if allow_rotation:\n            eff_w_j = w_j * (1 - orientation[j]) + h_j * orientation[j]\n            eff_h_j = h_j * (1 - orientation[j]) + w_j * orientation[j]\n        else:\n            eff_w_j = w_j\n            eff_h_j = h_j\n            \n        constraints += [(selected[i] & selected[j]).implies(\n            (x[i] + eff_w <= x[j]) | (x[j] + eff_w_j <= x[i]) | (y[i] + eff_h <= y[j]) | (y[j] + eff_h_j <= y[i])\n        )]\n\nobjective = sum(selected[i] * sprites[i][2] for i in range(num_sprites))\n\nmodel = Model(constraints)\nmodel.maximize(objective)\n\nif model.solve():\n    placements = []\n    total_design_points = 0\n    for i in range(num_sprites):\n        if selected[i].value() == 1:\n            if allow_rotation:\n                orient = int(orientation[i].value())\n            else:\n                orient = 0\n            placements.append([i, int(x[i].value()), int(y[i].value()), orient])\n            total_design_points += sprites[i][2]\n    \n    result = {\"placements\": placements, \"total_design_points\": total_design_points}\n    print(json.dumps(result))\nelse:\n    print(json.dumps({\"placements\": [], \"total_design_points\": 0}))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    required_fields = [\"placements\", \"total_design_points\"]\n    missing = [f for f in required_fields if f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    try:\n        placements = solution[\"placements\"]\n        total_design_points = solution[\"total_design_points\"]\n        sprites = structured_data[\"sprites\"]\n        screen_dimensions = structured_data[\"screen_dimensions\"]\n        errors = []\n        placed_indices = [p[0] for p in placements]\n        if len(placed_indices) != len(set(placed_indices)):\n            errors.append(\"Duplicate sprite placements detected.\")\n        placed_rects = []\n        for placement in placements:\n            sprite_idx, x, y, orientation = placement\n            if not (0 <= sprite_idx < len(sprites)):\n                errors.append(f\"Sprite index {sprite_idx} is invalid.\")\n                continue\n            w, h, _ = sprites[sprite_idx]\n            p_width = w if orientation == 0 else h\n            p_height = h if orientation == 0 else w\n            if x < 0 or y < 0 or (x + p_width) > screen_dimensions[0] or (y + p_height) > screen_dimensions[1]:\n                errors.append(f\"Placement of sprite {sprite_idx} is out of screen boundaries.\")\n            placed_rects.append([x, y, x + p_width, y + p_height, sprite_idx])\n        for i in range(len(placed_rects)):\n            for j in range(i + 1, len(placed_rects)):\n                r1, r2 = placed_rects[i], placed_rects[j]\n                if not (r1[2] <= r2[0] or r2[2] <= r1[0] or r1[3] <= r2[1] or r2[3] <= r1[1]):\n                    errors.append(f\"Overlapping detected between sprite {r1[4]} and sprite {r2[4]}.\")\n        is_valid = len(errors) == 0\n        if is_valid:\n            optimal_value = reference_solution[\"total_design_points\"]\n            if optimal_value == 0:\n                optimality_score = 1.0 if total_design_points == 0 else 0.0\n            else:\n                gap = abs(optimal_value - total_design_points) / abs(optimal_value)\n                optimality_score = max(0, 1 - gap)\n        else:\n            optimality_score = 0.0\n        return {\"is_valid\": is_valid, \"validation_errors\": errors, \"optimality_score\": optimality_score}\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Evaluation error\"], \"optimality_score\": 0.0}"
}