{
  "problem_id": "crew_scheduling_001",
  "metadata": {
    "problem_type": "Crew Scheduling Problem",
    "difficulty": "simple"
  },
  "problem_description": "Within the intricate operational architecture of a multinational aviation logistics enterprise, a sophisticated resource allocation optimization paradigm emerges necessitating precise temporal coordination of aircraft maintenance interventions across three specialized technical service units. The system encompasses ten critical maintenance operations systematically indexed from 0 through 9, each constrained within discrete temporal availability windows corresponding to aircraft ground time intervals. Inter-task transitions incur quantifiable resource expenditure encompassing equipment repositioning logistics and human capital temporal costs. The optimization challenge requires determining an optimal task assignment strategy that minimizes total transition costs while satisfying several critical operational constraints: all maintenance operations must be assigned to service units without exception, tasks within each service unit must be scheduled without temporal overlap, the total operational span for any service unit cannot exceed 480 minutes from first task commencement to final task completion, and valid transition pathways must exist between consecutive tasks assigned to the same service unit. The temporal parameters for maintenance operations are systematically defined as follows: Operation 0 executes within the temporal interval commencing at minute 0 and concluding at minute 60; Operation 1 operates between minute 80 and minute 140; Operation 2 spans the interval from minute 160 through minute 220; Operation 3 is scheduled between minutes 240 and 300; Operation 4 occupies the timeframe from minute 320 to minute 380; Operation 5 extends from minute 400 through minute 460; Operation 6 begins at minute 20 and terminates at minute 80; Operation 7 encompasses the period from minute 100 to minute 160; Operation 8 is allocated to the interval from minute 180 to minute 240; and Operation 9 runs from minute 260 through minute 320. The transition expenditure matrix exhibits the following quantified resource consumption values: progression from Operation 0 to Operation 1 incurs an expenditure of 20 monetary units; advancement from Operation 0 to Operation 2 requires 40 units; transition from Operation 0 to Operation 3 demands 60 units; movement from Operation 0 to Operation 4 necessitates 80 units; progression from Operation 0 to Operation 5 consumes 100 units; transition from Operation 1 to Operation 2 involves 25 units; advancement from Operation 1 to Operation 3 requires 45 units; movement from Operation 1 to Operation 4 entails 65 units; progression from Operation 1 to Operation 5 involves 85 units; transition from Operation 2 to Operation 3 costs 30 units; advancement from Operation 2 to Operation 4 requires 50 units; movement from Operation 2 to Operation 5 involves 70 units; transition from Operation 3 to Operation 4 necessitates 35 units; advancement from Operation 3 to Operation 5 requires 55 units; progression from Operation 4 to Operation 5 costs 40 units; transition from Operation 6 to Operation 7 involves 22 units; advancement from Operation 6 to Operation 8 requires 42 units; movement from Operation 6 to Operation 9 costs 62 units; progression from Operation 7 to Operation 8 necessitates 27 units; transition from Operation 7 to Operation 9 involves 47 units; advancement from Operation 8 to Operation 9 requires 32 units; movement from Operation 0 to Operation 6 costs 15 units; progression from Operation 1 to Operation 7 involves 18 units; transition from Operation 2 to Operation 8 requires 21 units; advancement from Operation 3 to Operation 9 costs 24 units; movement from Operation 4 to Operation 6 necessitates 27 units; progression from Operation 5 to Operation 7 involves 30 units; transition from Operation 7 to Operation 2 requires 35 units; advancement from Operation 9 to Operation 4 costs 45 units; and movement from Operation 1 to Operation 8 involves 50 units.",  
  "solution_format_description": "Print the following fields: - service_unit_assignments: operation assignments for each service unit. - aggregate_transition_expenditure: total transition cost between operations.",  
  "structured_data": {
    "num_service_units": 3,
    "operational_time_limit": 480,
    "maintenance_operations": [
      [0, 60], 
      [80, 140], 
      [160, 220], 
      [240, 300], 
      [320, 380], 
      [400, 460], 
      [20, 80], 
      [100, 160], 
      [180, 240], 
      [260, 320]
    ],
    "inter_operation_transition_expenditures": [
      [0, 1, 20], 
      [0, 2, 40], 
      [0, 3, 60], 
      [0, 4, 80], 
      [0, 5, 100], 
      [1, 2, 25], 
      [1, 3, 45], 
      [1, 4, 65], 
      [1, 5, 85], 
      [2, 3, 30], 
      [2, 4, 50], 
      [2, 5, 70], 
      [3, 4, 35], 
      [3, 5, 55], 
      [4, 5, 40], 
      [6, 7, 22], 
      [6, 8, 42], 
      [6, 9, 62], 
      [7, 8, 27], 
      [7, 9, 47], 
      [8, 9, 32], 
      [0, 6, 15], 
      [1, 7, 18], 
      [2, 8, 21], 
      [3, 9, 24], 
      [4, 6, 27], 
      [5, 7, 30],
      [7, 2, 35],
      [9, 4, 45],
      [1, 8, 50]
    ]
  },
  "reference_solution": {
    "service_unit_assignments": [[5], [6, 7, 8, 9], [0, 1, 2, 3, 4]],
    "aggregate_transition_expenditure": 191
  },
  "solver_code": "from cpmpy import *\nimport json\n\nn = 10\nm = 3\n\nstart = [0, 80, 160, 240, 320, 400, 20, 100, 180, 260]\nend = [60, 140, 220, 300, 380, 460, 80, 160, 240, 320]\n\ntransition_cost = [[0] * n for _ in range(n)]\ntransition_pairs = {\n    (0,1):20, (0,2):40, (0,3):60, (0,4):80, (0,5):100,\n    (1,2):25, (1,3):45, (1,4):65, (1,5):85,\n    (2,3):30, (2,4):50, (2,5):70,\n    (3,4):35, (3,5):55,\n    (4,5):40,\n    (6,7):22, (6,8):42, (6,9):62,\n    (7,8):27, (7,9):47,\n    (8,9):32,\n    (0,6):15, (1,7):18, (2,8):21, (3,9):24,\n    (4,6):27, (5,7):30, (7,2):35, (9,4):45, (1,8):50\n}\n\nfor (i, j), cost in transition_pairs.items():\n    transition_cost[i][j] = cost\n\noverlap_pairs = []\nfor i in range(n):\n    for j in range(i+1, n):\n        if max(start[i], start[j]) < min(end[i], end[j]):\n            overlap_pairs.append((i, j))\n\nmax_span = 480\n\nassign = boolvar(shape=(n, m), name=\"assign\")\nsucc = boolvar(shape=(n, n), name=\"succ\")\nfirst = boolvar(shape=n, name=\"first\")\nlast = boolvar(shape=n, name=\"last\")\n\nmodel = Model()\n\nfor i in range(n):\n    model += sum(assign[i, :]) == 1\n\nfor (i, j) in overlap_pairs:\n    for k in range(m):\n        model += (assign[i, k] + assign[j, k]) <= 1\n\nfor i in range(n):\n    for j in range(n):\n        if i != j:\n            model += succ[i, j] <= sum(assign[i, :] * assign[j, :])\n\nfor i in range(n):\n    model += succ[i, i] == 0\n\nfor i in range(n):\n    model += first[i] + sum(succ[:, i]) == 1\n\nfor i in range(n):\n    model += last[i] + sum(succ[i, :]) == 1\n\nfor k in range(m):\n    model += sum(first * assign[:, k]) == 1\n\nfor k in range(m):\n    model += sum(last * assign[:, k]) == 1\n\nfor i in range(n):\n    for j in range(n):\n        if i != j:\n            model += (succ[i, j] == 1).implies(end[i] <= start[j])\n\nfor i in range(n):\n    for j in range(n):\n        if transition_cost[i][j] == 0 and i != j:\n            model += succ[i, j] == 0\n\nfor k in range(m):\n    unit_start = intvar(0, max(start), name=f\"unit_start_{k}\")\n    unit_end = intvar(0, max(end), name=f\"unit_end_{k}\")\n    \n    for i in range(n):\n        model += (first[i] & assign[i, k]).implies(unit_start == start[i])\n    \n    for i in range(n):\n        model += (last[i] & assign[i, k]).implies(unit_end == end[i])\n    \n    model += unit_end - unit_start <= max_span\n\nobjective = sum(transition_cost[i][j] * succ[i, j] for i in range(n) for j in range(n))\nmodel.minimize(objective)\n\nif model.solve():\n    service_unit_assignments = [[] for _ in range(m)]\n    \n    for k in range(m):\n        for i in range(n):\n            if assign[i, k].value():\n                service_unit_assignments[k].append(i)\n    \n    for k in range(m):\n        service_unit_assignments[k].sort(key=lambda op_id: start[op_id])\n    \n    calculated_expenditure = 0\n    for i in range(n):\n        for j in range(n):\n            if succ[i, j].value() and transition_cost[i][j] > 0:\n                calculated_expenditure += transition_cost[i][j]\n    \n    result = {\n        \"service_unit_assignments\": service_unit_assignments, \n        \"aggregate_transition_expenditure\": calculated_expenditure\n    }\n    print(json.dumps(result))\nelse:\n    print(json.dumps({\"service_unit_assignments\": [], \"aggregate_transition_expenditure\": 0}))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"service_unit_assignments\", \"aggregate_transition_expenditure\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        service_unit_assignments = solution[\"service_unit_assignments\"]\n        aggregate_transition_expenditure = solution[\"aggregate_transition_expenditure\"]\n        num_service_units = structured_data[\"num_service_units\"]\n        operational_time_limit = structured_data[\"operational_time_limit\"]\n        maintenance_operations = structured_data[\"maintenance_operations\"]\n        inter_operation_transition_expenditures = structured_data[\"inter_operation_transition_expenditures\"]\n        \n        errors = []\n        \n        if len(service_unit_assignments) > num_service_units:\n            errors.append(f\"Too many service units: expected max {num_service_units}, got {len(service_unit_assignments)}\")\n        \n        empty_units = [i for i, unit in enumerate(service_unit_assignments) if not unit]\n        if empty_units:\n            if len(empty_units) == len(service_unit_assignments):\n                errors.append(\"All service units are empty\")\n        \n        all_operations = []\n        for unit in service_unit_assignments:\n            all_operations.extend(unit)\n        \n        expected_operations = set(range(len(maintenance_operations)))\n        actual_operations = set(all_operations)\n        \n        if len(all_operations) != len(maintenance_operations):\n            errors.append(f\"Wrong number of operations: expected {len(maintenance_operations)}, got {len(all_operations)}\")\n        \n        if actual_operations != expected_operations:\n            missing_operations = expected_operations - actual_operations\n            extra_operations = actual_operations - expected_operations\n            if missing_operations:\n                errors.append(f\"Missing operations: {sorted(missing_operations)}\")\n            if extra_operations:\n                errors.append(f\"Extra operations: {sorted(extra_operations)}\")\n        \n        cost_matrix = {}\n        for i, j, cost in inter_operation_transition_expenditures:\n            cost_matrix[(i, j)] = cost\n        \n        calculated_expenditure = 0\n        for unit_idx, unit in enumerate(service_unit_assignments):\n            if not unit:\n                continue\n            \n            unit_sorted = sorted(unit, key=lambda operation_id: maintenance_operations[operation_id][0])\n            \n            for i in range(len(unit_sorted) - 1):\n                current_operation = unit_sorted[i]\n                next_operation = unit_sorted[i + 1]\n                \n                current_start, current_end = maintenance_operations[current_operation]\n                next_start, next_end = maintenance_operations[next_operation]\n                \n                if current_end > next_start:\n                    errors.append(f\"Time overlap in service unit {unit_idx}: operation {current_operation} ends at {current_end} but operation {next_operation} starts at {next_start}\")\n                \n                if (current_operation, next_operation) not in cost_matrix:\n                    errors.append(f\"Invalid transition in service unit {unit_idx}: no transition from operation {current_operation} to operation {next_operation}\")\n                else:\n                    calculated_expenditure += cost_matrix[(current_operation, next_operation)]\n            \n            if unit_sorted:\n                first_operation = unit_sorted[0]\n                last_operation = unit_sorted[-1]\n                duty_time = maintenance_operations[last_operation][1] - maintenance_operations[first_operation][0]\n                if duty_time > operational_time_limit:\n                    errors.append(f\"Operational time exceeded in service unit {unit_idx}: {duty_time} > {operational_time_limit}\")\n        \n        if abs(calculated_expenditure - aggregate_transition_expenditure) > 1e-6:\n            errors.append(f\"Expenditure inconsistency: calculated {calculated_expenditure}, declared {aggregate_transition_expenditure}\")\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            reference_expenditure = reference_solution[\"aggregate_transition_expenditure\"]\n            if reference_expenditure == 0:\n                optimality_score = 1.0 if aggregate_transition_expenditure == 0 else 0.0\n            else:\n                gap = (aggregate_transition_expenditure - reference_expenditure) / abs(reference_expenditure)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}