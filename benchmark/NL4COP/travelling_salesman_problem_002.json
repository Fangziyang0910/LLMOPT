{
  "problem_id": "travelling_salesman_problem_002",
  "metadata": {
    "problem_type": "Traveling Salesman Problem",
    "difficulty": "medium"
  },
  "problem_description": "An autonomous aerial logistics system is tasked with executing a sophisticated routing optimization mission across a complex spatial network spanning a 100km by 100km operational theater. The unmanned aerial vehicle (UAV) operates from a central command hub positioned at coordinates (4, 3) on the digital navigation grid, where each coordinate unit corresponds to one kilometer of actual airspace. The mission protocol requires the UAV to establish contact with nineteen distinct delivery waypoints distributed throughout the airspace, ensuring each waypoint receives exactly one visitation before the aircraft returns to its origin point for mission completion. The spatial distribution of waypoints reflects realistic delivery patterns across the operational domain: Waypoint Alpha is situated at (97, 20) in the northeastern quadrant, Waypoint Bravo occupies (75, 54) in the north-central region, Waypoint Charlie is positioned at (91, 83) near the northern boundary, Waypoint Delta resides at (57, 75) in the central-northern sector, Waypoint Echo is located at (81, 14) in the eastern corridor, Waypoint Foxtrot maintains position (71, 25) in the east-central area, Waypoint Golf is situated at (53, 28) in the central region, Waypoint Hotel occupies (28, 17) in the western sector, Waypoint India is positioned at (3, 94) in the northwestern extremity, Waypoint Juliet can be found at (29, 64) in the west-central zone, Waypoint Kilo resides at (89, 54) in the northeastern area, Waypoint Lima is located at (77, 3) in the southeastern quadrant, Waypoint Mike sits at (35, 31) in the central-western region, Waypoint November occupies (89, 69) in the northeast, Waypoint Oscar is positioned at (69, 11) in the east-southeast sector, Waypoint Papa can be reached at (94, 13) near the eastern boundary, Waypoint Quebec maintains location (86, 94) in the northern extremity, Waypoint Romeo is situated at (35, 0) along the southern edge, and Waypoint Sierra is established at (11, 27) in the southwestern corridor. The UAV navigation system employs direct trajectory planning between waypoints using optimal flight paths calculated through Euclidean distance metrics. The mission objective is to determine the most efficient permutation of waypoint visitations that yields the minimal cumulative flight distance while satisfying the operational constraint of forming a complete closed circuit originating and terminating at the central command hub.",
  "solution_format_description": "Print the following fields: - flight_path: complete route visiting all waypoints. - total_distance: total flight distance.",  
  "structured_data": {
  "num_waypoints": 20,
  "waypoint_coordinates": [
    [4, 3], [97, 20], [75, 54], [91, 83], [57, 75],
    [81, 14], [71, 25], [53, 28], [28, 17], [3, 94],
    [29, 64], [89, 54], [77, 3], [35, 31], [89, 69],
    [69, 11], [94, 13], [86, 94], [35, 0], [11, 27]
  ]
},
  "reference_solution": {
  "total_distance": 452.09,
  "flight_path": [0, 19, 9, 10, 4, 17, 3, 14, 2, 11, 1, 16, 5, 12, 15, 6, 7, 13, 8, 18, 0]
},
  "solver_code": "from cpmpy import *\nimport json\nimport math\n\nnum_waypoints = 20\nwaypoint_coordinates = [\n    [4, 3], [97, 20], [75, 54], [91, 83], [57, 75],\n    [81, 14], [71, 25], [53, 28], [28, 17], [3, 94],\n    [29, 64], [89, 54], [77, 3], [35, 31], [89, 69],\n    [69, 11], [94, 13], [86, 94], [35, 0], [11, 27]\n]\n\ndist_matrix = [[0.0 for _ in range(num_waypoints)] for _ in range(num_waypoints)]\nfor i in range(num_waypoints):\n    for j in range(num_waypoints):\n        if i != j:\n            xi, yi = waypoint_coordinates[i]\n            xj, yj = waypoint_coordinates[j]\n            dist_matrix[i][j] = math.sqrt((xi - xj)**2 + (yi - yj)**2)\n\nmodel = Model()\nx = boolvar(shape=(num_waypoints, num_waypoints))\n\nfor i in range(num_waypoints):\n    model += sum(x[i, j] for j in range(num_waypoints) if i != j) == 1\n\nfor j in range(num_waypoints):\n    model += sum(x[i, j] for i in range(num_waypoints) if i != j) == 1\n\nu = intvar(0, num_waypoints - 1, shape=num_waypoints)\nfor i in range(1, num_waypoints):\n    for j in range(1, num_waypoints):\n        if i != j:\n            model += u[i] - u[j] + num_waypoints * x[i, j] <= num_waypoints - 1\n\nscale_factor = 10000\nscaled_flat_distances = [int(dist_matrix[r][c] * scale_factor) for r in range(num_waypoints) for c in range(num_waypoints)]\nobjective_expr = sum(x[i, j] * scaled_flat_distances[i * num_waypoints + j] for i in range(num_waypoints) for j in range(num_waypoints) if i != j)\nmodel.minimize(objective_expr)\n\nif model.solve():\n    flight_path = [0]\n    current_waypoint = 0\n    visited = {0}\n    \n    while len(flight_path) < num_waypoints:\n        for j in range(num_waypoints):\n            if j not in visited and x[current_waypoint, j].value():\n                flight_path.append(j)\n                visited.add(j)\n                current_waypoint = j\n                break\n    \n    flight_path.append(0)\n    \n    solution = {\n        \"flight_path\": flight_path,\n        \"total_distance\": round(float(objective_expr.value()) / scale_factor, 2)\n    }\n    print(json.dumps(solution))\nelse:\n    print(json.dumps({\"flight_path\": [], \"total_distance\": -1}))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"flight_path\", \"total_distance\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        flight_path = solution[\"flight_path\"]\n        total_distance = solution[\"total_distance\"]\n        num_waypoints = structured_data[\"num_waypoints\"]\n        errors = []\n        \n        if not isinstance(flight_path, list):\n            errors.append(\"Flight path must be a list.\")\n        \n        if isinstance(flight_path, list):\n            if len(flight_path) == 0 or flight_path[0] != 0 or flight_path[-1] != 0:\n                errors.append(\"Flight path must start and end at command hub (node 0).\")\n            \n            if len(flight_path) > 0:\n                visited_nodes = set(flight_path[:-1])  \n                expected_nodes = set(range(num_waypoints))\n                if visited_nodes != expected_nodes:\n                    errors.append(\"Flight path must visit each waypoint exactly once (excluding final return to command hub).\")\n        \n        if not isinstance(total_distance, (int, float)):\n            errors.append(\"Total distance must be a number.\")\n        \n        if len(errors) > 0:\n            return {\n                \"is_valid\": False,\n                \"validation_errors\": errors,\n                \"optimality_score\": 0.0\n            }\n        \n        optimal_value = reference_solution[\"total_distance\"]\n        if optimal_value == 0:\n            optimality_score = 1.0 if total_distance == 0 else 0.0\n        else:\n            gap = abs(optimal_value - total_distance) / abs(optimal_value)\n            optimality_score = max(0, 1 - gap)\n            \n        return {\n            \"is_valid\": True,\n            \"validation_errors\": [],\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}