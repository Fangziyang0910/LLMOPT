{
  "problem_id": "constrained_guillotine_cutting_001",
  "metadata": {
    "problem_type": "Constrained Guillotine Cutting Problem",
    "difficulty": "simple"
  },
  "problem_description": "A metal fabrication workshop needs to optimize steel plate cutting for industrial machinery parts using a guillotine cutting process. The workshop has standard steel plates measuring 40 by 70 centimeters and needs to cut three types of machine components with the following specifications: 1. Large mounting brackets: 30 by 43 centimeters, maximum 4 pieces required, each valued at 500 dollars 2. Medium support plates: 29 by 39 centimeters, maximum 4 pieces required, each valued at 460 dollars 3. Small connector pieces: 25 by 35 centimeters, maximum 3 pieces required, each valued at 400 dollars Each machine component must be cut in its original orientation (no rotating the piece), completely within the steel plate boundaries, and without overlapping any other components. In guillotine cutting, each cut must be a straight line that goes completely from one edge to another without cutting through any placed component, and this property must hold recursively for all resulting subregions. The workshop supervisor needs to determine the optimal layout of machine components to maximize the total value while meeting all cutting and placement requirements.",
  "solution_format_description": "Output JSON with fields: {\"total_value\": 0, \"placements\": []}. Notes: placements array contains all placed pieces, each placement is [piece_type_id, x, y, length, width, orientation] where piece_type_id is 1-3, x,y are bottom-left coordinates, length/width are dimensions, and orientation is 0 (no rotation allowed).",
  "structured_data": {
    "container_dimensions": [40, 70],
    "item_inventory": [
      [30, 43, 4, 500],
      [29, 39, 4, 460],
      [25, 35, 3, 400]
    ]
  },
  "reference_solution": {
    "total_value": 800, 
    "placements": [
      [3, 11, 35, 25, 35, 0], [3, 11, 0, 25, 35, 0]
    ]
  },
  "solver_code": "from cpmpy import *\nimport json\n\ncontainer_dimensions = [40, 70]\nitem_inventory = [\n    [30, 43, 4, 500],\n    [29, 39, 4, 460],\n    [25, 35, 3, 400]\n]\n\ncontainer_length, container_width = container_dimensions\nm = len(item_inventory)\nmax_placements = sum(item[2] for item in item_inventory)\n\npiece_types_vars = [intvar(1, m, name=f\"p_type_{i}\") for i in range(max_placements)]\nx_vars = [intvar(0, container_length, name=f\"x_{i}\") for i in range(max_placements)]\ny_vars = [intvar(0, container_width, name=f\"y_{i}\") for i in range(max_placements)]\nplaced_vars = [boolvar(name=f\"placed_{i}\") for i in range(max_placements)]\n\nmodel = Model()\n\nfor i in range(max_placements):\n    for p in range(m):\n        item = item_inventory[p]\n        model += ((piece_types_vars[i] == p+1) & placed_vars[i]).implies(\n            (x_vars[i] + item[0] <= container_length) & \n            (y_vars[i] + item[1] <= container_width)\n        )\n\nfor i in range(max_placements):\n    for j in range(i+1, max_placements):\n        p1_type, x1, y1, placed1 = piece_types_vars[i], x_vars[i], y_vars[i], placed_vars[i]\n        p2_type, x2, y2, placed2 = piece_types_vars[j], x_vars[j], y_vars[j], placed_vars[j]\n        \n        p1_len = 0\n        p1_wid = 0\n        for p in range(m):\n            p1_len += (p1_type == p+1) * item_inventory[p][0]\n            p1_wid += (p1_type == p+1) * item_inventory[p][1]\n        \n        p2_len = 0\n        p2_wid = 0\n        for p in range(m):\n            p2_len += (p2_type == p+1) * item_inventory[p][0]\n            p2_wid += (p2_type == p+1) * item_inventory[p][1]\n        \n        model += (placed1 & placed2).implies(\n            (x1 + p1_len <= x2) | (x2 + p2_len <= x1) |\n            (y1 + p1_wid <= y2) | (y2 + p2_wid <= y1)\n        )\n\nfor p in range(m):\n    count = 0\n    for i in range(max_placements):\n        count += (piece_types_vars[i] == p+1) & placed_vars[i]\n    model += count <= item_inventory[p][2]\n\ntotal_value = 0\nfor i in range(max_placements):\n    item_value = 0\n    for p in range(m):\n        item_value += (piece_types_vars[i] == p+1) * item_inventory[p][3]\n    total_value += placed_vars[i] * item_value\n\nmodel.maximize(total_value)\n\nif model.solve():\n    solution_placements = []\n    solution_value = 0\n    \n    for i in range(max_placements):\n        if placed_vars[i].value():\n            p_idx = piece_types_vars[i].value() - 1\n            item = item_inventory[p_idx]\n            solution_placements.append([\n                piece_types_vars[i].value(), \n                x_vars[i].value(),           \n                y_vars[i].value(),          \n                item[0],             \n                item[1],              \n                0                          \n            ])\n            solution_value += item[3]\n    \n    result = {\n        \"total_value\": solution_value,\n        \"placements\": solution_placements\n    }\n    print(json.dumps(result))\nelse:\n    print(json.dumps({\"total_value\": 0, \"placements\": []}))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"total_value\", \"placements\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        total_value = solution[\"total_value\"]\n        placements = solution[\"placements\"]\n        \n        steel_plates_length = structured_data[0][\"steel_plates_length\"]\n        steel_plates_width = structured_data[0][\"steel_plates_width\"]\n        machine_components = structured_data[0][\"machine_components\"]\n        \n        m = len(machine_components)\n        computed_value = 0\n        type_counts = [0] * m\n        rects = []\n        errors = []\n        \n        for idx, placement in enumerate(placements):\n            if not (isinstance(placement, (list, tuple)) and len(placement) == 6):\n                errors.append(f\"Placement {idx} is not a 6-tuple: {placement}\")\n                continue\n            \n            try:\n                type_idx = int(placement[0])\n                x = int(placement[1])\n                y = int(placement[2])\n                placed_len = int(placement[3])\n                placed_wid = int(placement[4])\n                orient = int(placement[5])\n            except:\n                errors.append(f\"Non-integer value in placement {idx}: {placement}\")\n                continue\n            \n            if type_idx < 1 or type_idx > m:\n                errors.append(f\"Placement {idx} has invalid piece type index {type_idx}\")\n                continue\n            \n            if orient != 0:\n                errors.append(f\"Placement {idx} has invalid orientation flag {orient}\")\n                continue\n            \n            piece = machine_components[type_idx - 1]\n            expected_length = piece[\"length\"]\n            expected_width = piece[\"width\"]\n            max_allowed = piece[\"max\"]\n            p_value = piece[\"value\"]\n            \n            if placed_len != expected_length or placed_wid != expected_width:\n                errors.append(f\"Placement {idx} dimensions ({placed_len}, {placed_wid}) do not match expected ({expected_length}, {expected_width})\")\n                continue\n            \n            if x < 0 or y < 0 or (x + placed_len) > steel_plates_length or (y + placed_wid) > steel_plates_width:\n                errors.append(f\"Placement {idx} is out of bounds\")\n                continue\n            \n            type_counts[type_idx - 1] += 1\n            computed_value += p_value\n            \n            rects.append((x, y, x + placed_len, y + placed_wid))\n        \n        num_rects = len(rects)\n        for i in range(num_rects):\n            for j in range(i + 1, num_rects):\n                r1 = rects[i]\n                r2 = rects[j]\n                dx = min(r1[2], r2[2]) - max(r1[0], r2[0])\n                dy = min(r1[3], r2[3]) - max(r1[1], r2[1])\n                if dx > 0 and dy > 0:\n                    errors.append(f\"Placements {i} and {j} overlap\")\n        \n        for i in range(m):\n            if type_counts[i] > machine_components[i][\"max\"]:\n                errors.append(f\"Piece type {i+1} exceeds allowed count: {type_counts[i]} > {machine_components[i]['max']}\")\n        \n        if rects and not is_guillotine(rects, 0, 0, steel_plates_length, steel_plates_width):\n            errors.append(\"Guillotine condition violated\")\n        \n        if abs(computed_value - total_value) > 1e-6:\n            errors.append(f\"Value inconsistency: computed {computed_value}, reported {total_value}\")\n        \n        is_valid = len(errors) == 0\n        \n        if not is_valid:\n            optimality_score = 0.0\n        else:\n            optimal_value = reference_solution[\"total_value\"]\n            if optimal_value == 0:\n                optimality_score = 1.0 if total_value == 0 else 0.0\n            else:\n                gap = abs(optimal_value - total_value) / abs(optimal_value)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": is_valid,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}\n\n\ndef is_guillotine(rects, bx, by, ex, ey):\n    if not rects:\n        return True\n    \n    if len(rects) == 1:\n        r = rects[0]\n        if r[0] == bx and r[1] == by and r[2] == ex and r[3] == ey:\n            return True\n    \n    for x in range(bx + 1, ex):\n        if all((r[2] <= x or r[0] >= x) for r in rects):\n            left_rects = [r for r in rects if r[2] <= x]\n            right_rects = [r for r in rects if r[0] >= x]\n            if is_guillotine(left_rects, bx, by, x, ey) and is_guillotine(right_rects, x, by, ex, ey):\n                return True\n    \n    for y in range(by + 1, ey):\n        if all((r[3] <= y or r[1] >= y) for r in rects):\n            bottom_rects = [r for r in rects if r[3] <= y]\n            top_rects = [r for r in rects if r[1] >= y]\n            if is_guillotine(bottom_rects, bx, by, ex, y) and is_guillotine(top_rects, bx, y, ex, ey):\n                return True\n    \n    return False"
}
