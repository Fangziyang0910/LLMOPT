{
  "problem_id": "open_shop_scheduling_002",
  "metadata": {
    "problem_type": "Open Shop Scheduling Problem",
    "difficulty": "medium"
  },
  "problem_description": "In a sophisticated quantum computing research facility, seven independent experiments each contain seven computational procedures that require uninterrupted processing on dedicated quantum processing nodes. The research coordinator seeks to optimize the temporal efficiency by determining the optimal initiation schedule for each procedure to minimize the overall completion horizon across all concurrent experimental executions. The system must adhere to several operational constraints: first, within any given experiment, only one procedure can be active at any time, meaning procedures in the same experiment cannot run simultaneously; second, each quantum processing node can handle only one procedure at any given moment, so procedures assigned to the same QPU must be scheduled at different times; third, and most importantly, unlike traditional sequential workflows, each experiment's procedures can be processed in any order the coordinator chooses. The coordinator can decide which procedure to run first, second, and so on for each experiment based on what works best for the overall schedule. The experiment specifications are as follows: Experiment Alpha has seven procedures requiring QPU-3 for 89 seconds, QPU-2 for 39 seconds, QPU-4 for 54 seconds, QPU-7 for 34 seconds, QPU-1 for 71 seconds, QPU-6 for 92 seconds, and QPU-5 for 56 seconds, all of which can be scheduled in any order. Experiment Beta has procedures requiring QPU-2 for 19 seconds, QPU-3 for 13 seconds, QPU-6 for 81 seconds, QPU-5 for 46 seconds, QPU-1 for 91 seconds, QPU-4 for 73 seconds, and QPU-7 for 27 seconds, with complete flexibility in sequencing. Experiment Gamma has procedures requiring QPU-1 for 66 seconds, QPU-2 for 95 seconds, QPU-6 for 48 seconds, QPU-7 for 24 seconds, QPU-3 for 96 seconds, QPU-4 for 18 seconds, and QPU-5 for 14 seconds, allowing any arrangement. Experiment Delta has procedures requiring QPU-2 for 48 seconds, QPU-6 for 46 seconds, QPU-1 for 78 seconds, QPU-7 for 94 seconds, QPU-3 for 19 seconds, QPU-4 for 68 seconds, and QPU-5 for 63 seconds, with flexible ordering. Experiment Epsilon has procedures requiring QPU-6 for 60 seconds, QPU-4 for 28 seconds, QPU-3 for 91 seconds, QPU-5 for 75 seconds, QPU-1 for 52 seconds, QPU-2 for 9 seconds, and QPU-7 for 7 seconds, which can be arranged in any sequence. Experiment Zeta has procedures requiring QPU-7 for 33 seconds, QPU-5 for 98 seconds, QPU-2 for 37 seconds, QPU-1 for 11 seconds, QPU-4 for 2 seconds, QPU-3 for 30 seconds, and QPU-6 for 38 seconds, allowing any permutation. Experiment Eta has procedures requiring QPU-2 for 83 seconds, QPU-4 for 45 seconds, QPU-5 for 37 seconds, QPU-7 for 77 seconds, QPU-6 for 52 seconds, QPU-3 for 88 seconds, and QPU-1 for 52 seconds, with completely flexible scheduling order.",
  "solution_format_description": "Print the following fields: - start_times: start time for each experiment's procedure. - makespan: total completion time.",
  "structured_data": {
    "n_experiments": 7,
    "n_qpus": 7,
    "procedure_durations": [
      [89, 39, 54, 34, 71, 92, 56],
      [19, 13, 81, 46, 91, 73, 27],
      [66, 95, 48, 24, 96, 18, 14],
      [48, 46, 78, 94, 19, 68, 63],
      [60, 28, 91, 75, 52, 9, 7],
      [33, 98, 37, 11, 2, 30, 38],
      [83, 45, 37, 77, 52, 88, 52]
    ],
    "qpu_assignments": [
      [3, 2, 4, 7, 1, 6, 5],
      [2, 3, 6, 5, 1, 4, 7],
      [1, 2, 6, 7, 3, 4, 5],
      [2, 6, 1, 7, 3, 4, 5],
      [6, 4, 3, 5, 1, 2, 7],
      [7, 5, 2, 1, 4, 3, 6],
      [2, 4, 5, 7, 6, 3, 1]
    ]
  },
  "reference_solution": {
    "start_times": [
      [219, 126, 165, 92, 364, 0, 308],
      [0, 308, 93, 379, 203, 20, 352],
      [294, 20, 378, 236, 118, 2, 276],
      [236, 290, 0, 142, 412, 336, 78],
      [230, 290, 321, 0, 151, 115, 126],
      [379, 178, 284, 140, 0, 88, 340],
      [352, 230, 141, 275, 178, 0, 88]
    ],
    "makespan": 435
  },
  "solver_code": "from cpmpy import *\nimport json\n\nn_experiments = 7\nn_qpus = 7\nprocedure_durations = [\n    [89, 39, 54, 34, 71, 92, 56],\n    [19, 13, 81, 46, 91, 73, 27],\n    [66, 95, 48, 24, 96, 18, 14],\n    [48, 46, 78, 94, 19, 68, 63],\n    [60, 28, 91, 75, 52, 9, 7],\n    [33, 98, 37, 11, 2, 30, 38],\n    [83, 45, 37, 77, 52, 88, 52]\n]\nqpu_assignments = [\n    [3, 2, 4, 7, 1, 6, 5],\n    [2, 3, 6, 5, 1, 4, 7],\n    [1, 2, 6, 7, 3, 4, 5],\n    [2, 6, 1, 7, 3, 4, 5],\n    [6, 4, 3, 5, 1, 2, 7],\n    [7, 5, 2, 1, 4, 3, 6],\n    [2, 4, 5, 7, 6, 3, 1]\n]\n\nmodel = Model()\n\nstart = intvar(0, sum(sum(row) for row in procedure_durations), shape=(n_experiments, n_qpus))\n\nmakespan = intvar(0, sum(sum(row) for row in procedure_durations))\n\nfor i in range(n_experiments):\n    for j1 in range(n_qpus):\n        for j2 in range(j1 + 1, n_qpus):\n            model += (\n                (start[i][j1] + procedure_durations[i][j1] <= start[i][j2]) |\n                (start[i][j2] + procedure_durations[i][j2] <= start[i][j1])\n            )\n\nqpu_tasks = {}\nfor i in range(n_experiments):\n    for j in range(n_qpus):\n        qpu_id = qpu_assignments[i][j]\n        if qpu_id not in qpu_tasks:\n            qpu_tasks[qpu_id] = []\n        qpu_tasks[qpu_id].append((i, j))\n\nfor tasks in qpu_tasks.values():\n    if len(tasks) > 1:\n        for idx1 in range(len(tasks)):\n            for idx2 in range(idx1 + 1, len(tasks)):\n                i1, j1 = tasks[idx1]\n                i2, j2 = tasks[idx2]\n                model += (\n                    (start[i1][j1] + procedure_durations[i1][j1] <= start[i2][j2]) |\n                    (start[i2][j2] + procedure_durations[i2][j2] <= start[i1][j1])\n                )\n\nfor i in range(n_experiments):\n    for j in range(n_qpus):\n        model += makespan >= start[i][j] + procedure_durations[i][j]\n\nmodel.minimize(makespan)\n\nif model.solve():\n    start_times_solution = [[start[i][j].value() for j in range(n_qpus)] for i in range(n_experiments)]\n    makespan_solution = makespan.value()\n    \n    result = {\n        \"start_times\": start_times_solution,\n        \"makespan\": int(makespan_solution)\n    }\n    \n    print(json.dumps(result))\nelse:\n    print(json.dumps({\"error\": \"No solution found\"}))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"start_times\", \"makespan\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        start_times = solution[\"start_times\"]\n        makespan = solution[\"makespan\"]\n        n_experiments = structured_data[\"n_experiments\"]\n        n_qpus = structured_data[\"n_qpus\"]\n        procedure_durations = structured_data[\"procedure_durations\"]\n        qpu_assignments = structured_data[\"qpu_assignments\"]\n        errors = []\n        \n        if len(start_times) != n_experiments:\n            errors.append(f\"Experiments count mismatch: expected {n_experiments}, got {len(start_times)}\")\n            return {\"is_valid\": False, \"validation_errors\": errors, \"optimality_score\": 0.0}\n            \n        for i in range(n_experiments):\n            if len(start_times[i]) != n_qpus:\n                errors.append(f\"Procedures count mismatch for experiment {i}: expected {n_qpus}, got {len(start_times[i])}\")\n                return {\"is_valid\": False, \"validation_errors\": errors, \"optimality_score\": 0.0}\n                \n        for i in range(n_experiments):\n            for j in range(n_qpus):\n                if not isinstance(start_times[i][j], int) or start_times[i][j] < 0:\n                    errors.append(f\"Invalid start time at experiment {i}, procedure {j}: {start_times[i][j]}\")\n\n        for i in range(n_experiments):\n            for j1 in range(n_qpus):\n                for j2 in range(j1 + 1, n_qpus):\n                    st1 = start_times[i][j1]\n                    st2 = start_times[i][j2]\n                    et1 = st1 + procedure_durations[i][j1]\n                    et2 = st2 + procedure_durations[i][j2]\n                    if not (et1 <= st2 or et2 <= st1):\n                        errors.append(f\"Overlapping procedures in experiment {i}: procedures {j1} and {j2}\")\n\n        qpu_schedules = {}\n        for i in range(n_experiments):\n            for j in range(n_qpus):\n                qpu_id = qpu_assignments[i][j]\n                st = start_times[i][j]\n                et = st + procedure_durations[i][j]\n                if qpu_id not in qpu_schedules:\n                    qpu_schedules[qpu_id] = []\n                qpu_schedules[qpu_id].append((st, et, i, j))\n        \n        for qpu_id, tasks in qpu_schedules.items():\n            tasks_sorted = sorted(tasks, key=lambda x: x[0])\n            for k in range(1, len(tasks_sorted)):\n                prev_st, prev_et, prev_i, prev_j = tasks_sorted[k - 1]\n                curr_st, curr_et, curr_i, curr_j = tasks_sorted[k]\n                if prev_et > curr_st:\n                    errors.append(f\"QPU {qpu_id} conflict: experiment {prev_i} procedure {prev_j} overlaps with experiment {curr_i} procedure {curr_j}\")\n        \n        if len(errors) == 0:\n            optimal_makespan = reference_solution[\"makespan\"]\n            if optimal_makespan == 0:\n                optimality_score = 1.0 if makespan == 0 else 0.0\n            else:\n                gap = abs(optimal_makespan - makespan) / abs(optimal_makespan)\n                optimality_score = max(0, 1 - gap)\n        else:\n            optimality_score = 0.0\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}