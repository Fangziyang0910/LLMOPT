{
  "problem_id": "flow_shop_scheduling_001",
  "metadata": {
    "problem_type": "Flow Shop Scheduling Problem",
    "difficulty": "simple"
  },
  "problem_description": "Within the sophisticated operational framework of an advanced aerospace manufacturing facility, ten distinct precision-engineered turbine blade components require sequential processing through a quintet of specialized manufacturing stations operating under stringent temporal constraints. Each component must traverse the entire production pipeline in a predetermined technological sequence, where each station possesses exclusive processing capabilities that cannot be simultaneously allocated to multiple components. The manufacturing paradigm enforces a strict precedence relationship: components cannot commence processing at subsequent stations until completion at the preceding station, while each station maintains unitary processing capacity at any given time interval. The processing requirements exhibit significant heterogeneity across both components and stations, creating a complex multidimensional optimization landscape. Component Alpha-001 requires ten minutes at the CNC milling station, fifteen minutes at the precision grinding station, twelve minutes at the heat treatment station, eighteen minutes at the surface finishing station, and fourteen minutes at the quality inspection station. Component Beta-002 demonstrates extended processing demands with twenty minutes at CNC milling, twenty-five minutes at precision grinding, twenty-two minutes at heat treatment, twenty-eight minutes at surface finishing, and twenty-four minutes at quality inspection respectively across the sequential stations. Component Gamma-003 exhibits intermediate processing characteristics with thirty minutes at CNC milling, thirty-five minutes at precision grinding, thirty-two minutes at heat treatment, thirty-eight minutes at surface finishing, and thirty-four minutes at quality inspection. Component Delta-004's processing profile encompasses forty minutes at CNC milling, forty-five minutes at precision grinding, forty-two minutes at heat treatment, forty-eight minutes at surface finishing, and forty-four minutes at quality inspection, while Component Epsilon-005 requires fifty minutes at CNC milling, fifty-five minutes at precision grinding, fifty-two minutes at heat treatment, fifty-eight minutes at surface finishing, and fifty-four minutes at quality inspection across the manufacturing sequence. Component Zeta-006 demonstrates elevated processing demands with sixty minutes at CNC milling, sixty-five minutes at precision grinding, sixty-two minutes at heat treatment, sixty-eight minutes at surface finishing, and sixty-four minutes at quality inspection. Component Eta-007's processing requirements escalate to seventy minutes at CNC milling, seventy-five minutes at precision grinding, seventy-two minutes at heat treatment, seventy-eight minutes at surface finishing, and seventy-four minutes at quality inspection. Component Theta-008 exhibits substantial processing intensity with eighty minutes at CNC milling, eighty-five minutes at precision grinding, eighty-two minutes at heat treatment, eighty-eight minutes at surface finishing, and eighty-four minutes at quality inspection. Component Iota-009 requires ninety minutes at CNC milling, ninety-five minutes at precision grinding, ninety-two minutes at heat treatment, ninety-eight minutes at surface finishing, and ninety-four minutes at quality inspection, while Component Kappa-010 demonstrates the highest processing demands with one hundred minutes at CNC milling, one hundred five minutes at precision grinding, one hundred two minutes at heat treatment, one hundred eight minutes at surface finishing, and one hundred four minutes at quality inspection across the sequential manufacturing stations. How should the facility management sequence these ten turbine blade components through the manufacturing pipeline to achieve the shortest possible total production time for completing the entire batch?",
  "solution_format_description": "Print the following fields: - component_sequence: processing order for components. - total_production_time: total time to complete all operations.",
  "structured_data": {
    "components": 10,
    "stations": 5,
    "processing_time_matrix": [
      [10, 15, 12, 18, 14],
      [20, 25, 22, 28, 24],
      [30, 35, 32, 38, 34],
      [40, 45, 42, 48, 44],
      [50, 55, 52, 58, 54],
      [60, 65, 62, 68, 64],
      [70, 75, 72, 78, 74],
      [80, 85, 82, 88, 84],
      [90, 95, 92, 98, 94],
      [100, 105, 102, 108, 104]
    ]
  },
  "reference_solution": {
    "component_sequence": [1, 3, 4, 6, 7, 8, 5, 2, 9, 10],
    "total_production_time": 969
  },
  "solver_code": "from cpmpy import *\nimport json\n\ncomponents = 10\nstations = 5\nprocessing_time_matrix = [\n    [10, 15, 12, 18, 14],\n    [20, 25, 22, 28, 24],\n    [30, 35, 32, 38, 34],\n    [40, 45, 42, 48, 44],\n    [50, 55, 52, 58, 54],\n    [60, 65, 62, 68, 64],\n    [70, 75, 72, 78, 74],\n    [80, 85, 82, 88, 84],\n    [90, 95, 92, 98, 94],\n    [100, 105, 102, 108, 104]\n]\n\ncomponent_sequence = intvar(1, components, shape=components)\n\nmodel = Model()\n\nmodel += AllDifferent(component_sequence)\n\ncompletion = [[intvar(0, 10000) for _ in range(stations)] for _ in range(components)]\n\nfor i in range(components):\n    for j in range(stations):\n        component_idx = component_sequence[i] - 1\n        proc_time = Element([processing_time_matrix[p][j] for p in range(components)], component_idx)\n        \n        if i == 0 and j == 0:\n            model += (completion[i][j] == proc_time)\n        elif i == 0:\n            model += (completion[i][j] == completion[i][j-1] + proc_time)\n        elif j == 0:\n            model += (completion[i][j] == completion[i-1][j] + proc_time)\n        else:\n            model += (completion[i][j] == max(completion[i-1][j], completion[i][j-1]) + proc_time)\n\ntotal_production_time = completion[components-1][stations-1]\n\nmodel.minimize(total_production_time)\n\nif model.solve():\n    result = {\n        \"component_sequence\": [int(component_sequence[i].value()) for i in range(components)],\n        \"total_production_time\": int(total_production_time.value())\n    }\n    print(json.dumps(result))\nelse:\n    print(\"No solution found\")",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"component_sequence\", \"total_production_time\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        component_sequence = solution[\"component_sequence\"]\n        candidate_total_time = solution[\"total_production_time\"]\n        \n        components = structured_data[\"components\"]\n        stations = structured_data[\"stations\"]\n        processing_time_matrix = structured_data[\"processing_time_matrix\"]\n        errors = []\n        \n        if len(component_sequence) != components:\n            errors.append(f\"component_sequence length mismatch: expected {components}, got {len(component_sequence)}\")\n        \n        expected_set = set(range(1, components + 1))\n        actual_set = set(component_sequence)\n        if actual_set != expected_set:\n            missing = expected_set - actual_set\n            extra = actual_set - expected_set\n            if missing:\n                errors.append(f\"Missing component IDs: {sorted(list(missing))}\")\n            if extra:\n                errors.append(f\"Extra component IDs: {sorted(list(extra))}\")\n        \n        if len(errors) > 0:\n            return {\"is_valid\": False, \"validation_errors\": errors, \"optimality_score\": 0.0}\n        \n        seq_zero = [component - 1 for component in component_sequence]\n        completion = [[0] * stations for _ in range(components)]\n        \n        for i in range(components):\n            for j in range(stations):\n                proc_time = processing_time_matrix[seq_zero[i]][j]\n                if i == 0 and j == 0:\n                    completion[i][j] = proc_time\n                elif i == 0:\n                    completion[i][j] = completion[i][j - 1] + proc_time\n                elif j == 0:\n                    completion[i][j] = completion[i - 1][j] + proc_time\n                else:\n                    completion[i][j] = max(completion[i - 1][j], completion[i][j - 1]) + proc_time\n        \n        calculated_total_time = completion[-1][-1]\n        \n        if abs(calculated_total_time - candidate_total_time) > 1e-6:\n            errors.append(f\"Total production time inconsistency: calculated {calculated_total_time}, declared {candidate_total_time}\")\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_value = reference_solution[\"total_production_time\"]\n            if optimal_value == 0:\n                optimality_score = 1.0 if candidate_total_time == 0 else 0.0\n            else:\n                gap = abs(optimal_value - candidate_total_time) / abs(optimal_value)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}