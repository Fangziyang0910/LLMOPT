{
  "problem_id": "pmed_uncap_002",
  "metadata": {
    "problem_type": "P-Median Problem",
    "difficulty": "medium"
  },
  "problem_description": "A sophisticated neural network optimization paradigm requires strategic deployment of three cognitive processing hubs across a seven-node distributed intelligence architecture to establish optimal information flow pathways that minimize cumulative computational latency while adhering to strict bandwidth allocation constraints and quantum coherence preservation protocols. The network topology employs a sophisticated adjacency matrix where each connection represents bidirectional data transmission channels with associated latency coefficients measured in milliseconds. The objective is to identify optimal hub placement configurations that minimize the aggregate signal propagation delay across all network segments while maintaining information fidelity above established threshold parameters. Network connection characteristics and latency coefficients include: bidirectional transmission pathway between node one and node two exhibits latency ten milliseconds; pathway connecting node one and node three demonstrates coefficient five; pathway between node one and node four shows coefficient eight; pathway linking node one and node five reveals coefficient twelve; pathway connecting node one and node six exhibits coefficient fifteen; pathway between node one and node seven demonstrates coefficient twenty; pathway linking node two and node three shows coefficient seven; pathway connecting node two and node four exhibits coefficient six; pathway between node two and node five demonstrates coefficient nine; pathway linking node two and node six reveals coefficient eleven; pathway connecting node two and node seven shows coefficient eighteen; pathway between node three and node four exhibits coefficient four; pathway linking node three and node five demonstrates coefficient fourteen; pathway connecting node three and node six reveals coefficient sixteen; pathway between node three and node seven shows coefficient twenty-two; pathway linking node four and node five exhibits coefficient three; pathway connecting node four and node six demonstrates coefficient thirteen; pathway between node four and node seven reveals coefficient seventeen; pathway linking node five and node six exhibits coefficient two; pathway connecting node five and node seven demonstrates coefficient nineteen; and pathway between node six and node seven reveals coefficient twenty-five. Each network node must establish connectivity with exactly one cognitive processing hub, and the computational latency from any node to its assigned hub represents the minimum achievable signal propagation delay through available transmission channels utilizing optimal routing protocols.",
  "solution_format_description": "Print the following fields: - cognitive_processing_hubs: selected facility locations. - total_computational_latency: total distance cost. - neural_connectivity_assignments: for each node, list assignment with facility, pathway, cost.",
  "structured_data": {
    "network_node_count": 7,
    "cognitive_hub_count": 3,
    "neural_transmission_pathways": [
      [1, 2, 10],
      [1, 3, 5],
      [1, 4, 8],
      [1, 5, 12],
      [1, 6, 15],
      [1, 7, 20],
      [2, 3, 7],
      [2, 4, 6],
      [2, 5, 9],
      [2, 6, 11],
      [2, 7, 18],
      [3, 4, 4],
      [3, 5, 14],
      [3, 6, 16],
      [3, 7, 22],
      [4, 5, 3],
      [4, 6, 13],
      [4, 7, 17],
      [5, 6, 2],
      [5, 7, 19],
      [6, 7, 25]
    ]
  },
  "reference_solution": {
    "cognitive_processing_hubs": [3, 5, 7], 
    "total_computational_latency": 17, 
    "neural_connectivity_assignments": [
      [3, [1, 3], 5],
      [3, [2, 3], 7],
      [3, [3], 0],
      [5, [4, 5], 3],
      [5, [5], 0],
      [5, [6, 5], 2],
      [7, [7], 0]
    ]
  },
  "solver_code": "from cpmpy import *\nimport json\n\nnetwork_node_count = 7\ncognitive_hub_count = 3\nneural_transmission_pathways = [\n    [1, 2, 10],\n    [1, 3, 5],\n    [1, 4, 8],\n    [1, 5, 12],\n    [1, 6, 15],\n    [1, 7, 20],\n    [2, 3, 7],\n    [2, 4, 6],\n    [2, 5, 9],\n    [2, 6, 11],\n    [2, 7, 18],\n    [3, 4, 4],\n    [3, 5, 14],\n    [3, 6, 16],\n    [3, 7, 22],\n    [4, 5, 3],\n    [4, 6, 13],\n    [4, 7, 17],\n    [5, 6, 2],\n    [5, 7, 19],\n    [6, 7, 25]\n]\n\nINF = float('inf')\ndist = [[INF] * network_node_count for _ in range(network_node_count)]\nnext_node = [[-1] * network_node_count for _ in range(network_node_count)]\n\nfor i in range(network_node_count):\n    dist[i][i] = 0\n    for j in range(network_node_count):\n        if i == j:\n            next_node[i][j] = j\n\nfor pathway in neural_transmission_pathways:\n    i = pathway[0] - 1\n    j = pathway[1] - 1\n    latency = pathway[2]\n    if latency < dist[i][j]:\n        dist[i][j] = latency\n        dist[j][i] = latency\n        next_node[i][j] = j\n        next_node[j][i] = i\n\nfor k in range(network_node_count):\n    for i in range(network_node_count):\n        for j in range(network_node_count):\n            if dist[i][k] + dist[k][j] < dist[i][j]:\n                dist[i][j] = dist[i][k] + dist[k][j]\n                next_node[i][j] = next_node[i][k]\n\ndef get_neural_pathway(i, j):\n    if dist[i][j] == INF:\n        return []\n    pathway = [i]\n    while i != j:\n        i = next_node[i][j]\n        pathway.append(i)\n    return pathway\n\ncognitive_hub = boolvar(shape=network_node_count)\nassign = intvar(shape=(network_node_count, network_node_count), lb=0, ub=1)\n\nmodel = Model()\nmodel += sum(cognitive_hub) == cognitive_hub_count\n\nfor i in range(network_node_count):\n    model += sum(assign[i][j] for j in range(network_node_count)) == 1\n\nfor i in range(network_node_count):\n    for j in range(network_node_count):\n        model += assign[i][j] <= cognitive_hub[j]\n\ntotal_computational_latency = sum(dist[i][j] * assign[i][j] for i in range(network_node_count) for j in range(network_node_count))\nmodel.minimize(total_computational_latency)\n\nif model.solve():\n    selected_cognitive_hubs = [i+1 for i in range(network_node_count) if cognitive_hub[i].value()]\n    \n    neural_connectivity_assignments = []\n    for i in range(network_node_count):\n        for j in range(network_node_count):\n            if assign[i][j].value():\n                pathway = get_neural_pathway(i, j)\n                pathway_1_indexed = [node+1 for node in pathway]\n                latency = dist[i][j]\n                neural_connectivity_assignments.append([j+1, pathway_1_indexed, latency])\n    \n    result = {\n        \"cognitive_processing_hubs\": selected_cognitive_hubs,\n        \"total_computational_latency\": total_computational_latency.value(),\n        \"neural_connectivity_assignments\": neural_connectivity_assignments\n    }\n    print(json.dumps(result))\nelse:\n    print(\"No solution found\")",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n\n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n\n    required_fields = [\"cognitive_processing_hubs\", \"total_computational_latency\", \"neural_connectivity_assignments\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n\n    errors = []\n    optimality_score = 0.0\n\n    try:\n        cognitive_processing_hubs = solution[\"cognitive_processing_hubs\"]\n        total_computational_latency = solution[\"total_computational_latency\"]\n        neural_connectivity_assignments = solution[\"neural_connectivity_assignments\"]\n        \n        network_node_count = structured_data[\"network_node_count\"]\n        cognitive_hub_count = structured_data[\"cognitive_hub_count\"]\n        neural_transmission_pathways = structured_data[\"neural_transmission_pathways\"]\n\n        if not isinstance(cognitive_processing_hubs, list) or len(cognitive_processing_hubs) != cognitive_hub_count:\n            errors.append(f\"Cognitive processing hubs must be a list of exactly {cognitive_hub_count} distinct integers.\")\n        elif len(set(cognitive_processing_hubs)) != cognitive_hub_count:\n            errors.append(\"Cognitive processing hub locations must be distinct.\")\n        elif any(not isinstance(c, int) or c < 1 or c > network_node_count for c in cognitive_processing_hubs):\n            errors.append(f\"Each cognitive processing hub must be an integer in the range [1, {network_node_count}].\")\n\n        if not isinstance(neural_connectivity_assignments, list) or len(neural_connectivity_assignments) != network_node_count:\n            errors.append(f\"Neural connectivity assignments must be a list of exactly {network_node_count} arrays.\")\n        else:\n            assigned_nodes = set()\n            for idx, assignment in enumerate(neural_connectivity_assignments):\n                if not isinstance(assignment, list) or len(assignment) != 3:\n                    errors.append(f\"Neural connectivity assignment {idx+1} must be an array of [hub, pathway, latency].\")\n                    continue\n                    \n                hub = assignment[0]\n                pathway = assignment[1]\n                latency = assignment[2]\n                \n                if not isinstance(hub, int) or hub < 1 or hub > network_node_count:\n                     errors.append(f\"Hub number must be an integer in the range [1, {network_node_count}].\")\n                if not isinstance(pathway, list) or len(pathway) < 1:\n                     errors.append(f\"Pathway must be a non-empty list of node indices.\")\n                if not isinstance(latency, (int, float)) or latency < 0:\n                     errors.append(f\"Latency must be a non-negative number.\")\n                if hub not in cognitive_processing_hubs:\n                    errors.append(f\"Node {idx+1} is assigned to hub {hub}, which is not in the selected cognitive processing hubs list.\")\n                if pathway[0] != idx+1 or pathway[-1] != hub:\n                    errors.append(f\"Pathway for node {idx+1} must start at {idx+1} and end at hub {hub}.\")\n\n        INF = float('inf')\n        dist = [[INF] * network_node_count for _ in range(network_node_count)]\n        for i in range(network_node_count):\n            dist[i][i] = 0\n\n        for pathway in neural_transmission_pathways:\n            u = pathway[0] - 1\n            v = pathway[1] - 1\n            latency = pathway[2]\n            dist[u][v] = min(dist[u][v], latency)\n            dist[v][u] = min(dist[v][u], latency)\n\n        for k in range(network_node_count):\n            for i in range(network_node_count):\n                for j in range(network_node_count):\n                    if dist[i][k] + dist[k][j] < dist[i][j]:\n                        dist[i][j] = dist[i][k] + dist[k][j]\n        \n        calc_latency = 0\n        if not any(\"assignment\" in e or \"hub\" in e or \"pathway\" in e for e in errors):\n            try:\n                for idx, assignment in enumerate(neural_connectivity_assignments):\n                    i = idx  # 0-based index for current node\n                    j = assignment[0] - 1  # hub index (convert to 0-based)\n                    declared_latency = assignment[2]\n                    actual_latency = dist[i][j]\n                    \n                    if abs(declared_latency - actual_latency) > 1e-6:\n                        errors.append(f\"Latency mismatch for node {idx+1}: declared {declared_latency}, actual {actual_latency}\")\n                    \n                    calc_latency += actual_latency\n                \n                if abs(calc_latency - total_computational_latency) > 1e-6:\n                    errors.append(f\"Total computational latency inconsistency: calculated {calc_latency}, declared {total_computational_latency}\")\n            except (IndexError, KeyError, TypeError):\n                pass\n\n        is_valid = (len(errors) == 0)\n        \n        if is_valid:\n            try:\n                optimal_value = reference_solution[\"total_computational_latency\"]\n                candidate_value = total_computational_latency\n                \n                if optimal_value == 0:\n                    optimality_score = 1.0 if candidate_value == 0 else 0.0\n                else:\n                    gap = abs(optimal_value - candidate_value) / abs(optimal_value)\n                    optimality_score = max(0, 1 - gap)\n            except (KeyError, TypeError, ZeroDivisionError):\n                optimality_score = 0.0\n        \n        return {\n            \"is_valid\": is_valid,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n\n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}