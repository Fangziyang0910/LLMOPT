{
  "problem_id": "set_covering_001",
  "metadata": {
    "problem_type": "Set Covering Problem",
    "difficulty": "simple"
  },
  "problem_description": "A sophisticated multi-layered operational architecture governs an urban security surveillance infrastructure management system, presenting intricate deployment requirements that necessitate the strategic placement of monitoring equipment across a metropolitan security grid encompassing 10 designated surveillance zones. The operational framework encompasses 20 potential installation positions, each characterized by uniform installation expenses of 1 thousand dollars and distinctive location_coverage matrices that delineate their surveillance capabilities. The spatial coverage topology exhibits the following configuration: Position 1 extends location_coverage to zones 1,7,10; Position 2 extends location_coverage to zones 1,2,3,4,5,7; Position 3 extends location_coverage to zones 3,6,7,8,10; Position 4 extends location_coverage to zones 1,3,4,7,8,10; Position 5 extends location_coverage to zones 4,5,8,9,10; Position 6 extends location_coverage to zones 4,5; Position 7 extends location_coverage to zones 1,3,6,7; Position 8 extends location_coverage to zones 1,3,7; Position 9 extends location_coverage to zones 3,10; Position 10 extends location_coverage to zones 1,2,8; Position 11 extends location_coverage to zones 1,3,8; Position 12 extends location_coverage to zones 7,8,9; Position 13 extends location_coverage to zones 1,2,3,5,8; Position 14 extends location_coverage to zones 1,5,10; Position 15 extends location_coverage to zones 6,7,9; Position 16 extends location_coverage to zones 1,5,6,9; Position 17 extends location_coverage to zones 1,3,7,10; Position 18 extends location_coverage to zones 3,6,7,9; Position 19 extends location_coverage to zones 2,4,7,9,10; Position 20 extends location_coverage to zones 2,8,9. The coverage optimization paradigm mandates that each surveillance zone must be encompassed within the location_coverage of at least one selected installation position. Each installation position can either be activated for deployment or remain unutilized, with fractional deployment configurations being prohibited. System planners must determine which installation positions to select to ensure complete area coverage while keeping total installation_costs to a minimum.",
  "solution_format_description": "Print the following fields: - selected_locations: chosen installation locations. - total_installation_cost: total cost of selected locations.",
  "structured_data": {
    "num_areas": 10,
    "num_locations": 20,
    "installation_costs": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    "location_coverage": [[1, 7, 10], [1, 2, 3, 4, 5, 7], [3, 6, 7, 8, 10], [1, 3, 4, 7, 8, 10], [4, 5, 8, 9, 10], [4, 5], [1, 3, 6, 7], [1, 3, 7], [3, 10], [1, 2, 8], [1, 3, 8], [7, 8, 9], [1, 2, 3, 5, 8], [1, 5, 10], [6, 7, 9], [1, 5, 6, 9], [1, 3, 7, 10], [3, 6, 7, 9], [2, 4, 7, 9, 10], [2, 8, 9]]
  },
  "reference_solution": {
    "selected_locations": [2, 3, 5],
    "total_installation_cost": 3
  },
  "solver_code": "from cpmpy import *\nimport json\n\n\nnum_areas = 10\nnum_locations = 20\ninstallation_costs = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\nlocation_coverage = [\n    [1, 7, 10], [1, 2, 3, 4, 5, 7], [3, 6, 7, 8, 10], [1, 3, 4, 7, 8, 10],\n    [4, 5, 8, 9, 10], [4, 5], [1, 3, 6, 7], [1, 3, 7], [3, 10], [1, 2, 8],\n    [1, 3, 8], [7, 8, 9], [1, 2, 3, 5, 8], [1, 5, 10], [6, 7, 9], [1, 5, 6, 9],\n    [1, 3, 7, 10], [3, 6, 7, 9], [2, 4, 7, 9, 10], [2, 8, 9]\n]\n\n\nmodel = Model()\n\n\nx = boolvar(shape=num_locations)\n\n\nfor area in range(1, num_areas + 1):\n\n    covering_locations = [j for j in range(num_locations) if area in location_coverage[j]]\n    model += sum(x[j] for j in covering_locations) >= 1\n\n\nmodel.minimize(sum(installation_costs[j] * x[j] for j in range(num_locations)))\n\n\nif model.solve():\n    selected_locations = [j+1 for j in range(num_locations) if x[j].value()]\n    total_installation_cost = sum(installation_costs[j] for j in range(num_locations) if x[j].value())\n    \n    result = {\n        \"selected_locations\": selected_locations,\n        \"total_installation_cost\": total_installation_cost\n    }\n    print(json.dumps(result))\nelse:\n    print(\"No solution found\")",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n\n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n\n    required_fields = [\"selected_locations\", \"total_installation_cost\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n\n    try:\n        selected_locations = solution[\"selected_locations\"]\n        total_installation_cost = solution[\"total_installation_cost\"]\n        \n        num_areas = structured_data[\"num_areas\"]\n        num_locations = structured_data[\"num_locations\"]\n        installation_costs = structured_data[\"installation_costs\"]\n        location_coverage = structured_data[\"location_coverage\"]\n        \n        errors = []\n        \n\n        for loc in selected_locations:\n            if not isinstance(loc, int) or loc < 1 or loc > num_locations:\n                errors.append(f\"Location {loc} is out of bounds (should be between 1 and {num_locations})\")\n        \n\n        if len(selected_locations) != len(set(selected_locations)):\n            errors.append(\"Duplicate locations in selected_locations\")\n        \n\n        try:\n            calc_cost = sum(installation_costs[loc - 1] for loc in selected_locations if 1 <= loc <= num_locations)\n            if abs(calc_cost - total_installation_cost) > 1e-6:\n                errors.append(f\"Cost inconsistency: calculated {calc_cost}, declared {total_installation_cost}\")\n        except (IndexError, TypeError):\n            errors.append(\"Error calculating installation cost\")\n        \n\n        uncovered_areas = []\n        for area in range(1, num_areas + 1):\n\n            covering_locations = [j+1 for j in range(num_locations) if area in location_coverage[j]]\n            if not set(covering_locations).intersection(set(selected_locations)):\n                uncovered_areas.append(area)\n        \n        if uncovered_areas:\n            errors.append(f\"Coverage constraint violated: areas {uncovered_areas[:10]} are not covered\")\n        \n\n        optimal_cost = reference_solution[\"total_installation_cost\"]\n        if optimal_cost == 0:\n            optimality_score = 1.0 if total_installation_cost == 0 else 0.0\n        else:\n            gap = abs(optimal_cost - total_installation_cost) / abs(optimal_cost)\n            optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}