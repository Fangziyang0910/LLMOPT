{
  "problem_id": "pmed_uncap_001",
  "metadata": {
    "problem_type": "Uncapacitated P-Median Problem",
    "difficulty": "simple"
  },
  "problem_description": "An advanced quantum communication infrastructure optimization framework requires strategic deployment of two entanglement synchronization nodes across a five-point topological network to establish optimal information propagation pathways that minimize cumulative quantum decoherence expenditure while adhering to strict non-locality constraints and quantum coherence preservation protocols. The network topology employs a sophisticated quantum state transfer matrix where each connection represents a bidirectional quantum tunnel with associated decoherence resistance coefficients. The objective is to identify optimal node placement configurations that minimize the aggregate quantum information loss across all network segments while maintaining entanglement fidelity above established threshold parameters. Quantum connection characteristics and decoherence coefficients include: Quantum pathway Alpha connecting node one and node two exhibits decoherence coefficient ten; pathway Beta linking node one and node three demonstrates coefficient five; pathway Gamma connecting node one and node four shows coefficient seven; pathway Delta linking node one and node five reveals coefficient eight; pathway Epsilon connecting node two and node three exhibits coefficient two; pathway Zeta linking node two and node four demonstrates coefficient one; pathway Eta connecting node two and node five shows coefficient six; pathway Theta linking node three and node four exhibits coefficient nine; pathway Iota connecting node three and node five demonstrates coefficient two; and pathway Kappa linking node four and node five reveals coefficient four. Each network node must be quantum-entangled with exactly one synchronization node, and the quantum information transfer cost from any node to its assigned synchronization node represents the minimum achievable decoherence expenditure through available quantum tunneling pathways utilizing optimal state transfer protocols.",
  "solution_format_description": "Print the following fields: - synchronization_nodes: selected facility locations. - total_decoherence_expenditure: total distance cost. - quantum_entanglement_assignments: for each node, list assignment with facility, pathway, cost.",
  "structured_data": {
    "network_node_count": 5,
    "synchronization_node_count": 2,
    "quantum_tunneling_pathways": [
      [1, 2, 10],
      [1, 3, 5],
      [2, 3, 2],
      [2, 4, 1],
      [3, 4, 9],
      [3, 5, 2],
      [4, 5, 4],
      [1, 4, 7],
      [1, 5, 8],
      [2, 5, 6],
      [3, 1, 5],
      [4, 2, 1]
    ]
  },
  "reference_solution": {
    "synchronization_nodes": [1, 2],
    "total_decoherence_expenditure": 7,
    "quantum_entanglement_assignments": [
      [1, [1], 0],
      [2, [2], 0],
      [2, [3, 2], 2],
      [2, [4, 2], 1],
      [2, [5, 3, 2], 4]
    ]
  },
  "solver_code": "from cpmpy import *\nimport json\n\nnetwork_node_count = 5\nsynchronization_node_count = 2\nquantum_tunneling_pathways = [\n    [1, 2, 10],\n    [1, 3, 5],\n    [2, 3, 2],\n    [2, 4, 1],\n    [3, 4, 9],\n    [3, 5, 2],\n    [4, 5, 4],\n    [1, 4, 7],\n    [1, 5, 8],\n    [2, 5, 6],\n    [3, 1, 5],\n    [4, 2, 1]\n]\n\nINF = float('inf')\ndist = [[INF] * network_node_count for _ in range(network_node_count)]\nnext_node = [[-1] * network_node_count for _ in range(network_node_count)]\n\nfor i in range(network_node_count):\n    dist[i][i] = 0\n    for j in range(network_node_count):\n        if i == j:\n            next_node[i][j] = j\n\nfor pathway in quantum_tunneling_pathways:\n    i = pathway[0] - 1\n    j = pathway[1] - 1\n    decoherence_coefficient = pathway[2]\n    if decoherence_coefficient < dist[i][j]:\n        dist[i][j] = decoherence_coefficient\n        dist[j][i] = decoherence_coefficient\n        next_node[i][j] = j\n        next_node[j][i] = i\n\nfor k in range(network_node_count):\n    for i in range(network_node_count):\n        for j in range(network_node_count):\n            if dist[i][k] + dist[k][j] < dist[i][j]:\n                dist[i][j] = dist[i][k] + dist[k][j]\n                next_node[i][j] = next_node[i][k]\n\ndef get_quantum_pathway(i, j):\n    if dist[i][j] == INF:\n        return []\n    pathway = [i]\n    while i != j:\n        i = next_node[i][j]\n        pathway.append(i)\n    return pathway\n\nsynchronization_node = boolvar(shape=network_node_count)\nassign = intvar(shape=(network_node_count, network_node_count), lb=0, ub=1)\n\nmodel = Model()\n\nmodel += sum(synchronization_node) == synchronization_node_count\n\nfor i in range(network_node_count):\n    model += sum(assign[i][j] for j in range(network_node_count)) == 1\n\nfor i in range(network_node_count):\n    for j in range(network_node_count):\n        model += assign[i][j] <= synchronization_node[j]\n\ntotal_decoherence_expenditure = sum(dist[i][j] * assign[i][j] for i in range(network_node_count) for j in range(network_node_count))\nmodel.minimize(total_decoherence_expenditure)\n\nif model.solve():\n    selected_synchronization_nodes = [i+1 for i in range(network_node_count) if synchronization_node[i].value()]\n    \n    quantum_entanglement_assignments = []\n    for i in range(network_node_count):\n        for j in range(network_node_count):\n            if assign[i][j].value():\n                pathway = get_quantum_pathway(i, j)\n                pathway_1_indexed = [node+1 for node in pathway]\n                decoherence_cost = dist[i][j]\n                quantum_entanglement_assignments.append([j+1, pathway_1_indexed, decoherence_cost])\n    \n    result = {\n        \"synchronization_nodes\": selected_synchronization_nodes,\n        \"total_decoherence_expenditure\": total_decoherence_expenditure.value(),\n        \"quantum_entanglement_assignments\": quantum_entanglement_assignments\n    }\n    print(json.dumps(result))\nelse:\n    print(\"No solution found\")",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"synchronization_nodes\", \"total_decoherence_expenditure\", \"quantum_entanglement_assignments\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        synchronization_nodes = solution[\"synchronization_nodes\"]\n        total_decoherence_expenditure = solution[\"total_decoherence_expenditure\"]\n        quantum_entanglement_assignments = solution[\"quantum_entanglement_assignments\"]\n        network_node_count = structured_data[\"network_node_count\"]\n        synchronization_node_count = structured_data[\"synchronization_node_count\"]\n        quantum_tunneling_pathways = structured_data[\"quantum_tunneling_pathways\"]\n        errors = []\n        \n        if not isinstance(synchronization_nodes, list) or len(synchronization_nodes) != synchronization_node_count:\n            errors.append(f\"Synchronization nodes must be a list of exactly {synchronization_node_count} integers\")\n        \n        if not isinstance(total_decoherence_expenditure, (int, float)) or total_decoherence_expenditure < 0:\n            errors.append(\"Total decoherence expenditure must be a non-negative number\")\n        \n        if not isinstance(quantum_entanglement_assignments, list) or len(quantum_entanglement_assignments) != network_node_count:\n            errors.append(f\"Quantum entanglement assignments must be a list of exactly {network_node_count} arrays\")\n        \n        for node in synchronization_nodes:\n            if not isinstance(node, int) or node < 1 or node > network_node_count:\n                errors.append(f\"Synchronization node {node} is not a valid network node (must be between 1 and {network_node_count})\")\n        \n        if len(set(synchronization_nodes)) != len(synchronization_nodes):\n            errors.append(\"Synchronization nodes must be distinct\")\n        \n        for i, assignment in enumerate(quantum_entanglement_assignments):\n            if not isinstance(assignment, list) or len(assignment) != 3:\n                errors.append(f\"Quantum entanglement assignment {i+1} must be an array of [synchronization_node, quantum_pathway, decoherence_cost]\")\n                continue\n            \n            synchronization_node = assignment[0]\n            quantum_pathway = assignment[1]\n            decoherence_cost = assignment[2]\n            \n            if synchronization_node not in synchronization_nodes:\n                errors.append(f\"Quantum entanglement assignment {i+1} assigns to synchronization node {synchronization_node} which is not in selected nodes\")\n            \n            if not isinstance(quantum_pathway, list) or len(quantum_pathway) < 1:\n                errors.append(f\"Quantum entanglement assignment {i+1} pathway must be a non-empty list\")\n            \n            if quantum_pathway[0] != i+1 or quantum_pathway[-1] != synchronization_node:\n                errors.append(f\"Quantum entanglement assignment {i+1} pathway must start at network node {i+1} and end at synchronization node {synchronization_node}\")\n            \n            if not isinstance(decoherence_cost, (int, float)) or decoherence_cost < 0:\n                errors.append(f\"Quantum entanglement assignment {i+1} decoherence cost must be a non-negative number\")\n        \n        if errors:\n            return {\n                \"is_valid\": False,\n                \"validation_errors\": errors,\n                \"optimality_score\": 0.0\n            }\n        \n        INF = float('inf')\n        dist = [[INF] * network_node_count for _ in range(network_node_count)]\n        \n        for i in range(network_node_count):\n            dist[i][i] = 0\n        \n        for pathway in quantum_tunneling_pathways:\n            i = pathway[0] - 1\n            j = pathway[1] - 1\n            decoherence_coefficient = pathway[2]\n            dist[i][j] = min(dist[i][j], decoherence_coefficient)\n            dist[j][i] = min(dist[j][i], decoherence_coefficient)\n        \n        for k in range(network_node_count):\n            for i in range(network_node_count):\n                for j in range(network_node_count):\n                    if dist[i][k] + dist[k][j] < dist[i][j]:\n                        dist[i][j] = dist[i][k] + dist[k][j]\n        \n        calculated_total_decoherence_expenditure = 0\n        for i, assignment in enumerate(quantum_entanglement_assignments):\n            synchronization_node = assignment[0] - 1\n            declared_decoherence_cost = assignment[2]\n            actual_decoherence_cost = dist[i][synchronization_node]\n            \n            if abs(declared_decoherence_cost - actual_decoherence_cost) > 1e-6:\n                errors.append(f\"Decoherence cost mismatch for network node {i+1}: declared {declared_decoherence_cost}, actual {actual_decoherence_cost}\")\n            \n            calculated_total_decoherence_expenditure += actual_decoherence_cost\n        \n        if abs(calculated_total_decoherence_expenditure - total_decoherence_expenditure) > 1e-6:\n            errors.append(f\"Total decoherence expenditure mismatch: declared {total_decoherence_expenditure}, calculated {calculated_total_decoherence_expenditure}\")\n        \n        if errors:\n            return {\n                \"is_valid\": False,\n                \"validation_errors\": errors,\n                \"optimality_score\": 0.0\n            }\n        \n        optimal_cost = reference_solution[\"total_decoherence_expenditure\"]\n        if optimal_cost == 0:\n            optimality_score = 1.0 if total_decoherence_expenditure == 0 else 0.0\n        else:\n            gap = abs(optimal_cost - total_decoherence_expenditure) / abs(optimal_cost)\n            optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": True,\n            \"validation_errors\": [],\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}