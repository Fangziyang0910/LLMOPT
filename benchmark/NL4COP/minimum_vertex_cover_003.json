{
  "problem_id": "minimum_vertex_cover_003",
  "metadata": {
    "problem_type": "Minimum Vertex Cover Problem",
    "difficulty": "hard"
  },
  "problem_description": "A university's karate club has experienced a conflict between the instructor and the club president, resulting in the club splitting into two factions. The club administrator needs to identify the smallest group of key members who can mediate and monitor all social interactions within the club to prevent further conflicts. The club has 34 members with friendship relationships as follows: member 0 is friends with members 1 through 33; member 1 is friends with members 2, 3, 4, 8, 13, 17, 18, 20, 22, and 31; member 2 is friends with members 3, 8, 9, 13, 27, 28, 32, and 33; member 3 is friends with members 7, 12, and 13; member 4 is friends with members 6 and 10; member 5 is friends with members 6, 10, and 16; member 6 is friends with member 16; member 7 is friends with member 8; member 8 is friends with members 32 and 33; member 9 is friends with member 33; member 13 is friends with member 33; member 14 is friends with members 32 and 33; member 15 is friends with members 32 and 33; member 18 is friends with members 32 and 33; member 19 is friends with members 32 and 33; member 20 is friends with members 32 and 33; member 21 is friends with members 32 and 33; member 22 is friends with members 32 and 33; member 23 is friends with members 25, 27, 29, 32, and 33; member 24 is friends with members 25, 27, and 31; member 25 is friends with member 31; member 26 is friends with members 29 and 33; member 27 is friends with member 33; member 28 is friends with members 31 and 33; member 29 is friends with members 32 and 33; member 30 is friends with members 32 and 33; member 31 is friends with members 32 and 33; member 32 is friends with member 33. When a member is selected as a mediator, they can help oversee all their friendships. To ensure no conflicts go unnoticed, every friendship between two members should have at least one of them serving as a mediator. The administrator needs to determine which members should be selected as mediators to ensure complete coverage while using as few mediators as possible.",
  "solution_format_description": "Print the following fields: - selected_vertices: members selected as mediators. - num_vertices_selected: total number of selected members.",
  "structured_data": {
    "num_vertices": 34,
    "edges": [
      [0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [0, 7], [0, 8], [0, 9], [0, 10],
      [0, 11], [0, 12], [0, 13], [0, 14], [0, 15], [0, 16], [0, 17], [0, 18], [0, 19], [0, 20],
      [0, 21], [0, 22], [0, 23], [0, 24], [0, 25], [0, 26], [0, 27], [0, 28], [0, 29], [0, 30],
      [0, 31], [0, 32], [0, 33], [1, 2], [1, 3], [1, 4], [1, 8], [1, 13], [1, 17], [1, 18], [1, 20],
      [1, 22], [1, 31], [2, 3], [2, 8], [2, 9], [2, 13], [2, 27], [2, 28], [2, 32], [2, 33],
      [3, 7], [3, 12], [3, 13], [4, 6], [4, 10], [5, 6], [5, 10], [5, 16], [6, 16], [7, 8],
      [8, 32], [8, 33], [9, 33], [13, 33], [14, 32], [14, 33], [15, 32], [15, 33], [18, 32], [18, 33],
      [19, 32], [19, 33], [20, 32], [20, 33], [21, 32], [21, 33], [22, 32], [22, 33], [23, 25], [23, 27],
      [23, 29], [23, 32], [23, 33], [24, 25], [24, 27], [24, 31], [25, 31], [26, 29], [26, 33], [27, 33],
      [28, 31], [28, 33], [29, 32], [29, 33], [30, 32], [30, 33], [31, 32], [31, 33], [32, 33]
    ]
  },
  "reference_solution": {
    "selected_vertices": [0, 1, 2, 3, 5, 6, 8, 10, 25, 27, 29, 31, 32, 33],
    "num_vertices_selected": 14
  },
  "solver_code": "from cpmpy import *\nimport json\n\nnum_vertices = 34\nedges = [\n    [0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [0, 7], [0, 8], [0, 9], [0, 10],\n    [0, 11], [0, 12], [0, 13], [0, 14], [0, 15], [0, 16], [0, 17], [0, 18], [0, 19], [0, 20],\n    [0, 21], [0, 22], [0, 23], [0, 24], [0, 25], [0, 26], [0, 27], [0, 28], [0, 29], [0, 30],\n    [0, 31], [0, 32], [0, 33], [1, 2], [1, 3], [1, 4], [1, 8], [1, 13], [1, 17], [1, 18], [1, 20],\n    [1, 22], [1, 31], [2, 3], [2, 8], [2, 9], [2, 13], [2, 27], [2, 28], [2, 32], [2, 33],\n    [3, 7], [3, 12], [3, 13], [4, 6], [4, 10], [5, 6], [5, 10], [5, 16], [6, 16], [7, 8],\n    [8, 32], [8, 33], [9, 33], [13, 33], [14, 32], [14, 33], [15, 32], [15, 33], [18, 32], [18, 33],\n    [19, 32], [19, 33], [20, 32], [20, 33], [21, 32], [21, 33], [22, 32], [22, 33], [23, 25], [23, 27],\n    [23, 29], [23, 32], [23, 33], [24, 25], [24, 27], [24, 31], [25, 31], [26, 29], [26, 33], [27, 33],\n    [28, 31], [28, 33], [29, 32], [29, 33], [30, 32], [30, 33], [31, 32], [31, 33], [32, 33]\n]\n\nmodel = Model()\nx = boolvar(shape=num_vertices)\n\nfor edge in edges:\n    u, v = edge\n    model += x[u] + x[v] >= 1\n\nmodel.minimize(sum(x))\n\nif model.solve():\n    selected_vertices = [i for i in range(num_vertices) if x[i].value() == 1]\n    num_vertices_selected = len(selected_vertices)\n    \n    result = {\n        \"selected_vertices\": selected_vertices,\n        \"num_vertices_selected\": num_vertices_selected\n    }\n    \n    print(json.dumps(result))\nelse:\n    print(\"No solution found\")",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"selected_vertices\", \"num_vertices_selected\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        selected = solution[\"selected_vertices\"]\n        num_vertices_selected = solution[\"num_vertices_selected\"]\n        edges = structured_data[\"edges\"]\n        num_vertices = structured_data[\"num_vertices\"]\n        errors = []\n        \n        if not isinstance(selected, list):\n            errors.append(\"selected_vertices must be an array\")\n        \n        if len(selected) != num_vertices_selected:\n            errors.append(f\"Array length mismatch: expected {num_vertices_selected}, got {len(selected)}\")\n        \n        for idx in selected:\n            if not isinstance(idx, int) or idx < 0 or idx >= num_vertices:\n                errors.append(f\"Invalid vertex index: {idx}\")\n        \n        uncovered_edges = []\n        for i, edge in enumerate(edges):\n            u, v = edge\n            if u not in selected and v not in selected:\n                uncovered_edges.append(edge)\n        \n        if uncovered_edges:\n            errors.append(f\"Uncovered edges: {uncovered_edges}\")\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_vertices = reference_solution[\"num_vertices_selected\"]\n            if optimal_vertices == 0:\n                optimality_score = 1.0 if num_vertices_selected == 0 else 0.0\n            else:\n                gap = abs(optimal_vertices - num_vertices_selected) / abs(optimal_vertices)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}