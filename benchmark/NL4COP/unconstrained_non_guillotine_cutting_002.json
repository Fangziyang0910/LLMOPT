{
  "problem_id": "unconstrained_non_guillotine_cutting_002",
  "metadata": {
    "problem_type": "Unconstrained Non-Guillotine Cutting Problem",
    "difficulty": "medium"
  },
  "problem_description": "A specialized industrial manufacturing facility is addressing a complex spatial configuration optimization challenge involving non-sequential component arrangement on a rectangular workspace measuring 30 by 20 centimeters. This non-guillotine cutting methodology enables components to be positioned freely throughout the workspace without adherence to any predetermined cutting trajectory or sequential arrangement protocol. The manufacturing inventory encompasses eight distinct material categories: Category 1 components with length 8 centimeters and width 6 centimeters, valuation of 48 hundred dollars, and maximum allowable quantity of 2 pieces; Category 2 components with length 7 centimeters and width 5 centimeters, valuation of 35 hundred dollars, and maximum allowable quantity of 2 pieces; Category 3 components with length 6 centimeters and width 4 centimeters, valuation of 24 hundred dollars, and maximum allowable quantity of 2 pieces; Category 4 components with length 5 centimeters and width 5 centimeters, valuation of 25 hundred dollars, and maximum allowable quantity of 2 pieces; Category 5 components with length 9 centimeters and width 3 centimeters, valuation of 27 hundred dollars, and maximum allowable quantity of 2 pieces; Category 6 components with length 4 centimeters and width 7 centimeters, valuation of 28 hundred dollars, and maximum allowable quantity of 1 piece; Category 7 components with length 10 centimeters and width 4 centimeters, valuation of 40 hundred dollars, and maximum allowable quantity of 1 piece; Category 8 components with length 3 centimeters and width 8 centimeters, valuation of 24 hundred dollars, and maximum allowable quantity of 1 piece. Each component permits 90-degree rotational adjustment and can be positioned at any coordinate within the workspace boundaries, provided that spatial overlapping is avoided and complete containment within the perimeter is maintained. Manufacturing engineers must determine how to arrange the components to achieve maximum total value, with no constraints on placement order or cutting sequence.",
  "solution_format_description": "Print the following fields: - placements: for each piece, list placement with type, x, y, rotation. - total_value: total value of placed pieces.",  
  "structured_data": {
    "table_dimensions": [30, 20],
    "material_types": [
      [8, 6, 48, 2], 
      [7, 5, 35, 2], 
      [6, 4, 24, 2], 
      [5, 5, 25, 2], 
      [9, 3, 27, 2], 
      [4, 7, 28, 1], 
      [10, 4, 40, 1], 
      [3, 8, 24, 1]
    ]
  },
  "reference_solution": {
    "placements": [
      [0, 0, 0, 0], 
      [0, 16, 14, 0], 
      [1, 24, 12, 1], 
      [1, 24, 0, 1], 
      [2, 18, 10, 0], 
      [2, 15, 0, 1], 
      [3, 8, 0, 1], 
      [3, 25, 7, 1], 
      [4, 9, 10, 0], 
      [4, 7, 17, 0], 
      [5, 5, 6, 0], 
      [6, 6, 13, 0], 
      [7, 17, 7, 1]
    ],
    "total_value": 410
  },
  "solver_code": "from cpmpy import *\nimport json\n\ntable_dimensions = [30, 20]\nmaterial_types = [[8, 6, 48, 2], [7, 5, 35, 2], [6, 4, 24, 2], [5, 5, 25, 2], [9, 3, 27, 2], [4, 7, 28, 1], [10, 4, 40, 1], [3, 8, 24, 1]]\nallow_rotation = 1\n\nplacements = []\nfor material_type_idx in range(len(material_types)):\n    for idx in range(material_types[material_type_idx][3]):\n        used = boolvar(name=f\"used_{material_type_idx}_{idx}\")\n        x = intvar(0, table_dimensions[0], name=f\"x_{material_type_idx}_{idx}\")\n        y = intvar(0, table_dimensions[1], name=f\"y_{material_type_idx}_{idx}\")\n        orientation = boolvar(name=f\"orientation_{material_type_idx}_{idx}\")\n        placements.append((material_type_idx, idx, used, x, y, orientation))\n\nmodel = Model()\n\nfor material_type_idx, idx, used, x, y, orientation in placements:\n    width, height, value, max_pieces = material_types[material_type_idx]\n    \n    if allow_rotation and width != height:\n        orig_fits = (orientation == 0) & (x + width <= table_dimensions[0]) & (y + height <= table_dimensions[1])\n        rot_fits = (orientation == 1) & (x + height <= table_dimensions[0]) & (y + width <= table_dimensions[1])\n        model += used.implies(orig_fits | rot_fits)\n    else:\n        model += used.implies((x + width <= table_dimensions[0]) & (y + height <= table_dimensions[1]))\n        if not allow_rotation:\n            model += used.implies(orientation == 0)\n\nfor i in range(len(placements)):\n    for j in range(i + 1, len(placements)):\n        mt1, idx1, used1, x1, y1, orient1 = placements[i]\n        mt2, idx2, used2, x2, y2, orient2 = placements[j]\n        \n        w1, h1, v1, max1 = material_types[mt1]\n        w2, h2, v2, max2 = material_types[mt2]\n        \n        width1 = w1 * (1 - orient1) + h1 * orient1\n        height1 = h1 * (1 - orient1) + w1 * orient1\n        width2 = w2 * (1 - orient2) + h2 * orient2\n        height2 = h2 * (1 - orient2) + w2 * orient2\n        \n        no_overlap = (x1 + width1 <= x2) | (x2 + width2 <= x1) | (y1 + height1 <= y2) | (y2 + height2 <= y1)\n        model += (used1 & used2).implies(no_overlap)\n\nmaterial_type_counts = []\nfor material_type_idx in range(len(material_types)):\n    material_type_counts.append([])\n    \nfor material_type_idx, idx, used, x, y, orientation in placements:\n    material_type_counts[material_type_idx].append(used)\n    \nfor material_type_idx in range(len(material_types)):\n    used_count = sum(material_type_counts[material_type_idx])\n    model += used_count <= material_types[material_type_idx][3]\n\ntotal_value_expr = 0\nfor material_type_idx, idx, used, x, y, orientation in placements:\n    total_value_expr += used * material_types[material_type_idx][2]\n\nmodel.maximize(total_value_expr)\n\nif model.solve():\n    result = {\"placements\": [], \"total_value\": 0}\n    \n    for material_type_idx, idx, used, x, y, orientation in placements:\n        if used.value():\n            width, height, value, max_pieces = material_types[material_type_idx]\n            if orientation.value() == 0:\n                actual_width, actual_height = width, height\n            else:\n                actual_width, actual_height = height, width\n            \n            result[\"placements\"].append([material_type_idx, x.value(), y.value(), int(orientation.value())])\n            result[\"total_value\"] += value\n    \n    print(json.dumps(result))\nelse:\n    print(json.dumps({\"placements\": [], \"total_value\": 0}))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"placements\", \"total_value\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        placements = solution[\"placements\"]\n        total_value = solution[\"total_value\"]\n        table_dimensions = structured_data[\"table_dimensions\"]\n        material_types = structured_data[\"material_types\"]\n        allow_rotation = 1\n        \n        errors = []\n        \n        fabric_usage = [0] * len(material_types)\n        \n        for idx, placement in enumerate(placements):\n            if not isinstance(placement, list) or len(placement) != 4:\n                errors.append(f\"Placement {idx} must be an array with 4 elements [material_type, x, y, orientation]\")\n                continue\n            \n            material_type_idx = placement[0]\n            x = placement[1]\n            y = placement[2]\n            orientation = placement[3]\n            \n            if not isinstance(material_type_idx, int) or material_type_idx < 0 or material_type_idx >= len(material_types):\n                errors.append(f\"Placement {idx} has invalid material type index {material_type_idx}\")\n                continue\n            \n            if not all(isinstance(val, int) for val in [x, y]):\n                errors.append(f\"Placement {idx} has invalid coordinate values\")\n                continue\n            \n            if not isinstance(orientation, int) or orientation not in [0, 1]:\n                errors.append(f\"Placement {idx} has invalid orientation {orientation}\")\n                continue\n            \n            fabric_usage[material_type_idx] += 1\n            if fabric_usage[material_type_idx] > material_types[material_type_idx][3]:\n                errors.append(f\"Material type {material_type_idx} usage exceeds maximum available\")\n            \n            width, height, value, max_pieces = material_types[material_type_idx]\n            \n            if orientation == 0:\n                actual_width, actual_height = width, height\n            else:\n                if not allow_rotation:\n                    errors.append(f\"Placement {idx} uses rotation but rotation is not allowed\")\n                    continue\n                actual_width, actual_height = height, width\n            \n            if x < 0 or y < 0 or x + actual_width > table_dimensions[0] or y + actual_height > table_dimensions[1]:\n                errors.append(f\"Placement {idx} is out of table boundaries\")\n        \n        n = len(placements)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if i >= len(placements) or j >= len(placements):\n                    break\n                    \n                p1 = placements[i]\n                p2 = placements[j]\n                \n                x1, y1 = p1[1], p1[2]\n                x2, y2 = p2[1], p2[2]\n                ft1 = p1[0]\n                ft2 = p2[0]\n                \n                w1, h1, v1, max1 = material_types[ft1]\n                w2, h2, v2, max2 = material_types[ft2]\n                \n                width1 = w1 * (1 - p1[3]) + h1 * p1[3]\n                height1 = h1 * (1 - p1[3]) + w1 * p1[3]\n                width2 = w2 * (1 - p2[3]) + h2 * p2[3]\n                height2 = h2 * (1 - p2[3]) + w2 * p2[3]\n                \n                if not (x1 + width1 <= x2 or x2 + width2 <= x1 or y1 + height1 <= y2 or y2 + height2 <= y1):\n                    errors.append(f\"Placements {i} and {j} overlap\")\n        \n        calculated_value = 0\n        for placement in placements:\n            material_type_idx = placement[0]\n            calculated_value += material_types[material_type_idx][2]\n        \n        if abs(calculated_value - total_value) > 1e-6:\n            errors.append(f\"Total value inconsistency: calculated {calculated_value}, declared {total_value}\")\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_value = reference_solution[\"total_value\"]\n            if optimal_value == 0:\n                optimality_score = 1.0 if total_value == 0 else 0.0\n            else:\n                gap = abs(optimal_value - total_value) / abs(optimal_value)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}