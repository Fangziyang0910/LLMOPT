{
  "problem_id": "hybrid_reentrant_shop_scheduling_001",
  "metadata": {
    "problem_type": "Hybrid Reentrant Shop Scheduling Problem",
    "difficulty": "simple"
  },
  "problem_description": "A small automotive repair shop operates with two identical service bays and must complete a comprehensive three-phase service protocol for five vehicles that have arrived for specialized restoration work. Each vehicle must traverse a meticulously structured service sequence encompassing initial diagnostic assessment, followed by specialized computerized system reprogramming at a single dedicated diagnostic terminal, and culminating with final mechanical restoration on the same service bay where the initial diagnostic was originally performed. The service protocol stipulates that each vehicle undergo preliminary diagnostic evaluation requiring precisely 1 hour at whichever service bay becomes available first, with the assignment of vehicles to service bays determined through sequential arrival-based scheduling. Upon completion of initial diagnostics, each vehicle must be relocated to the exclusive diagnostic terminal for computerized system reprogramming, where the processing duration exhibits vehicle-specific variability: the first vehicle requires 15 hours for system reprogramming, the second vehicle necessitates 21 hours, the third vehicle demands 31 hours, the fourth vehicle requires 15 hours, and the fifth vehicle needs 32 hours. The diagnostic terminal maintains strict operational exclusivity, processing only one vehicle at any given moment, which necessitates careful consideration of the optimal processing sequence for all vehicles. Following the completion of computerized reprogramming, each vehicle must be returned to the identical service bay where its initial diagnostic assessment was conducted to undergo final mechanical restoration, with phase-specific processing requirements that vary by vehicle: the first vehicle requires 43 hours for mechanical restoration, the second vehicle needs 30 hours, the third vehicle demands 34 hours, the fourth vehicle requires 43 hours, and the fifth vehicle necessitates 45 hours. The service workflow follows essential operational principles where each service bay can handle only one vehicle at any given time, the diagnostic terminal works exclusively with one vehicle at a time, vehicles must finish each phase completely before moving to the next phase, each vehicle must return to the same service bay for final restoration where it received its initial diagnostics, and no overlapping work is allowed within any service bay during both diagnostic and restoration phases. The repair shop management aims to determine the best vehicle sequence for the diagnostic terminal and the most effective assignment of vehicles to service bays to minimize the total service completion time, which will maximize operational efficiency and reduce the time until the final vehicle finishes its mechanical restoration phase.",
  "solution_format_description": "Print the following fields: - diagnostic_terminal_sequence: processing order for vehicles at diagnostic terminal. - total_service_time: total time to complete all services.",
  "structured_data": {
    "num_vehicles": 5,
    "num_service_bays": 2,
    "initial_diagnostic_time": 1,
    "reprogramming_times": [15, 21, 31, 15, 32],
    "restoration_times": [43, 30, 34, 43, 45]
  },
  "reference_solution": {
    "diagnostic_terminal_sequence": [4, 5, 3, 1, 2],
    "total_service_time": 145
  },
  "solver_code": "from cpmpy import *\nimport json\n\nnum_vehicles = 5\nnum_service_bays = 2\ninitial_diagnostic_time = 1\nreprogramming_times = [15, 21, 31, 15, 32]\nrestoration_times = [43, 30, 34, 43, 45]\n\nhorizon = 314\n\nmodel = Model()\n\nassign = boolvar(shape=(num_vehicles, num_service_bays))\nvehicle_bay_assignment = intvar(1, num_service_bays, shape=num_vehicles)\ndiagnostic_terminal_sequence = intvar(1, num_vehicles, shape=num_vehicles)\n\ninitial_start = intvar(0, horizon - initial_diagnostic_time, shape=num_vehicles)\ninitial_end = intvar(0, horizon, shape=num_vehicles)\n\ndiagnostic_start = intvar(0, horizon, shape=num_vehicles)\ndiagnostic_end = intvar(0, horizon, shape=num_vehicles)\n\nfinal_start = intvar(0, horizon, shape=num_vehicles)\nfinal_end = intvar(0, horizon, shape=num_vehicles)\n\nmakespan = intvar(0, horizon)\n\nfor i in range(num_vehicles):\n    model += (sum(assign[i, :]) == 1)\n    model += (vehicle_bay_assignment[i] == sum([(s + 1) * assign[i, s] for s in range(num_service_bays)]))\n\nfor i in range(num_vehicles):\n    model += (initial_end[i] == initial_start[i] + initial_diagnostic_time)\n    model += (diagnostic_end[i] == diagnostic_start[i] + reprogramming_times[i])\n    model += (final_end[i] == final_start[i] + restoration_times[i])\n\nfor i in range(num_vehicles):\n    model += (initial_end[i] <= diagnostic_start[i])\n    model += (diagnostic_end[i] <= final_start[i])\n\nmodel += AllDifferent(diagnostic_terminal_sequence)\n\nfor p in range(num_vehicles - 1):\n    idx_prev = diagnostic_terminal_sequence[p] - 1\n    idx_next = diagnostic_terminal_sequence[p + 1] - 1\n    model += Element(diagnostic_start, idx_next) >= Element(diagnostic_end, idx_prev)\n\nfor s in range(num_service_bays):\n    for i in range(num_vehicles):\n        for j in range(i + 1, num_vehicles):\n            both_assigned = assign[i, s] & assign[j, s]\n            c1 = initial_end[i] <= initial_start[j]\n            c2 = initial_end[j] <= initial_start[i]\n            model += both_assigned.implies((c1) | (c2))\n            c3 = final_end[i] <= final_start[j]\n            c4 = final_end[j] <= final_start[i]\n            model += both_assigned.implies((c3) | (c4))\n\nfor i in range(num_vehicles):\n    for s in range(num_service_bays):\n        bay_match = (vehicle_bay_assignment[i] == s + 1)\n        model += bay_match.implies(final_start[i] >= diagnostic_end[i])\n\nmodel += makespan == max(final_end)\n\nmodel.minimize(makespan)\n\nif model.solve():\n    result = {\n        \"diagnostic_terminal_sequence\": [int(diagnostic_terminal_sequence[i].value()) for i in range(num_vehicles)],\n        \"total_service_time\": int(makespan.value())\n    }\n    print(json.dumps(result))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"diagnostic_terminal_sequence\", \"total_service_time\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        diagnostic_terminal_sequence = solution[\"diagnostic_terminal_sequence\"]\n        total_service_time = solution[\"total_service_time\"]\n        num_vehicles = structured_data[\"num_vehicles\"]\n        num_service_bays = structured_data[\"num_service_bays\"]\n        initial_diagnostic_time = structured_data[\"initial_diagnostic_time\"]\n        reprogramming_times = structured_data[\"reprogramming_times\"]\n        restoration_times = structured_data[\"restoration_times\"]\n        errors = []\n        \n        if len(diagnostic_terminal_sequence) != num_vehicles:\n            errors.append(f\"Sequence length mismatch: expected {num_vehicles}, got {len(diagnostic_terminal_sequence)}\")\n        \n        if sorted(diagnostic_terminal_sequence) != list(range(1, num_vehicles + 1)):\n            errors.append(\"Invalid permutation: sequence must contain all vehicles from 1 to n exactly once\")\n        \n        if total_service_time <= 0:\n            errors.append(\"Total service time must be positive\")\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_time = reference_solution[\"total_service_time\"]\n            if optimal_time == 0:\n                optimality_score = 1.0 if total_service_time == 0 else 0.0\n            else:\n                gap = abs(optimal_time - total_service_time) / abs(optimal_time)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}