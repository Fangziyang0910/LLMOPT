{
  "problem_id": "packing_unequal_circles_003",
  "metadata": {
    "problem_type": "Packing Unequal Circles",
    "difficulty": "hard"
  },
  "problem_description": "In a cutting-edge aerospace composite manufacturing facility, engineers are developing a next-generation satellite antenna array that requires precise spatial configuration of heterogeneous radio frequency (RF) resonator elements on a circular substrate platform with a precisely defined 65-centimeter effective operational radius, positioned at coordinates (65, 65) within a class-100 cleanroom environment. Fifteen distinct circular RF resonator variants must be strategically positioned, each possessing unique electromagnetic field characteristics: resonator 1 is a circular element with 12-centimeter radius for X-band frequency reception; resonator 2 is a circular element with 7-centimeter radius for Ku-band signal processing; resonator 3 is a circular element with 21-centimeter radius for Ka-band high-gain applications; resonator 4 is a circular element with 4-centimeter radius for S-band telemetry; resonator 5 is a circular element with 18-centimeter radius for C-band beamforming; resonator 6 is a circular element with 9-centimeter radius for L-band filtering; resonator 7 is a circular element with 25-centimeter radius for multi-band operation; resonator 8 is a circular element with 2-centimeter radius for ultra-high Q-factor applications; resonator 9 is a circular element with 15-centimeter radius for millimeter-wave communications; resonator 10 is a circular element with 6-centimeter radius for GPS signal reception; resonator 11 is a circular element with 23-centimeter radius for beam steering capabilities; resonator 12 is a circular element with 11-centimeter radius for high-frequency transmission; resonator 13 is a circular element with 19-centimeter radius for ultra-wideband functionality; resonator 14 is a circular element with 3-centimeter radius for terahertz sensing; and resonator 15 is a circular element with 16-centimeter radius for 6G communications. Every activated resonator element must be completely contained within the substrate boundaries and maintain adequate spatial separation to prevent electromagnetic interference coupling and preserve individual RF performance characteristics. The engineering team seeks to determine the optimal spatial configuration strategy to maximize the number of simultaneously operational resonator elements while maintaining the entire antenna array's electromagnetic coherence and system-level performance metrics.",
  "solution_format_description": "Print the following fields: - activated: activation status for each resonator. - positions: for each resonator, list coordinates with x, y. - num_activated: total number of activated resonators.",
  "structured_data": {
    "substrate_center": [65, 65],
    "substrate_radius": 65,
    "resonator_apertures": [12, 7, 21, 4, 18, 9, 25, 2, 15, 6, 23, 11, 19, 3, 16]
  },
  "reference_solution": {
    "activated": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    "positions": [[87, 17], [20, 29], [85, 104], [60, 98], [74, 66], [47, 63], [52, 29], [77, 46], [17, 51], [63, 88], [33, 92], [55, 118], [104, 43], [7, 72], [112, 78]],
    "num_activated": 15
  },
  "solver_code": "from cpmpy import *\nimport json\n\ncx, cy = 65, 65\nR = 65\nradii = [12,7,21,4,18,9,25,2,15,6,23,11,19,3,16]\nn = len(radii)\n\nalpha = boolvar(shape=n)\nx = intvar(-R, 2 * R, shape=n)\ny = intvar(-R, 2 * R, shape=n)\n\nmodel = Model()\n\nfor i in range(n):\n    model += (alpha[i] == 0).implies(x[i] == -R)\n    model += (alpha[i] == 0).implies(y[i] == -R)\n\nfor i in range(n):\n    r = radii[i]\n    if (R - r) < 0:\n        model += alpha[i] == 0\n    else:\n        rhs_sq = (R - r) ** 2\n        dist_sq = (x[i] - cx)**2 + (y[i] - cy)**2\n        model += alpha[i].implies(dist_sq <= rhs_sq)\n\nM = 4 * R * R\nfor i in range(n):\n    for j in range(i + 1, n):\n        r_i, r_j = radii[i], radii[j]\n        rhs_sq = (r_i + r_j) ** 2\n        dist_sq = (x[i] - x[j])**2 + (y[i] - y[j])**2\n        model += dist_sq >= rhs_sq - M * (2 - alpha[i] - alpha[j])\n\nmodel.maximize(sum(alpha))\n\nif model.solve():\n    activated = [int(alpha[i].value()) for i in range(n)]\n    positions = [(int(x[i].value()), int(y[i].value())) if activated[i] else (-1, -1) for i in range(n)]\n    num_activated = sum(activated)\n    \n    result = {\n        \"activated\": activated,\n        \"positions\": positions,\n        \"num_activated\": num_activated\n    }\n    print(json.dumps(result))\nelse:\n    print(\"No solution found.\")",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    import math\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"activated\", \"positions\", \"num_activated\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        activated = solution[\"activated\"]\n        positions = solution[\"positions\"]\n        num_activated = solution[\"num_activated\"]\n        errors = []\n        \n        cx, cy = structured_data[\"substrate_center\"]\n        container_R = structured_data[\"substrate_radius\"]\n        radii = structured_data[\"resonator_apertures\"]\n        n = len(radii)\n        \n        # 硬约束1: 容器边界约束\n        for i in range(n):\n            if activated[i] == 1:\n                x, y = positions[i]\n                r = radii[i]\n                dist = math.sqrt((x - cx)**2 + (y - cy)**2)\n                if dist > container_R - r:\n                    errors.append(f\"Resonator {i+1} exceeds substrate boundary\")\n        \n        # 硬约束2: 无重叠约束\n        for i in range(n):\n            if activated[i] == 1:\n                for j in range(i + 1, n):\n                    if activated[j] == 1:\n                        x1, y1 = positions[i]\n                        x2, y2 = positions[j]\n                        r1, r2 = radii[i], radii[j]\n                        dist = math.sqrt((x1 - x2)**2 + (y1 - y2)**2)\n                        if dist < r1 + r2:\n                            errors.append(f\"Resonators {i+1} and {j+1} overlap\")\n        \n        # 计算最优性得分\n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_value = reference_solution[\"num_activated\"]\n            if optimal_value == 0:\n                optimality_score = 1.0 if num_activated == 0 else 0.0\n            else:\n                gap = abs(optimal_value - num_activated) / abs(optimal_value)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}