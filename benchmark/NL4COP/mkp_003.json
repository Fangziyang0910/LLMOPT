{
  "problem_id": "mkp_003",
  "metadata": {
    "problem_type": "Multidimensional Knapsack Problem",
    "difficulty": "hard"
  },
  "problem_description": "In a quantum venture capital ecosystem, an investment matrix contains sixty quantum-resonant investment opportunities. Each opportunity has six measurable properties: economic return in quantum credit units (QCU), temporal resource allocation in development cycles, financial capital expenditure in investment units, equipment utilization in hardware resource units, specialized expertise requirements in expert hours, and computational load consumption in server capacity units. The investment matrix operates under five dimensional stability constraints: maximum temporal resource allocation of 280 development cycles, financial capital budget limit of 300 investment units, equipment utilization threshold of 250 hardware resource units, specialized expertise availability of 280 expert hours, and computational load capacity of 260 server capacity units. The investment opportunities have the following characteristics: 1. Quantum Algorithm Optimizer: return 85 QCU, cycles 17, capital 14, hardware 14, expertise 13, load 17; 2. Neural Network Synthesizer: return 98 QCU, cycles 17, capital 13, hardware 14, expertise 17, load 17; 3. Blockchain Protocol Implementation: return 15 QCU, cycles 19, capital 18, hardware 13, expertise 17, load 19; 4. AI Model Training: return 68 QCU, cycles 18, capital 15, hardware 16, expertise 17, load 17; 5. Cloud Infrastructure: return 13 QCU, cycles 13, capital 18, hardware 19, expertise 14, load 14; 6. Edge Computing Platform: return 93 QCU, cycles 18, capital 14, hardware 19, expertise 19, load 18; 7. Distributed Ledger System: return 100 QCU, cycles 17, capital 15, hardware 15, expertise 15, load 15; 8. Machine Learning Pipeline: return 59 QCU, cycles 19, capital 17, hardware 16, expertise 16, load 13; 9. Data Analytics Engine: return 52 QCU, cycles 15, capital 18, hardware 13, expertise 14, load 14; 10. IoT Integration Framework: return 19 QCU, cycles 16, capital 19, hardware 16, expertise 19, load 19; 11. API Gateway Service: return 30 QCU, cycles 16, capital 15, hardware 14, expertise 15, load 17; 12. Security Audit Suite: return 70 QCU, cycles 15, capital 13, hardware 16, expertise 17, load 16; 13. Predictive Analytics: return 83 QCU, cycles 17, capital 13, hardware 16, expertise 13, load 17; 14. Autonomous System: return 86 QCU, cycles 17, capital 15, hardware 19, expertise 17, load 14; 15. Robotic Process Automation: return 91 QCU, cycles 14, capital 19, hardware 19, expertise 18, load 18; 16. Smart Contract Platform: return 68 QCU, cycles 13, capital 14, hardware 15, expertise 19, load 19; 17. Virtual Reality Engine: return 11 QCU, cycles 14, capital 13, hardware 15, expertise 14, load 16; 18. Quantum Sensor Network: return 70 QCU, cycles 16, capital 16, hardware 15, expertise 18, load 17; 19. Augmented Reality Interface: return 100 QCU, cycles 18, capital 18, hardware 19, expertise 16, load 16; 20. Biometric Security System: return 15 QCU, cycles 19, capital 17, hardware 17, expertise 15, load 17; 21. Voice Assistant: return 92 QCU, cycles 15, capital 15, hardware 13, expertise 19, load 14; 22. Cyber Defense Shield: return 28 QCU, cycles 16, capital 13, hardware 16, expertise 14, load 13; 23. Quantum Encryption Service: return 31 QCU, cycles 16, capital 13, hardware 13, expertise 16, load 19; 24. Edge Analytics Node: return 76 QCU, cycles 17, capital 15, hardware 17, expertise 16, load 19; 25. Microservice Architecture: return 63 QCU, cycles 17, capital 19, hardware 16, expertise 16, load 14; 26. Serverless Function Platform: return 56 QCU, cycles 14, capital 14, hardware 19, expertise 14, load 18; 27. Container Orchestration: return 39 QCU, cycles 13, capital 13, hardware 15, expertise 13, load 19; 28. DevOps Automation: return 34 QCU, cycles 14, capital 16, hardware 15, expertise 17, load 19; 29. Continuous Integration Pipeline: return 58 QCU, cycles 16, capital 18, hardware 19, expertise 19, load 19; 30. Multi-Cloud Strategy: return 15 QCU, cycles 18, capital 17, hardware 15, expertise 13, load 13; 31. Digital Twin Platform: return 74 QCU, cycles 19, capital 14, hardware 13, expertise 16, load 17; 32. Quantum Computing Cluster: return 70 QCU, cycles 17, capital 13, hardware 19, expertise 19, load 16; 33. Federated Learning Network: return 13 QCU, cycles 15, capital 13, hardware 14, expertise 16, load 17; 34. Big Data Processing: return 95 QCU, cycles 13, capital 19, hardware 17, expertise 18, load 14; 35. Natural Language Processor: return 85 QCU, cycles 13, capital 14, hardware 16, expertise 15, load 17; 36. Computer Vision System: return 23 QCU, cycles 15, capital 18, hardware 16, expertise 17, load 16; 37. Speech Recognition Engine: return 16 QCU, cycles 15, capital 15, hardware 16, expertise 14, load 19; 38. Graph Database Engine: return 48 QCU, cycles 19, capital 18, hardware 19, expertise 19, load 13; 39. Recommendation System: return 85 QCU, cycles 19, capital 18, hardware 19, expertise 19, load 13; 40. Anomaly Detection: return 79 QCU, cycles 17, capital 18, hardware 19, expertise 19, load 16; 41. Threat Intelligence Platform: return 21 QCU, cycles 13, capital 14, hardware 13, expertise 16, load 17; 42. Zero-Knowledge Proof: return 17 QCU, cycles 15, capital 13, hardware 19, expertise 13, load 14; 43. Smart Contract Executor: return 79 QCU, cycles 15, capital 18, hardware 14, expertise 16, load 13; 44. Privacy Preserving Analytics: return 31 QCU, cycles 13, capital 15, hardware 17, expertise 18, load 19; 45. Distributed Consensus: return 70 QCU, cycles 13, capital 18, hardware 16, expertise 15, load 13; 46. Load Balancer: return 93 QCU, cycles 19, capital 15, hardware 17, expertise 17, load 19; 47. Fault Tolerant System: return 81 QCU, cycles 18, capital 13, hardware 16, expertise 14, load 16; 48. Data Lake Architecture: return 40 QCU, cycles 17, capital 18, hardware 17, expertise 19, load 17; 49. Knowledge Graph Builder: return 21 QCU, cycles 13, capital 19, hardware 19, expertise 13, load 16; 50. Real-time Analytics: return 55 QCU, cycles 15, capital 19, hardware 14, expertise 17, load 17; 51. Stream Processing Engine: return 51 QCU, cycles 17, capital 16, hardware 19, expertise 14, load 19; 52. Event-Driven Architecture: return 28 QCU, cycles 14, capital 18, hardware 14, expertise 13, load 17; 53. Time Series Forecaster: return 28 QCU, cycles 16, capital 15, hardware 14, expertise 16, load 15; 54. Autonomous Agent Network: return 37 QCU, cycles 13, capital 17, hardware 19, expertise 19, load 14; 55. Quantum Communication Mesh: return 42 QCU, cycles 16, capital 12, hardware 16, expertise 14, load 13; 56. Bio-inspired Computing: return 37 QCU, cycles 19, capital 18, hardware 13, expertise 18, load 19; 57. Hybrid Intelligence System: return 75 QCU, cycles 13, capital 17, hardware 17, expertise 19, load 16; 58. Cognitive Computing Engine: return 99 QCU, cycles 14, capital 19, hardware 14, expertise 19, load 17; 59. Neural Processing Core: return 52 QCU, cycles 13, capital 17, hardware 13, expertise 19, load 13; 60. Quantum Interface Framework: return 85 QCU, cycles 17, capital 19, hardware 14, expertise 19, load 19. Each investment opportunity can either be selected (1) or not selected (0). How should the investment opportunities be selected to maximize the total quantum credit return without exceeding any of the five dimensional capacity constraints?",  
  "solution_format_description": "Print the following fields: - selected: selection status for each investment opportunity. - total_return: total economic return. - total_cycles: total development cycles. - total_capital: total financial capital. - total_hardware: total hardware resources. - total_expertise: total expert hours. - total_load: total server capacity.",
  "structured_data": {
    "num_opportunities": 60,
    "num_constraint_types": 5,
    "opportunities": [
      [85,17,14,14,13,17],[98,17,13,14,17,17],[15,19,18,13,17,19],
      [68,18,15,16,17,17],[13,13,18,19,14,14],[93,18,14,19,19,18],
      [100,17,15,15,15,15],[59,19,17,16,16,13],[52,15,18,13,14,14],
      [19,16,19,16,19,19],[30,16,15,14,15,17],[70,15,13,16,17,16],
      [83,17,13,16,13,17],[86,17,15,19,17,14],[91,14,19,19,18,18],
      [68,13,14,15,19,19],[11,14,13,15,14,16],[70,16,16,15,18,17],
      [100,18,18,19,16,16],[15,19,17,17,15,17],[92,15,15,13,19,14],
      [28,16,13,16,14,13],[31,16,13,13,16,19],[76,17,15,17,16,19],
      [63,17,19,16,16,14],[56,14,14,19,14,18],[39,13,13,15,13,19],
      [34,14,16,15,17,19],[58,16,18,19,19,19],[15,18,17,15,13,13],
      [74,19,14,13,16,17],[70,17,13,19,19,16],[13,15,13,14,16,17],
      [95,13,19,17,18,14],[85,13,14,16,15,17],[23,15,18,16,17,16],
      [16,15,15,16,14,19],[48,19,18,19,19,13],[85,18,14,15,13,19],
      [79,17,18,19,19,16],[21,13,14,13,16,17],[17,15,13,19,13,14],
      [79,15,18,14,16,13],[31,13,15,17,18,19],[70,13,18,16,15,13],
      [93,19,15,17,17,19],[81,18,13,16,14,16],[40,17,18,17,19,17],
      [21,13,19,19,13,16],[55,15,19,14,17,17],[51,17,16,19,14,19],
      [28,14,18,14,13,17],[28,16,15,14,16,15],[37,13,17,19,19,14],
      [42,16,12,16,14,13],[37,19,18,13,18,19],[75,13,17,17,19,16],
      [99,14,19,14,19,17],[52,13,17,13,19,13],[85,17,19,14,19,19]],
    "constraints": [280,300,250,280,260]
  },
  "reference_solution": {
    "selected": [1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
    "total_return": 1428,
    "total_cycles": 264,
    "total_capital": 248,
    "total_hardware": 250,
    "total_expertise": 263,
    "total_load": 260
  },
  "solver_code": "from cpmpy import *\nimport json\n\nopportunities = [\n    [85, 17, 14, 14, 13, 17],\n    [98, 17, 13, 14, 17, 17],\n    [15, 19, 18, 13, 17, 19],\n    [68, 18, 15, 16, 17, 17],\n    [13, 13, 18, 19, 14, 14],\n    [93, 18, 14, 19, 19, 18],\n    [100, 17, 15, 15, 15, 15],\n    [59, 19, 17, 16, 16, 13],\n    [52, 15, 18, 13, 14, 14],\n    [19, 16, 19, 16, 19, 19],\n    [30, 16, 15, 14, 15, 17],\n    [70, 15, 13, 16, 17, 16],\n    [83, 17, 13, 16, 13, 17],\n    [86, 17, 15, 19, 17, 14],\n    [91, 14, 19, 19, 18, 18],\n    [68, 13, 14, 15, 19, 19],\n    [11, 14, 13, 15, 14, 16],\n    [70, 16, 15, 16, 18, 17],\n    [100, 18, 18, 19, 16, 16],\n    [15, 19, 17, 17, 15, 17],\n    [92, 15, 15, 13, 19, 14],\n    [28, 16, 13, 16, 14, 13],\n    [31, 16, 13, 13, 16, 19],\n    [76, 17, 15, 17, 16, 19],\n    [63, 17, 19, 16, 16, 14],\n    [56, 14, 14, 19, 14, 18],\n    [39, 13, 13, 15, 13, 19],\n    [34, 14, 16, 15, 17, 19],\n    [58, 16, 18, 19, 19, 19],\n    [15, 18, 17, 15, 13, 13],\n    [74, 19, 14, 13, 16, 17],\n    [70, 17, 13, 19, 19, 16],\n    [13, 15, 13, 14, 16, 17],\n    [95, 13, 19, 17, 18, 14],\n    [85, 13, 14, 16, 15, 17],\n    [23, 15, 18, 16, 17, 16],\n    [16, 15, 15, 16, 14, 19],\n    [48, 19, 18, 19, 19, 13],\n    [85, 18, 14, 15, 13, 19],\n    [79, 17, 18, 19, 19, 16],\n    [21, 13, 14, 13, 16, 17],\n    [17, 15, 13, 19, 13, 14],\n    [79, 15, 18, 14, 16, 13],\n    [31, 13, 15, 17, 18, 19],\n    [70, 13, 18, 16, 15, 13],\n    [93, 19, 15, 17, 17, 19],\n    [81, 18, 13, 16, 14, 16],\n    [40, 17, 18, 17, 19, 17],\n    [21, 13, 19, 19, 13, 16],\n    [55, 15, 19, 14, 17, 17],\n    [51, 17, 16, 19, 14, 19],\n    [28, 14, 18, 14, 13, 17],\n    [28, 16, 15, 14, 16, 15],\n    [37, 13, 17, 19, 19, 14],\n    [42, 16, 12, 16, 14, 13],\n    [37, 19, 18, 13, 18, 19],\n    [75, 13, 17, 17, 19, 16],\n    [99, 14, 19, 14, 19, 17],\n    [52, 13, 17, 13, 19, 13],\n    [85, 17, 19, 14, 19, 19]\n]\n\nconstraints = [280, 300, 250, 280, 260]\nmax_cycles = constraints[0]\nmax_capital = constraints[1]\nmax_hardware = constraints[2]\nmax_expertise = constraints[3]\nmax_load = constraints[4]\n\nnum_opportunities = len(opportunities)\n\nx = boolvar(shape=num_opportunities)\n\nmodel = Model()\n\nmodel += sum(opportunities[i][1] * x[i] for i in range(num_opportunities)) <= max_cycles\nmodel += sum(opportunities[i][2] * x[i] for i in range(num_opportunities)) <= max_capital\nmodel += sum(opportunities[i][3] * x[i] for i in range(num_opportunities)) <= max_hardware\nmodel += sum(opportunities[i][4] * x[i] for i in range(num_opportunities)) <= max_expertise\nmodel += sum(opportunities[i][5] * x[i] for i in range(num_opportunities)) <= max_load\n\nmodel.maximize(sum(opportunities[i][0] * x[i] for i in range(num_opportunities)))\n\nif model.solve():\n    selected = [int(x[i].value()) for i in range(num_opportunities)]\n    total_return = sum(opportunities[i][0] * selected[i] for i in range(num_opportunities))\n    total_cycles = sum(opportunities[i][1] * selected[i] for i in range(num_opportunities))\n    total_capital = sum(opportunities[i][2] * selected[i] for i in range(num_opportunities))\n    total_hardware = sum(opportunities[i][3] * selected[i] for i in range(num_opportunities))\n    total_expertise = sum(opportunities[i][4] * selected[i] for i in range(num_opportunities))\n    total_load = sum(opportunities[i][5] * selected[i] for i in range(num_opportunities))\n    \n    result = {\n        \"selected\": selected,\n        \"total_return\": total_return,\n        \"total_cycles\": total_cycles,\n        \"total_capital\": total_capital,\n        \"total_hardware\": total_hardware,\n        \"total_expertise\": total_expertise,\n        \"total_load\": total_load\n    }\n    print(json.dumps(result))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"selected\", \"total_return\", \"total_cycles\", \"total_capital\", \"total_hardware\", \"total_expertise\", \"total_load\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        selected = solution[\"selected\"]\n        total_cycles = solution[\"total_cycles\"]\n        total_capital = solution[\"total_capital\"]\n        total_hardware = solution[\"total_hardware\"]\n        total_expertise = solution[\"total_expertise\"]\n        total_load = solution[\"total_load\"]\n        \n        opportunities = structured_data[\"opportunities\"]\n        constraints = structured_data[\"constraints\"]\n        num_opportunities = len(opportunities)\n        errors = []\n        \n        if len(selected) != num_opportunities:\n            errors.append(f\"Selection array length mismatch: expected {num_opportunities}, got {len(selected)}\")\n            return {\"is_valid\": False, \"validation_errors\": errors, \"optimality_score\": 0.0}\n        \n        for i in range(num_opportunities):\n            if selected[i] not in [0, 1]:\n                errors.append(f\"Invalid selection value at index {i}: {selected[i]} (must be 0 or 1)\")\n        \n        if total_cycles > constraints[0]:\n            errors.append(f\"Cycles constraint violated: {total_cycles} > {constraints[0]}\")\n        \n        if total_capital > constraints[1]:\n            errors.append(f\"Capital constraint violated: {total_capital} > {constraints[1]}\")\n        \n        if total_hardware > constraints[2]:\n            errors.append(f\"Hardware constraint violated: {total_hardware} > {constraints[2]}\")\n        \n        if total_expertise > constraints[3]:\n            errors.append(f\"Expertise constraint violated: {total_expertise} > {constraints[3]}\")\n        \n        if total_load > constraints[4]:\n            errors.append(f\"Load constraint violated: {total_load} > {constraints[4]}\")\n        \n        if len(errors) == 0:\n            optimal_value = reference_solution[\"total_return\"]\n            if optimal_value == 0:\n                optimality_score = 1.0 if solution[\"total_return\"] == 0 else 0.0\n            else:\n                gap = abs(optimal_value - solution[\"total_return\"]) / abs(optimal_value)\n                optimality_score = max(0, 1 - gap)\n        else:\n            optimality_score = 0.0\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}