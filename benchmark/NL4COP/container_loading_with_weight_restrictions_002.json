{
  "problem_id": "container_loading_with_weight_restrictions_002",
  "metadata": {
    "problem_type": "Container Loading with Weight Restrictions Problem",
    "difficulty": "medium"
  },
  "problem_description": "An e-commerce warehouse needs to load a delivery van measuring 150×100×120 cm with customer orders. Available packages are: Category 1 packages (8 units available, each 60×40×30 cm, weighing 25 kg), Category 2 packages (7 units available, each 40×30×20 cm, weighing 15 kg), and Category 3 packages (5 units available, each 30×20×15 cm, weighing 8 kg). Each package can be placed in one of three orientations by rotating its dimensions. Packages must be placed such that they do not extend beyond the van boundaries in any dimension. Additionally, packages cannot overlap with each other in the van space. The objective is to maximize the total volume of packages loaded into the van, thereby achieving the highest possible space utilization rate.",
  "solution_format_description": "Print the following fields: - package_placements: for each package, list placement with category, x, y, z, length, width, height. - space_utilization: ratio of used van space to total space. - total_volume_used: total volume of placed packages. - van_volume: total van volume.",
  "structured_data": {
    "container_dimensions": [150, 100, 120],
    "box_inventory": [
      [60, 40, 30, 8, 25],
      [40, 30, 20, 7, 15],
      [30, 20, 15, 5, 8]
    ]
  },
  "reference_solution": {
    "package_placements": [
      [1, [101, 0, 9], [30, 60, 40]],
      [1, [0, 0, 30], [40, 30, 60]],
      [1, [70, 43, 49], [60, 40, 30]],
      [1, [66, 0, 59], [60, 40, 30]],
      [1, [30, 0, 90], [60, 40, 30]],
      [1, [61, 40, 0], [30, 60, 40]],
      [1, [90, 0, 89], [60, 40, 30]],
      [1, [37, 40, 48], [30, 60, 40]],
      [2, [0, 60, 67], [30, 20, 40]],
      [2, [0, 40, 67], [30, 20, 40]],
      [2, [0, 80, 67], [30, 20, 40]],
      [2, [30, 44, 88], [20, 40, 30]],
      [2, [50, 44, 88], [20, 40, 30]],
      [2, [70, 44, 79], [20, 40, 30]],
      [2, [90, 44, 79], [20, 40, 30]],
      [3, [125, 50, 87], [15, 30, 20]],
      [3, [110, 53, 85], [15, 30, 20]],
      [3, [110, 83, 75], [20, 15, 30]],
      [3, [130, 82, 75], [20, 15, 30]],
      [3, [120, 80, 105], [30, 20, 15]]
    ],
    "space_utilization": 0.438,
    "total_volume_used": 789000,
    "van_volume": 1800000
  },
  "solver_code": "from cpmpy import *\nimport json\n\ncontainer_dimensions = [150, 100, 120]\nbox_inventory = [\n    [60, 40, 30, 8, 25],\n    [40, 30, 20, 7, 15],\n    [30, 20, 15, 5, 8]\n]\n\ncontainer_length, container_width, container_height = container_dimensions\ncontainer_volume = container_length * container_width * container_height\n\nboxes = []\nfor box_idx, (length, width, height, available, weight) in enumerate(box_inventory):\n    for i in range(available):\n        boxes.append([box_idx + 1, length, width, height])\n\nnum_boxes = len(boxes)\n\nused = boolvar(shape=num_boxes)\nx = intvar(0, container_length, shape=num_boxes)\ny = intvar(0, container_width, shape=num_boxes)\nz = intvar(0, container_height, shape=num_boxes)\norientation = intvar(1, 3, shape=num_boxes)\n\no_length = intvar(1, max(container_length, container_width, container_height), shape=num_boxes)\no_width = intvar(1, max(container_length, container_width, container_height), shape=num_boxes)\no_height = intvar(1, max(container_length, container_width, container_height), shape=num_boxes)\n\nmodel = Model()\n\nfor i in range(num_boxes):\n    box_type, length, width, height = boxes[i]\n    \n    model += (orientation[i] == 1).implies(o_length[i] == length)\n    model += (orientation[i] == 1).implies(o_width[i] == width)\n    model += (orientation[i] == 1).implies(o_height[i] == height)\n    \n    model += (orientation[i] == 2).implies(o_length[i] == width)\n    model += (orientation[i] == 2).implies(o_width[i] == height)\n    model += (orientation[i] == 2).implies(o_height[i] == length)\n    \n    model += (orientation[i] == 3).implies(o_length[i] == height)\n    model += (orientation[i] == 3).implies(o_width[i] == length)\n    model += (orientation[i] == 3).implies(o_height[i] == width)\n    \n    model += used[i].implies(x[i] + o_length[i] <= container_length)\n    model += used[i].implies(y[i] + o_width[i] <= container_width)\n    model += used[i].implies(z[i] + o_height[i] <= container_height)\n\nfor i in range(num_boxes):\n    for j in range(i + 1, num_boxes):\n        no_x_overlap = (x[i] + o_length[i] <= x[j]) | (x[j] + o_length[j] <= x[i])\n        no_y_overlap = (y[i] + o_width[i] <= y[j]) | (y[j] + o_width[j] <= y[i])\n        no_z_overlap = (z[i] + o_height[i] <= z[j]) | (z[j] + o_height[j] <= z[i])\n        non_overlap = no_x_overlap | no_y_overlap | no_z_overlap\n        model += (used[i] & used[j]).implies(non_overlap)\n\nbox_volumes = [boxes[i][1] * boxes[i][2] * boxes[i][3] for i in range(num_boxes)]\nmodel.maximize(sum(used[i] * box_volumes[i] for i in range(num_boxes)))\n\nif model.solve():\n    total_volume_used = sum(box_volumes[i] for i in range(num_boxes) if used[i].value())\n    space_utilization = total_volume_used / container_volume\n    \n    package_placements = []\n    for i in range(num_boxes):\n        if used[i].value():\n            package_placements.append([\n                boxes[i][0],\n                [int(x[i].value()), int(y[i].value()), int(z[i].value())],\n                [int(o_length[i].value()), int(o_width[i].value()), int(o_height[i].value())]\n            ])\n    \n    result = {\n        \"package_placements\": package_placements,\n        \"space_utilization\": round(space_utilization, 3),\n        \"total_volume_used\": total_volume_used,\n        \"van_volume\": container_volume\n    }\n    \n    print(json.dumps(result))\nelse:\n    print(json.dumps({\n        \"package_placements\": [],\n        \"space_utilization\": 0.0,\n        \"total_volume_used\": 0,\n        \"van_volume\": container_volume\n    }))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"package_placements\", \"space_utilization\", \"total_volume_used\", \"van_volume\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        placements = solution[\"package_placements\"]\n        space_utilization = solution[\"space_utilization\"]\n        total_volume_used = solution[\"total_volume_used\"]\n        van_volume = solution[\"van_volume\"]\n        \n        van = structured_data[\"van_dimensions\"]\n        packages = structured_data[\"packages\"]\n        \n        errors = []\n        \n        if van_volume != van[\"length\"] * van[\"width\"] * van[\"height\"]:\n            errors.append(f\"Van volume mismatch: expected {van['length'] * van['width'] * van['height']}, got {van_volume}\")\n        \n        category_to_index = {}\n        for idx, pkg in enumerate(packages):\n            category_to_index[pkg[\"category\"]] = idx\n        \n        package_usage = [0] * len(packages)\n        \n        for i, placement in enumerate(placements):\n            if len(placement) != 3:\n                errors.append(f\"Placement {i} should have 3 elements: [category, [x,y,z], [length,width,height]]\")\n                continue\n            \n            category, position, dimensions = placement\n            x, y, z = position\n            length, width, height = dimensions\n            \n            if category not in category_to_index:\n                errors.append(f\"Invalid package category {category} in placement {i}\")\n                continue\n            \n            pkg_idx = category_to_index[category]\n            package_usage[pkg_idx] += 1\n            \n            if package_usage[pkg_idx] > packages[pkg_idx][\"units_available\"]:\n                errors.append(f\"Exceeded available quantity for package category {category}\")\n            \n            if x < 0 or y < 0 or z < 0:\n                errors.append(f\"Negative coordinates in placement {i}\")\n            \n            if x + length > van[\"length\"]:\n                errors.append(f\"Package {i} exceeds van length: {x} + {length} > {van['length']}\")\n            \n            if y + width > van[\"width\"]:\n                errors.append(f\"Package {i} exceeds van width: {y} + {width} > {van['width']}\")\n            \n            if z + height > van[\"height\"]:\n                errors.append(f\"Package {i} exceeds van height: {z} + {height} > {van['height']}\")\n        \n        for i in range(len(placements)):\n            for j in range(i + 1, len(placements)):\n                if packages_overlap(placements[i], placements[j]):\n                    errors.append(f\"Packages {i} and {j} overlap\")\n        \n        calc_volume = 0\n        for placement in placements:\n            category = placement[0]\n            if category in category_to_index:\n                pkg_idx = category_to_index[category]\n                pkg = packages[pkg_idx]\n                calc_volume += pkg[\"size\"][\"length\"] * pkg[\"size\"][\"width\"] * pkg[\"size\"][\"height\"]\n        \n        if abs(calc_volume - total_volume_used) > 1e-6:\n            errors.append(f\"Volume calculation mismatch: calculated {calc_volume}, declared {total_volume_used}\")\n        \n        calc_utilization = calc_volume / van_volume if van_volume > 0 else 0\n        if abs(calc_utilization - space_utilization) > 1e-6:\n            errors.append(f\"Utilization calculation mismatch: calculated {calc_utilization}, declared {space_utilization}\")\n        \n        optimal_volume = reference_solution[\"total_volume_used\"]\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            if optimal_volume == 0:\n                optimality_score = 1.0 if total_volume_used == 0 else 0.0\n            else:\n                gap = abs(optimal_volume - total_volume_used) / abs(optimal_volume)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Format error in solution data: {str(e)}\"], \"optimality_score\": 0.0}\n\ndef packages_overlap(placement1, placement2):\n    _, pos1, dim1 = placement1\n    _, pos2, dim2 = placement2\n    \n    x1, y1, z1 = pos1\n    x2, y2, z2 = pos2\n    l1, w1, h1 = dim1\n    l2, w2, h2 = dim2\n    \n    if x1 + l1 <= x2 or x2 + l2 <= x1:\n        return False\n    if y1 + w1 <= y2 or y2 + w2 <= y1:\n        return False\n    if z1 + h1 <= z2 or z2 + h2 <= z1:\n        return False\n    \n    return True"
}