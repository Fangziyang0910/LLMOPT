{
  "problem_id": "packing_rectangles_003",
  "metadata": {
    "problem_type": "Rectangle Packing Problem",
    "difficulty": "hard"
  },
  "problem_description": "In a cutting-edge biomedical research facility, scientists are developing a sophisticated spatial optimization algorithm for arranging microfluidic chip modules within a circular containment chamber for advanced cellular analysis experiments. The containment chamber generates a precisely controlled circular spatial boundary with quantum stabilization coordinates centered at (30, 36) and an effective containment radius of 42 micrometers. Ten heterogeneous microfluidic processing modules require precise spatial configuration: module 1 implements an electrophoresis separation channel with a length of 11 micrometers and a width of 16 micrometers for protein analysis; module 2 houses a flow cytometry chamber with a length of 22 micrometers and a width of 11 micrometers for cell sorting and classification; module 3 contains a PCR amplification microreactor with a length of 17 micrometers and a width of 15 micrometers for nucleic acid replication; module 4 integrates an immunoassay detection array with a length of 18 micrometers and a width of 26 micrometers for biomarker identification; module 5 provides a cell culture chamber with a length of 27 micrometers and a width of 26 micrometers with controlled environmental conditions; module 6 incorporates a mass spectrometry interface with a length of 32 micrometers and a width of 22 micrometers for molecular weight determination; module 7 establishes an optical detection system with a length of 30 micrometers and a width of 35 micrometers with fluorescence capabilities; module 8 maintains a temperature-controlled incubation zone with a length of 37 micrometers and a width of 34 micrometers for enzymatic reactions; module 9 operates a high-throughput screening platform with a length of 46 micrometers and a width of 34 micrometers for drug discovery; and module 10 contains an integrated analysis system with a length of 38 micrometers and a width of 48 micrometers for comprehensive metabolic profiling. Each module can either be activated for the experimental protocol or remain inactive, with no partial activation allowed. When a module is activated, it must be positioned so that its entire rectangular area lies completely within the circular containment chamber boundaries. No two activated modules can overlap with each other. Additionally, each module can be oriented in its original direction (0 degrees) or rotated 90 degrees to better fit the available spatial configuration. The research team wants to determine which modules to activate, where to position them, and how to orient them to maximize the total number of modules that can be successfully arranged within the containment chamber. Important constraints: all spatial positioning coordinates must be integer quantum lattice points to maintain phase coherence, module positions are defined by their quantum center coordinates, and modules can only be rotated by orthogonal quantum alignment angles of 0 or 90 degrees.",
  "solution_format_description": "Print the following fields: - activated: for each activated module, list placement with module ID, x, y, rotation. - total_activated: total number of activated modules.",
  "structured_data": {
    "chamber_center": [30, 36],
    "chamber_radius": 42,
    "module_dimensions": [[11, 16], [22, 11], [17, 15], [18, 26], [27, 26], [32, 22], [30, 35], [37, 34], [46, 34], [38, 48]]
  },
  "reference_solution": {
    "activated": [[1, 5, 16, 90], [2, 11, 57, 0], [3, 40, 6, 0], [4, 22, 11, 0], [5, 6, 38, 90], [6, 47, 25, 0], [7, 41, 51, 90]],
    "total_activated": 7
  },
  "solver_code": "from cpmpy import *\nimport json\n\nn = 10\ncx, cy = 30, 36\nR = 42\nitems = [[11, 16], [22, 11], [17, 15], [18, 26], [27, 26], [32, 22], [30, 35], [37, 34], [46, 34], [38, 48]]\n\nmodel = Model()\nselected = boolvar(shape=n)\nrotated = boolvar(shape=n)\n\n\ndummy_x, dummy_y = cx + R + 100, cy + R + 100\nx = intvar(cx - R, max(cx + R, dummy_x), shape=n)\ny = intvar(cy - R, max(cy + R, dummy_y), shape=n)\n\nfor i in range(n):\n\n    model += (~selected[i]).implies(x[i] == dummy_x)\n    model += (~selected[i]).implies(y[i] == dummy_y)\n    model += (~selected[i]).implies(~rotated[i])\n    l, w = items[i]\n    \n\n    half_l, half_w = l // 2, w // 2\n    corners_x_orig = [x[i] - half_l, x[i] - half_l, x[i] + half_l, x[i] + half_l]\n    corners_y_orig = [y[i] - half_w, y[i] + half_w, y[i] - half_w, y[i] + half_w]\n    \n\n    half_w_rot, half_l_rot = w // 2, l // 2\n    corners_x_rot = [x[i] - half_w_rot, x[i] - half_w_rot, x[i] + half_w_rot, x[i] + half_w_rot]\n    corners_y_rot = [y[i] - half_l_rot, y[i] + half_l_rot, y[i] - half_l_rot, y[i] + half_l_rot]\n    \n\n    for cx_corner, cy_corner in zip(corners_x_orig, corners_y_orig):\n        dist_sq = (cx_corner - cx)**2 + (cy_corner - cy)**2\n        model += (selected[i] & ~rotated[i]).implies(dist_sq <= R**2)\n    \n\n    for cx_corner, cy_corner in zip(corners_x_rot, corners_y_rot):\n        dist_sq = (cx_corner - cx)**2 + (cy_corner - cy)**2\n        model += (selected[i] & rotated[i]).implies(dist_sq <= R**2)\n\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        l1, w1 = items[i]\n        l2, w2 = items[j]\n        \n\n        x1_min = x[i] - l1//2\n        x1_max = x[i] + l1//2\n        y1_min = y[i] - w1//2\n        y1_max = y[i] + w1//2\n        x2_min = x[j] - l2//2\n        x2_max = x[j] + l2//2\n        y2_min = y[j] - w2//2\n        y2_max = y[j] + w2//2\n        no_overlap_case1 = (x1_max <= x2_min) | (x2_max <= x1_min) | (y1_max <= y2_min) | (y2_max <= y1_min)\n        model += (selected[i] & selected[j] & ~rotated[i] & ~rotated[j]).implies(no_overlap_case1)\n        \n\n        x1_min = x[i] - l1//2\n        x1_max = x[i] + l1//2\n        y1_min = y[i] - w1//2\n        y1_max = y[i] + w1//2\n        x2_min = x[j] - w2//2\n        x2_max = x[j] + w2//2\n        y2_min = y[j] - l2//2\n        y2_max = y[j] + l2//2\n        no_overlap_case2 = (x1_max <= x2_min) | (x2_max <= x1_min) | (y1_max <= y2_min) | (y2_max <= y1_min)\n        model += (selected[i] & selected[j] & ~rotated[i] & rotated[j]).implies(no_overlap_case2)\n        \n\n        x1_min = x[i] - w1//2\n        x1_max = x[i] + w1//2\n        y1_min = y[i] - l1//2\n        y1_max = y[i] + l1//2\n        x2_min = x[j] - l2//2\n        x2_max = x[j] + l2//2\n        y2_min = y[j] - w2//2\n        y2_max = y[j] + w2//2\n        no_overlap_case3 = (x1_max <= x2_min) | (x2_max <= x1_min) | (y1_max <= y2_min) | (y2_max <= y1_min)\n        model += (selected[i] & selected[j] & rotated[i] & ~rotated[j]).implies(no_overlap_case3)\n        \n\n        x1_min = x[i] - w1//2\n        x1_max = x[i] + w1//2\n        y1_min = y[i] - l1//2\n        y1_max = y[i] + l1//2\n        x2_min = x[j] - w2//2\n        x2_max = x[j] + w2//2\n        y2_min = y[j] - l2//2\n        y2_max = y[j] + l2//2\n        no_overlap_case4 = (x1_max <= x2_min) | (x2_max <= x1_min) | (y1_max <= y2_min) | (y2_max <= y1_min)\n        model += (selected[i] & selected[j] & rotated[i] & rotated[j]).implies(no_overlap_case4)\n\n\nmodel.maximize(sum(selected))\n\nif model.solve():\n    activated = []\n    for i in range(n):\n        if selected[i].value():\n            rotation = 90 if rotated[i].value() else 0\n            activated.append([i, int(x[i].value()), int(y[i].value()), rotation])\n    result = {\"activated\": activated, \"total_activated\": len(activated)}\n    print(json.dumps(result))\nelse:\n    print(json.dumps({\"error\": \"No solution found\"}))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n\n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n\n    required_fields = [\"activated\", \"total_activated\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n\n    try:\n        activated = solution[\"activated\"]\n        total_activated = solution[\"total_activated\"]\n        cx, cy = structured_data[\"chamber_center\"][0], structured_data[\"chamber_center\"][1]\n        R = structured_data[\"chamber_radius\"]\n        items = structured_data[\"module_dimensions\"]\n        errors = []\n        \n\n        if not isinstance(activated, list):\n            errors.append(\"Field 'activated' must be a list\")\n        if not isinstance(total_activated, int) or total_activated < 0:\n            errors.append(\"Field 'total_activated' must be a non-negative integer\")\n        if len(activated) != total_activated:\n            errors.append(f\"Inconsistent count: activated length {len(activated)} != total_activated {total_activated}\")\n        \n\n        used_items = set()\n        positions = []\n        for i, item_data in enumerate(activated):\n            if not isinstance(item_data, list) or len(item_data) != 4:\n                errors.append(f\"Activated item {i}: must be [module_id, x, y, rotation] format\")\n                continue\n            module_id, x, y, rotation = item_data\n            if not isinstance(module_id, int) or module_id < 0 or module_id >= len(items):\n                errors.append(f\"Activated item {i}: invalid module_id {module_id}\")\n                continue\n            if module_id in used_items:\n                errors.append(f\"Activated item {i}: duplicate module_id {module_id}\")\n                continue\n            used_items.add(module_id)\n            \n\n            if not isinstance(x, int) or not isinstance(y, int) or not isinstance(rotation, int):\n                errors.append(f\"Activated item {i}: x, y, rotation must be integers\")\n                continue\n            if rotation not in [0, 90]:\n                errors.append(f\"Activated item {i}: rotation must be 0 or 90\")\n                continue\n            \n\n            l, w = items[module_id]\n            if rotation == 90:\n                l, w = w, l\n                \n            corners = [\n                (x - l//2, y - w//2), \n                (x - l//2, y + w//2),\n                (x + l//2, y - w//2),\n                (x + l//2, y + w//2)\n            ]\n            for corner_x, corner_y in corners:\n                dist_sq = (corner_x - cx)**2 + (corner_y - cy)**2\n                if dist_sq > R**2:\n                    errors.append(f\"Module {module_id} exceeds chamber boundaries\")\n                    break\n        \n\n        for i in range(len(activated)):\n            module_id_i, x_i, y_i, rotation_i = activated[i]\n            l_i, w_i = items[module_id_i]\n            if rotation_i == 90:\n                l_i, w_i = w_i, l_i\n                \n            for j in range(i + 1, len(activated)):\n                module_id_j, x_j, y_j, rotation_j = activated[j]\n                l_j, w_j = items[module_id_j]\n                if rotation_j == 90:\n                    l_j, w_j = w_j, l_j\n                \n                i_right = x_i + l_i//2\n                i_left = x_i - l_i//2\n                i_top = y_i + w_i//2\n                i_bottom = y_i - w_i//2\n                \n                j_right = x_j + l_j//2\n                j_left = x_j - l_j//2\n                j_top = y_j + w_j//2\n                j_bottom = y_j - w_j//2\n                \n                if not (i_right <= j_left or j_right <= i_left or i_top <= j_bottom or j_top <= i_bottom):\n                    errors.append(f\"Modules {module_id_i} and {module_id_j} overlap\")\n        \n\n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_value = reference_solution[\"total_activated\"]\n            if optimal_value == 0:\n                optimality_score = 1.0 if total_activated == 0 else 0.0\n            else:\n                gap = abs(optimal_value - total_activated) / abs(optimal_value)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}