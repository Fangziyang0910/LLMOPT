{
  "problem_id": "maximum_independent_set_003",
  "metadata": {
    "problem_type": "Maximum Independent Set Problem",
    "difficulty": "hard"
  },
  "problem_description": "The Global Digital Infrastructure Consortium is undertaking a sophisticated distributed systems optimization initiative involving the strategic deployment of fifty distinct computational service modules within a unified resource allocation framework. The consortium's systems architecture committee has identified multifaceted operational incompatibilities that preclude concurrent execution of certain service modules due to complex infrastructure resource contention patterns. The intricate deployment constraints reveal that service modules 0-5 constitute a critical persistent data management subsystem where all modules exhibit mutual resource competition for exclusive storage input/output bandwidth access, creating comprehensive operational exclusivity among the entire cluster. Service modules 6-12 represent an advanced computational processing framework requiring monopolistic access to specialized graphics processing unit infrastructure, establishing complete mutual operational conflicts across the entire high-performance computing cluster. Service modules 13-24 embody a distributed web services architecture with specific adjacency constraints: modules 13-14-15-16 form a linear horizontal chain where consecutive modules share network interfaces, modules 17-18-19-20 constitute another horizontal chain, modules 21-22-23-24 represent a third horizontal chain, with vertical interconnections between chains creating cross-tier network bandwidth conflicts. Service modules 25-34 implement a hierarchical message dissemination architecture with tree-like dependency constraints: module 25 serves as root conflicting with children 26 and 27, module 26 conflicts with descendants 28 and 29, module 27 conflicts with descendants 30 and 31, module 28 conflicts with leaf nodes 32 and 33, and module 32 conflicts with terminal module 34, establishing parent-child exclusivity patterns. Service modules 35-42 constitute a centralized load distribution architecture where the primary orchestration module 35 demonstrates comprehensive operational conflicts with all subordinate worker modules 36,37,38,39,40,41,42 due to centralized resource allocation monopolization. Service modules 43-49 implement a security processing pipeline where sequential modules cannot operate simultaneously due to shared authentication token management, creating a chain of cryptographic resource dependencies. Additionally, complex cross-cluster interference patterns exist between disparate subsystems representing sophisticated inter-system resource contention scenarios. The consortium's deployment optimization committee seeks to determine the optimal configuration of service modules that can be simultaneously activated within the unified infrastructure framework while maintaining complete operational coherence and avoiding all identified resource contention incompatibilities.",  
  "solution_format_description": "Print the following fields: - selected_services: services in the maximum independent set. - num_selected_services: number of services in the maximum independent set.",  
  "structured_data": {
    "num_services": 50,
    "conflict_pairs": [
      [0,1],[0,2],[0,3],[0,4],[0,5],[1,2],[1,3],[1,4],[1,5],[2,3],[2,4],[2,5],[3,4],[3,5],[4,5],
      [6,7],[6,8],[6,9],[6,10],[6,11],[6,12],[7,8],[7,9],[7,10],[7,11],[7,12],[8,9],[8,10],[8,11],[8,12],[9,10],[9,11],[9,12],[10,11],[10,12],[11,12],
      [13,14],[14,15],[15,16],[17,18],[18,19],[19,20],[21,22],[22,23],[23,24],
      [25,26],[25,27],[26,28],[26,29],[27,30],[27,31],[28,32],[28,33],[32,34],
      [35,36],[35,37],[35,38],[35,39],[35,40],[35,41],[35,42],
      [43,44],[43,45],[43,46],[43,47],[43,48],[43,49],[44,45],[44,46],[44,47],[44,48],[44,49],[45,46],[45,47],[45,48],[45,49],[46,47],[46,48],[46,49],[47,48],[47,49],[48,49]
    ]
  },
  "reference_solution": {
    "selected_services": [0, 6, 13, 16, 17, 20, 21, 24, 25, 29, 30, 31, 33, 34, 36, 37, 38, 39, 40, 41, 42, 43],
    "num_selected_services": 22
  },
  "solver_code": "from cpmpy import *\nimport json\n\nnum_services = 50\nconflict_pairs = [\n    [0,1],[0,2],[0,3],[0,4],[0,5],[1,2],[1,3],[1,4],[1,5],[2,3],[2,4],[2,5],[3,4],[3,5],[4,5],\n    [6,7],[6,8],[6,9],[6,10],[6,11],[6,12],[7,8],[7,9],[7,10],[7,11],[7,12],[8,9],[8,10],[8,11],[8,12],[9,10],[9,11],[9,12],[10,11],[10,12],[11,12],\n    [13,14],[13,15],[13,16],[14,15],[14,16],[15,16],\n    [17,18],[17,19],[17,20],[18,19],[18,20],[19,20],\n    [21,22],[21,23],[21,24],[22,23],[22,24],[23,24],\n    [25,26],[25,27],[26,28],[26,29],[27,30],[27,31],[28,32],[28,33],[32,34],\n    [35,36],[35,37],[35,38],[35,39],[35,40],[35,41],[35,42],[36,37],[36,38],[36,39],[36,40],[36,41],[36,42],[37,38],[37,39],[37,40],[37,41],[37,42],[38,39],[38,40],[38,41],[38,42],[39,40],[39,41],[39,42],[40,41],[40,42],[41,42],\n    [43,44],[43,45],[43,46],[43,47],[43,48],[43,49],[44,45],[44,46],[44,47],[44,48],[44,49],[45,46],[45,47],[45,48],[45,49],[46,47],[46,48],[46,49],[47,48],[47,49],[48,49],\n    [2,8],[4,10],[7,15],[11,19],[16,26],[22,29],[31,37],[33,40],[39,44],[41,47],[1,18],[9,28],[20,36],[30,45],[14,48],[13,17],[14,18],[15,19],[16,20],[17,21],[18,22],[19,23],[20,24],[26,30],[26,31],[27,28],[27,29],[28,30],[29,31],[0,13],[1,16],[3,20],[5,24],[0,35],[3,38],[5,41],[1,43],[4,46],[5,49],[6,25],[8,27],[12,31],[7,43],[10,45],[12,47],[13,35],[17,37],[21,40],[16,25],[20,30],[24,34],[26,36],[28,39],[31,42],[29,44],[32,48],[25,28],[25,29],[25,30],[25,31],[43,46],[45,48]\n]\n\nmodel = Model()\nx = boolvar(shape=num_services)\n\nfor edge in conflict_pairs:\n    u, v = edge[0], edge[1]\n    model += x[u] + x[v] <= 1\n\nmodel.maximize(sum(x[i] for i in range(num_services)))\n\nif model.solve():\n    selected_services = [i for i in range(num_services) if x[i].value()]\n    result = {\n        \"selected_services\": selected_services,\n        \"num_selected_services\": len(selected_services)\n    }\n    print(json.dumps(result))\nelse:\n    print(\"No solution found\")",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"selected_services\", \"num_selected_services\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        selected_services = solution[\"selected_services\"]\n        num_selected_services = solution[\"num_selected_services\"]\n        conflict_pairs = structured_data[\"conflict_pairs\"]\n        num_services = structured_data[\"num_services\"]\n        valid_services = set(range(num_services))\n        errors = []\n        \n        if not isinstance(selected_services, list):\n            errors.append(\"selected_services must be a list\")\n        \n        if num_selected_services != len(selected_services):\n            errors.append(f\"num_selected_services inconsistency: declared {num_selected_services}, actual {len(selected_services)}\")\n        \n        for service in selected_services:\n            if service not in valid_services:\n                errors.append(f\"Service {service} does not exist in problem\")\n        \n        if len(selected_services) != len(set(selected_services)):\n            errors.append(\"Duplicate services in selected_services\")\n        \n        edge_set = set()\n        for edge in conflict_pairs:\n            u, v = edge[0], edge[1]\n            edge_set.add((min(u, v), max(u, v)))\n        \n        for i in range(len(selected_services)):\n            for j in range(i + 1, len(selected_services)):\n                u, v = selected_services[i], selected_services[j]\n                if (min(u, v), max(u, v)) in edge_set:\n                    errors.append(f\"Independence constraint violated: conflict exists between services {u} and {v}\")\n        \n        if len(errors) > 0:\n            return {\n                \"is_valid\": False,\n                \"validation_errors\": errors,\n                \"optimality_score\": 0.0\n            }\n        \n        optimal_size = reference_solution[\"num_selected_services\"]\n        if optimal_size == 0:\n            optimality_score = 1.0 if num_selected_services == 0 else 0.0\n        else:\n            gap = abs(optimal_size - num_selected_services) / abs(optimal_size)\n            optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": True,\n            \"validation_errors\": [],\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}