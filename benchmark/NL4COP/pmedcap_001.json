{
  "problem_id": "pmedcap_001",
  "metadata": {
    "problem_type": "Capacitated P-Median Problem",
    "difficulty": "simple"
  },
  "problem_description": "An advanced municipal logistics optimization framework requires strategic deployment of three emergency supply depots across a heterogeneous urban landscape to establish optimal resource allocation networks that minimize total transportation distance in kilometers while adhering to stringent capacity utilization constraints and spatial efficiency parameters. The coordinate system uses the city center as the origin with all distances measured in kilometers from this central reference location. Each distribution hub can handle a maximum of twenty-five pallets per day. Every residential zone exhibits unique consumption patterns requiring specialized resource allocation ranging from two to nine pallets per day, necessitating precise assignment optimization to ensure balanced operational efficiency. Geospatial distribution characteristics and consumption profiles include: Neighborhood Alpha is located five kilometers east and fifteen kilometers north from city center and requires four pallets daily; Neighborhood Beta is situated twenty-five kilometers east and five kilometers north from city center and requires six pallets; Neighborhood Gamma is positioned ten kilometers east and thirty kilometers north from city center and requires seven pallets; Neighborhood Delta is located forty kilometers east and twenty kilometers north from city center and requires five pallets; Neighborhood Epsilon is situated fifty-five kilometers east and fifty kilometers north from city center and requires eight pallets; Neighborhood Zeta is positioned thirty-five kilometers east and sixty-five kilometers north from city center and requires three pallets; Neighborhood Eta is located seventy kilometers east and forty-five kilometers north from city center and requires nine pallets; Neighborhood Theta is situated eighty-five kilometers east and eighty kilometers north from city center and requires two pallets; Neighborhood Iota is positioned sixty kilometers east and ninety kilometers north from city center and requires six pallets; and Neighborhood Kappa is located ninety-five kilometers east and ten kilometers north from city center and requires four pallets. Each distribution depot must be co-located with an existing neighborhood and can provide comprehensive logistical support to multiple neighborhoods as long as cumulative demand remains within the established capacity envelope of twenty-five pallets per day.",
  "solution_format_description": "Print the following fields: - total_cost: total transportation distance. - depot_locations: selected depot locations. - service_allocations: assigned depot for each community.",
  "structured_data": {
    "depot_count": 3,
    "daily_capacity": 25,
    "community_data": [
      [5, 15, 4],
      [25, 5, 6],
      [10, 30, 7],
      [40, 20, 5],
      [55, 50, 8],
      [35, 65, 3],
      [70, 45, 9],
      [85, 80, 2],
      [60, 90, 6],
      [95, 10, 4]
    ]
  },
  "reference_solution": {
    "total_cost": 193.8328,
    "depot_locations": [2, 7, 9],
    "service_allocations": [1, 1, 1, 1, 2, 3, 2, 3, 3, 2]
  },
  "solver_code": "from cpmpy import *\nimport json\nimport math\n\ndepot_count = 3\ndaily_capacity = 25\ncommunity_data = [\n    [5, 15, 4],\n    [25, 5, 6],\n    [10, 30, 7],\n    [40, 20, 5],\n    [55, 50, 8],\n    [35, 65, 3],\n    [70, 45, 9],\n    [85, 80, 2],\n    [60, 90, 6],\n    [95, 10, 4]\n]\n\nn_communities = len(community_data)\ndemands = [community_data[i][2] for i in range(n_communities)]\ncoordinates = [(community_data[i][0], community_data[i][1]) for i in range(n_communities)]\n\nmodel = Model()\n\nis_depot = boolvar(shape=n_communities)\nassign = boolvar(shape=(n_communities, n_communities))\n\nmodel += sum(is_depot) == depot_count\n\nfor i in range(n_communities):\n    model += sum(assign[i, j] for j in range(n_communities)) == 1\n\nfor i in range(n_communities):\n    for j in range(n_communities):\n        model += assign[i, j] <= is_depot[j]\n\nfor j in range(n_communities):\n    total_demand_to_j = sum(demands[i] * assign[i, j] for i in range(n_communities))\n    model += total_demand_to_j <= daily_capacity * is_depot[j]\n\ndistance_matrix = {}\nfor i in range(n_communities):\n    for j in range(n_communities):\n        xi, yi = coordinates[i]\n        xj, yj = coordinates[j]\n        dist = math.sqrt((xi - xj)**2 + (yi - yj)**2)\n        distance_matrix[(i, j)] = dist\n\ntotal_cost = sum(distance_matrix[(i, j)] * assign[i, j] \n                 for i in range(n_communities) for j in range(n_communities))\nmodel.minimize(total_cost)\n\nif model.solve():\n    depot_locations = [j+1 for j in range(n_communities) if is_depot[j].value()]\n    \n    service_allocations = []\n    for i in range(n_communities):\n        assigned_depot = None\n        for j in range(n_communities):\n            if assign[i, j].value() == 1:\n                assigned_depot = j\n                break\n        depot_idx = depot_locations.index(assigned_depot + 1) + 1\n        service_allocations.append(depot_idx)\n    \n    result = {\n        \"total_cost\": round(model.objective_value(), 4),\n        \"depot_locations\": depot_locations,\n        \"service_allocations\": service_allocations\n    }\n    print(json.dumps(result, indent=2))\nelse:\n    print(\"No solution found.\")",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"total_cost\", \"depot_locations\", \"service_allocations\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        total_cost = solution[\"total_cost\"]\n        depot_locations = solution[\"depot_locations\"]\n        service_allocations = solution[\"service_allocations\"]\n        \n        depot_count = structured_data[\"depot_count\"]\n        daily_capacity = structured_data[\"daily_capacity\"]\n        community_data = structured_data[\"community_data\"]\n        \n        errors = []\n        \n        if len(depot_locations) != depot_count:\n            errors.append(f\"Must select exactly {depot_count} depot locations, got {len(depot_locations)}\")\n        \n        for depot in depot_locations:\n            if depot < 0 or depot >= len(community_data):\n                errors.append(f\"Invalid depot location {depot}, must be between 0 and {len(community_data)-1}\")\n        \n        if len(service_allocations) != len(community_data):\n            errors.append(f\"Must assign all {len(community_data)} communities, got {len(service_allocations)}\")\n        \n        for i, depot in enumerate(service_allocations):\n            if depot < 0 or depot >= len(community_data):\n                errors.append(f\"Invalid depot assignment {depot} for community {i}, must be between 0 and {len(community_data)-1}\")\n        \n        depot_loads = {}\n        for i, depot in enumerate(service_allocations):\n            if depot not in depot_loads:\n                depot_loads[depot] = 0\n            depot_loads[depot] += community_data[i][2]\n        \n        for depot, load in depot_loads.items():\n            if load > daily_capacity:\n                errors.append(f\"Depot {depot} exceeds capacity: {load} > {daily_capacity}\")\n        \n        if len(errors) > 0:\n            return {\n                \"is_valid\": False,\n                \"validation_errors\": errors,\n                \"optimality_score\": 0.0\n            }\n        \n        optimal_cost = reference_solution[\"total_cost\"]\n        if optimal_cost == 0:\n            optimality_score = 1.0 if total_cost == 0 else 0.0\n        else:\n            gap = abs(optimal_cost - total_cost) / abs(optimal_cost)\n            optimality_score = max(0, 1 - gap)\n            \n        return {\n            \"is_valid\": True,\n            \"validation_errors\": [],\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}