{
  "problem_id": "packing_unequal_rectangles_and_squares_001",
  "metadata": {
    "problem_type": "Packing unequal rectangles and squares",
    "difficulty": "simple"
  },
  "problem_description": "A prestigious landscape architecture firm has been commissioned by the municipal parks department to design an innovative circular botanical garden spanning 4.18 meters in radius, with its geometric center precisely positioned at coordinate (4.18, 4.18) within the comprehensive site development plan. The project represents a significant urban renewal initiative, requiring the strategic placement of ten distinct garden installations that serve both aesthetic and functional purposes. The client's primary design mandate emphasizes maximizing the quantity of installations that can be successfully accommodated while maintaining optimal spatial relationships and circulation patterns. Each installation's placement is determined by precise centroid coordinate positioning and may incorporate orthogonal orientation adjustments in 90-degree increments to achieve superior spatial integration and visual harmony. The design constraints are rigorous: every positioned installation must remain entirely within the circular boundary, ensuring all perimeter points are contained within or coincident with the garden's perimeter curve, while the spatial footprints of any two installations cannot intersect, overlap, or violate minimum clearance requirements. The comprehensive installation catalog includes the following dimensional specifications: Installation Alpha measures 1.0 by 1.0 meters; Installation Beta extends 1.2 by 0.8 meters; Installation Gamma covers 0.9 by 1.1 meters; Installation Delta spans 1.1 by 1.3 meters; Installation Epsilon occupies 1.4 by 1.2 meters; Installation Zeta encompasses 1.5 by 1.5 meters; Installation Eta provides 1.0 by 1.0 meters; Installation Theta measures 1.6 by 1.6 meters; Installation Iota extends 1.3 by 1.3 meters; and Installation Kappa covers 1.4 by 1.4 meters.",
  "solution_format_description": "Print the following fields: - placements: for each installation, list placement with x, y, rotation angle. - total_count: total number of placed installations.",  
  "structured_data": {
    "garden_radius": 4.18,
    "garden_center": [4.18, 4.18],
    "installations": [
      [1.0, 1.0],
      [1.2, 0.8],
      [0.9, 1.1],
      [1.1, 1.3],
      [1.4, 1.2],
      [1.5, 1.5],
      [1.0, 1.0],
      [1.6, 1.6],
      [1.3, 1.3],
      [1.4, 1.4]
    ]
  },
  "reference_solution": {
    "placements": [
      [0.6, 2.56, 0], 
      [2.49, 0.36, 0], 
      [4.0, 3.56, 90], 
      [4.0, 0.3, 90], 
      [5.93, 5.16, 90], 
      [2.2, 4.18, 0], 
      [1.6, 1.4, 0], 
      [1.62, 5.88, 0], 
      [6.76, 3.5, 0], 
      [2.6, 1.16, 0]
    ], 
    "total_count": 10
  },
  "solver_code": "from cpmpy import *\nimport json\n\ngarden_radius = 4.18\ngarden_center = [4.18, 4.18]\ninstallations = [\n    [1.0, 1.0],\n    [1.2, 0.8],\n    [0.9, 1.1],\n    [1.1, 1.3],\n    [1.4, 1.2],\n    [1.5, 1.5],\n    [1.0, 1.0],\n    [1.6, 1.6],\n    [1.3, 1.3],\n    [1.4, 1.4]\n]\n\nn = len(installations)\nscale = 100\n\nr = int(garden_radius * scale)\ncx, cy = int(garden_center[0] * scale), int(garden_center[1] * scale)\n\ninstallations_scaled = [[int(l * scale), int(w * scale)] for l, w in installations]\n\nplaced = boolvar(shape=n)\nx = intvar(-scale, 2 * cx + scale, shape=n)\ny = intvar(-scale, 2 * cy + scale, shape=n)\nrotated = boolvar(shape=n)\n\nmodel = Model()\n\nfor i in range(n):\n    model += (placed[i] == 0).implies((x[i] == -scale) & (y[i] == -scale))\n\nwidths = []\nheights = []\nfor i in range(n):\n    w, h = installations_scaled[i]\n    widths.append(intvar(min(w, h), max(w, h), name=f\"width_{i}\"))\n    heights.append(intvar(min(w, h), max(w, h), name=f\"height_{i}\"))\n    \n    model += (rotated[i] == 0).implies(widths[i] == w)\n    model += (rotated[i] == 0).implies(heights[i] == h)\n    model += (rotated[i] == 1).implies(widths[i] == h)\n    model += (rotated[i] == 1).implies(heights[i] == w)\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        no_overlap = ((x[i] + widths[i] <= x[j]) | \n                     (x[j] + widths[j] <= x[i]) | \n                     (y[i] + heights[i] <= y[j]) | \n                     (y[j] + heights[j] <= y[i]))\n        \n        model += (placed[i] & placed[j]).implies(no_overlap)\n\nfor i in range(n):\n    corners = [\n        (x[i], y[i]),                    \n        (x[i] + widths[i], y[i]),        \n        (x[i], y[i] + heights[i]),        \n        (x[i] + widths[i], y[i] + heights[i])  \n    ]\n    \n    for corner_x, corner_y in corners:\n        dx = corner_x - cx\n        dy = corner_y - cy\n        model += (placed[i] == 1).implies(dx * dx + dy * dy <= r * r)\n\nmodel.maximize(sum(placed[i] for i in range(n)))\n\nif model.solve():\n    placements = []\n    total_count = 0\n    for i in range(n):\n        if placed[i].value():\n            center_x = x[i].value() / scale\n            center_y = y[i].value() / scale\n            theta = 90 if rotated[i].value() else 0\n            placements.append([round(center_x, 2), round(center_y, 2), theta])\n            total_count += 1\n        else:\n            placements.append([-1, -1, 0])\n    \n    result = {\"placements\": placements, \"total_count\": total_count}\n    print(json.dumps(result))\nelse:\n    print(json.dumps({\"placements\": [], \"total_count\": 0}))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    import math\n\n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n\n    required_fields = [\"placements\", \"total_area\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n\n    try:\n        placements = solution[\"placements\"]\n        installations = structured_data[\"installations\"]\n        garden_cx = structured_data[\"garden_center\"][0]\n        garden_cy = structured_data[\"garden_center\"][1]\n        garden_R = structured_data[\"garden_radius\"]\n        \n        errors = []\n        tol = 1e-5\n\n        if not isinstance(placements, list) or len(placements) != len(installations):\n            errors.append(f\"Array length mismatch: expected {len(installations)}, got {len(placements)}\")\n            return {\"is_valid\": False, \"validation_errors\": errors, \"optimality_score\": 0.0}\n\n        placed_items = []\n\n        for idx, placement in enumerate(placements):\n            if not isinstance(placement, list) or len(placement) != 3:\n                errors.append(f\"Placement {idx} must be a list of [x, y, theta].\")\n                continue\n            \n            x, y, theta = placement\n\n            if x == -1 and y == -1:\n                continue\n\n            if not (math.isclose(theta, 0, abs_tol=1e-3) or math.isclose(theta, 90, abs_tol=1e-3)):\n                errors.append(f\"Installation {idx}: rotation angle must be 0 or 90 degrees.\")\n\n            L, W = installations[idx]\n\n            if math.isclose(theta, 90, abs_tol=1e-3):\n                eff_L, eff_W = W, L\n            else:\n                eff_L, eff_W = L, W\n\n            if not (isinstance(x, (int, float)) and isinstance(y, (int, float))):\n                 errors.append(f\"Installation {idx}: coordinates must be numbers.\")\n                 continue\n            \n            corners = [\n                (x - eff_L/2, y - eff_W/2),\n                (x + eff_L/2, y - eff_W/2),\n                (x - eff_L/2, y + eff_W/2),\n                (x + eff_L/2, y + eff_W/2)\n            ]\n            \n            for corner_x, corner_y in corners:\n                dist = math.hypot(corner_x - garden_cx, corner_y - garden_cy)\n                if dist > garden_R + tol:\n                    errors.append(f\"Installation {idx}: corner ({corner_x:.2f}, {corner_y:.2f}) lies outside the circular boundary.\")\n\n            xmin = x - eff_L / 2.0\n            ymin = y - eff_W / 2.0\n            xmax = xmin + eff_L\n            ymax = ymin + eff_W\n            \n            current_rect = (xmin, xmax, ymin, ymax, idx)\n\n            for other_rect in placed_items:\n                oxmin, oxmax, oymin, oymax, oidx = other_rect\n                \n                if not (xmax <= oxmin + tol or xmin >= oxmax - tol or\n                        ymax <= oymin + tol or ymin >= oymax - tol):\n                    errors.append(f\"Installation {idx} overlaps with installation {oidx}.\")\n\n            placed_items.append(current_rect)\n\n        is_solution_valid = (len(errors) == 0)\n        \n        if not is_solution_valid:\n            return {\n                \"is_valid\": False,\n                \"validation_errors\": errors,\n                \"optimality_score\": 0.0\n            }\n        else:\n            total_area = solution[\"total_area\"]\n            optimal_area = reference_solution[\"total_area\"]\n            if optimal_area == 0:\n                optimality_score = 1.0 if total_area == 0 else 0.0\n            else:\n                gap = abs(optimal_area - total_area) / abs(optimal_area)\n                optimality_score = max(0, 1 - gap)\n\n            return {\n                \"is_valid\": True,\n                \"validation_errors\": [],\n                \"optimality_score\": optimality_score\n            }\n\n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}