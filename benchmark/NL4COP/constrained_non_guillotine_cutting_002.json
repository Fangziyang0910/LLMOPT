{
  "problem_id": "constrained_non_guillotine_cutting_002",
  "metadata": {
    "problem_type": "Constrained Non-Guillotine Cutting Problem",
    "difficulty": "medium"
  },
  "problem_description": "Emma is furnishing her new 10x10 meter studio apartment and needs to arrange different furniture pieces to maximize living comfort and functionality. She has the following furniture items available: 1. Furniture Type 1 (Large bookshelf): 3x3 meters, comfort value 35 points (must include exactly 1, no more and no less) 2. Furniture Type 2 (Long sofa): 4x2 meters, comfort value 40 points (optional, up to 1 can be placed) 3. Furniture Type 3 (Wide media console): 2x2 meters, comfort value 27 points (optional, up to 1 can be placed) 4. Furniture Type 4 (Medium dining table): 3x2 meters, comfort value 23 points (optional, up to 1 can be placed) 5. Furniture Type 5 (Tall storage cabinet): 2x3 meters, comfort value 43 points (optional, up to 1 can be placed) Each furniture piece can be placed either in its original orientation or rotated by 90 degrees. All furniture must be placed completely within the apartment boundaries and cannot overlap with each other. Emma wants to know how to arrange these furniture pieces to achieve the maximum total comfort value while making the best use of her available space.",
  "solution_format_description": "Print the following fields: - total_comfort_value: total comfort value of placed furniture. - placements: for each furniture, list placements with piece type, x, y, rotation.",
  "structured_data": {
    "container_dimensions": [10, 10],
    "item_inventory": [
      [3, 3, 1, 1, 35],
      [4, 2, 0, 1, 40],
      [2, 2, 0, 1, 27],
      [3, 2, 0, 1, 23],
      [2, 3, 0, 1, 43]
    ]
  },
  "reference_solution": {
    "total_comfort_value": 168,
    "placements": [
      [2, 3, 6, 0],
      [5, 5, 2, 1],
      [3, 3, 3, 0],
      [1, 1, 0, 1],
      [4, 0, 4, 0]
    ]
  },
  "solver_code": "from cpmpy import *\nimport json\n\ncontainer_dimensions = [10, 10]\nitem_inventory = [\n    [3, 3, 1, 1, 35],\n    [4, 2, 0, 1, 40],\n    [2, 2, 0, 1, 27],\n    [3, 2, 0, 1, 23],\n    [2, 3, 0, 1, 43]\n]\n\ncontainer_length, container_width = container_dimensions\n\nmax_placements = sum(item[3] for item in item_inventory)\nmodel = Model()\n\npiece_types = intvar(1, len(item_inventory), shape=max_placements)\nx_coords = intvar(0, container_length, shape=max_placements)\ny_coords = intvar(0, container_width, shape=max_placements)\nrotations = boolvar(shape=max_placements)\nis_used = boolvar(shape=max_placements)\n\nfor idx in range(len(item_inventory)):\n    type_count = 0\n    for i in range(max_placements):\n        type_count += is_used[i] * (piece_types[i] == idx + 1)\n    model += type_count >= item_inventory[idx][2]\n    model += type_count <= item_inventory[idx][3]\n\nfor i in range(max_placements):\n    for t in range(len(item_inventory)):\n        item = item_inventory[t]\n        length = item[0]\n        width = item[1]\n        \n        M = max(container_length, container_width)\n        type_match = (piece_types[i] == t + 1)\n        \n        len_i = rotations[i] * width + (1 - rotations[i]) * length\n        wid_i = rotations[i] * length + (1 - rotations[i]) * width\n        \n        model += x_coords[i] + len_i <= container_length + M * (2 - is_used[i] - type_match)\n        model += y_coords[i] + wid_i <= container_width + M * (2 - is_used[i] - type_match)\n\nfor i in range(max_placements):\n    for j in range(i + 1, max_placements):\n        for t1 in range(len(item_inventory)):\n            for t2 in range(len(item_inventory)):\n                item1 = item_inventory[t1]\n                item2 = item_inventory[t2]\n                \n                len_i = rotations[i] * item1[1] + (1 - rotations[i]) * item1[0]\n                wid_i = rotations[i] * item1[0] + (1 - rotations[i]) * item1[1]\n                len_j = rotations[j] * item2[1] + (1 - rotations[j]) * item2[0]\n                wid_j = rotations[j] * item2[0] + (1 - rotations[j]) * item2[1]\n                \n                left = x_coords[i] + len_i <= x_coords[j]\n                right = x_coords[j] + len_j <= x_coords[i]\n                below = y_coords[i] + wid_i <= y_coords[j]\n                above = y_coords[j] + wid_j <= y_coords[i]\n                \n                type1_match = (piece_types[i] == t1 + 1)\n                type2_match = (piece_types[j] == t2 + 1)\n                both_used = is_used[i] * is_used[j] * type1_match * type2_match\n                \n                M2 = 1\n                model += left + right + below + above >= M2 * both_used\n\ntotal_comfort = 0\nfor i in range(max_placements):\n    for t in range(len(item_inventory)):\n        total_comfort += is_used[i] * (piece_types[i] == t + 1) * item_inventory[t][4]\n\nmodel.maximize(total_comfort)\n\nif model.solve():\n    placements = []\n    total_comfort_value = 0\n    \n    for i in range(max_placements):\n        if is_used[i].value():\n            piece_type = piece_types[i].value()\n            x = x_coords[i].value()\n            y = y_coords[i].value()\n            r = int(rotations[i].value())\n            placements.append([piece_type, x, y, r])\n            total_comfort_value += item_inventory[piece_type - 1][4]\n    \n    result = {\n        \"total_comfort_value\": total_comfort_value,\n        \"placements\": placements\n    }\n    print(json.dumps(result))\nelse:\n    print(json.dumps({\"total_comfort_value\": 0, \"placements\": []}))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"total_comfort_value\", \"placements\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        total_comfort_value = solution[\"total_comfort_value\"]\n        placements = solution[\"placements\"]\n        apartment_length = structured_data[\"apartment_length\"]\n        apartment_width = structured_data[\"apartment_width\"]\n        furniture_items = structured_data[\"furniture_items\"]\n        errors = []\n        \n        if not isinstance(placements, list):\n            errors.append(\"Placements must be a list\")\n            return {\"is_valid\": False, \"validation_errors\": errors, \"optimality_score\": 0.0}\n        \n        for idx, placement in enumerate(placements):\n            if not (isinstance(placement, (list, tuple)) and len(placement) == 4):\n                errors.append(f\"Placement at index {idx} is invalid; must be a 4-tuple\")\n                continue\n            \n            piece_type, x, y, r = placement\n            \n            if not all(isinstance(val, int) for val in (piece_type, x, y, r)):\n                errors.append(f\"All values in placement at index {idx} must be integers\")\n                continue\n            \n            if piece_type < 1 or piece_type > len(furniture_items):\n                errors.append(f\"Placement at index {idx} has an invalid piece_type {piece_type}\")\n                continue\n            \n            if r not in [0, 1]:\n                errors.append(f\"Placement at index {idx} has an invalid rotation flag {r}\")\n                continue\n        \n        if errors:\n            return {\"is_valid\": False, \"validation_errors\": errors, \"optimality_score\": 0.0}\n        \n        counts = [0] * len(furniture_items)\n        for placement in placements:\n            piece_type = placement[0]\n            counts[piece_type - 1] += 1\n        \n        for i, item in enumerate(furniture_items):\n            if counts[i] < item[\"min_required\"] or counts[i] > item[\"max_allowed\"]:\n                errors.append(f\"Furniture type {i + 1} count {counts[i]} does not meet constraints [min: {item['min_required']}, max: {item['max_allowed']}]\")\n        \n        rects = []\n        for idx, placement in enumerate(placements):\n            piece_type, x, y, r = placement\n            piece = furniture_items[piece_type - 1]\n            \n            if r == 0:\n                p_len = piece[\"length\"]\n                p_wid = piece[\"width\"]\n            elif r == 1:\n                p_len = piece[\"width\"]\n                p_wid = piece[\"length\"]\n            else:\n                errors.append(f\"Placement at index {idx} has an invalid rotation flag {r}\")\n                continue\n            \n            if x < 0 or y < 0 or (x + p_len) > apartment_length or (y + p_wid) > apartment_width:\n                errors.append(f\"Placement at index {idx} is out of stock boundaries\")\n                continue\n            \n            rects.append((x, y, x + p_len, y + p_wid))\n        \n        n = len(rects)\n        for i in range(n):\n            for j in range(i + 1, n):\n                a = rects[i]\n                b = rects[j]\n                if not (a[2] <= b[0] or b[2] <= a[0] or a[3] <= b[1] or b[3] <= a[1]):\n                    errors.append(f\"Placements at indices {i} and {j} overlap\")\n        \n        calculated_comfort = 0\n        for placement in placements:\n            piece_type = placement[0]\n            calculated_comfort += furniture_items[piece_type - 1][\"comfort_value\"]\n        \n        if abs(calculated_comfort - total_comfort_value) > 1e-6:\n            errors.append(f\"Comfort value inconsistency: calculated {calculated_comfort}, declared {total_comfort_value}\")\n        \n        optimal_value = reference_solution[\"total_comfort_value\"]\n        if optimal_value == 0:\n            optimality_score = 1.0 if total_comfort_value == 0 else 0.0\n        else:\n            gap = abs(optimal_value - total_comfort_value) / abs(optimal_value)\n            optimality_score = max(0, 1 - gap)\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}