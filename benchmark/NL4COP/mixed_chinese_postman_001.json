{
  "problem_id": "mixed_chinese_postman_001",
  "metadata": {
    "problem_type": "Mixed Chinese Postman Problem",
    "difficulty": "simple"
  },
  "problem_description": "A city's public works department needs to design an efficient inspection route for a mixed network of one-way and two-way streets in a downtown area with 7 key intersections. There are 8 street segments that require inspection, each with specific inspection and travel times. The inspection requirements are: 1. One-way street from intersection 0 to 1: 5 minutes inspection time, 3 minutes travel time 2. One-way street from intersection 1 to 2: 3 minutes inspection time, 2 minutes travel time 3. Two-way street between intersections 2 and 3: 7 minutes inspection time (total), 4 minutes travel time in either direction 4. One-way street from intersection 3 to 4: 2 minutes inspection time, 1 minute travel time 5. Two-way street between intersections 4 and 5: 4 minutes inspection time (total), 2 minutes travel time in either direction 6. One-way street from intersection 5 to 6: 6 minutes inspection time, 3 minutes travel time 7. Two-way street between intersections 6 and 0: 8 minutes inspection time (total), 5 minutes travel time in either direction 8. One-way street from intersection 1 to 5: 5 minutes inspection time, 3 minutes travel time. Important rules: For one-way streets, inspection must be done in the specified direction. For two-way streets, inspection can be completed in either direction (only one direction needs inspection). When a street segment is traversed for the first time in the inspection direction, both inspection time and travel time are incurred. Subsequent traversals of the same street segment incur only travel time. The inspection route must start and end at the depot intersection 0 and ensure all 8 street segments are inspected once. Streets can be traversed multiple times if needed for route connectivity. How should the inspection team plan the route to complete all inspection tasks in the minimum total time?",  
  "solution_format_description": "Print the following fields: - route: sequence of intersections visited. - total_cost: total inspection and travel time.",
  "structured_data": {
    "num_intersections": 7,
    "inspection_streets": [
      [0, 1, 5, 3, 0],
      [1, 2, 3, 2, 0],
      [2, 3, 7, 4, 1],
      [3, 4, 2, 1, 0],
      [4, 5, 4, 2, 1],
      [5, 6, 6, 3, 0],
      [6, 0, 8, 5, 1],
      [1, 5, 5, 3, 0]
    ]
  },
  "reference_solution": {
    "route": [0, 1, 5, 6, 0, 1, 2, 3, 4, 5, 6, 0], 
    "total_cost": 74
  },
  "solver_code": "",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"route\", \"total_cost\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        route = solution[\"route\"]\n        total_cost = solution[\"total_cost\"]\n        inspection_streets = structured_data[\"inspection_streets\"]\n        errors = []\n        \n        if not route or route[0] != 0 or route[-1] != 0:\n            errors.append(\"Route must start and end at depot intersection 0\")\n        \n        def is_connected(u, v):\n            for street in inspection_streets:\n                su, sv, _, _, bidirectional = street\n                if bidirectional == 0:\n                    if su == u and sv == v:\n                        return True\n                else:\n                    if (su == u and sv == v) or (su == v and sv == u):\n                        return True\n            return False\n        \n        for i in range(len(route) - 1):\n            u, v = route[i], route[i + 1]\n            if not is_connected(u, v):\n                errors.append(f\"Invalid path segment: {u} -> {v} (no direct connection)\")\n        \n        covered_streets = set()\n        \n        for i in range(len(route) - 1):\n            u, v = route[i], route[i + 1]\n            \n            for idx, street in enumerate(inspection_streets):\n                su, sv, _, _, bidirectional = street\n                \n                if bidirectional == 0:\n                    if su == u and sv == v:\n                        covered_streets.add(idx)\n                        break\n                else:\n                    if (su == u and sv == v) or (su == v and sv == u):\n                        covered_streets.add(idx)\n                        break\n        \n        if len(covered_streets) < len(inspection_streets):\n            missing_streets = set(range(len(inspection_streets))) - covered_streets\n            errors.append(f\"Missing inspection streets: {sorted(missing_streets)}\")\n        \n        if len(errors) == 0:\n            optimal_cost = reference_solution[\"total_cost\"]\n            if optimal_cost == 0:\n                optimality_score = 1.0 if total_cost == 0 else 0.0\n            else:\n                gap = abs(optimal_cost - total_cost) / abs(optimal_cost)\n                optimality_score = max(0, 1 - gap)\n        else:\n            optimality_score = 0.0\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}