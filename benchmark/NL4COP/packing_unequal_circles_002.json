{
  "problem_id": "packing_unequal_circles_002",
  "metadata": {
    "problem_type": "Packing Unequal Circles",
    "difficulty": "medium"
  },
  "problem_description": "In an urban spatial optimization project, authorities are redeveloping a circular green infrastructure zone with a 25-meter effective radius, positioned at coordinates (25, 25) in the central business district. The project involves deploying ten distinct urban service modules, each with specific spatial requirements: module 1 needs a 3-meter area for a pediatric recreational zone using evidence-based play therapy; module 2 requires a 7-meter space for a multi-disciplinary athletic facility supporting adaptive sports and community wellness; module 3 needs a 2-meter area for a mindfulness space incorporating biophilic design and stress reduction; module 4 requires a 12-meter area for a performing arts amphitheater with acoustic optimization; module 5 allocates a 5-meter zone for a canine behavioral facility using positive reinforcement protocols; module 6 needs an 11-meter footprint for a civic engagement platform supporting community events and participatory governance; module 7 requires a 4-meter area for an outdoor therapeutic fitness zone with evidence-based exercise programming; module 8 specifies an 8-meter space for a communal dining facility supporting diverse culinary traditions; module 9 needs a 6-meter area for an extreme sports zone with advanced safety engineering; and module 10 requires a 10-meter footprint for an ethnobotanical garden implementing native species propagation. Each module must be completely contained within the circular boundary and maintain adequate buffer zones to prevent functional interference and ensure optimal user experience. The planners seek to determine the maximum number of modules that can be deployed while maintaining ecological capacity and urban sustainability standards.",
  "solution_format_description": "Print the following fields: - deployed: deployment status for each module. - locations: for each module, list coordinates with x, y. - num_deployed: total number of deployed modules.",
  "structured_data": {
    "zone": [25, 25, 25],
    "module_footprints": [3, 7, 2, 12, 5, 11, 4, 8, 6, 10]
  },
  "reference_solution": {
    "deployed": [1, 1, 1, 0, 1, 1, 1, 1, 1, 1],
    "locations": [[3, 25], [11, 15], [10, 24], [-1, -1], [25, 5], [17, 35], [34, 8], [26, 18], [40, 16], [38, 32]],
    "num_deployed": 9
  },
  "solver_code": "from cpmpy import *\nimport json\n\ncx, cy = 25, 25\nR = 25\nradii = [3, 7, 2, 12, 5, 11, 4, 8, 6, 10]\nn = len(radii)\n\nalpha = boolvar(shape=n)\nx = intvar(-R, 2 * R, shape=n)\ny = intvar(-R, 2 * R, shape=n)\n\nmodel = Model()\n\nfor i in range(n):\n    model += (alpha[i] == 0).implies(x[i] == -R)\n    model += (alpha[i] == 0).implies(y[i] == -R)\n\nfor i in range(n):\n    r = radii[i]\n    if (R - r) < 0:\n        model += alpha[i] == 0\n    else:\n        rhs_sq = (R - r) ** 2\n        dist_sq = (x[i] - cx)**2 + (y[i] - cy)**2\n        model += alpha[i].implies(dist_sq <= rhs_sq)\n\nM = 4 * R * R\nfor i in range(n):\n    for j in range(i + 1, n):\n        r_i, r_j = radii[i], radii[j]\n        rhs_sq = (r_i + r_j) ** 2\n        dist_sq = (x[i] - x[j])**2 + (y[i] - y[j])**2\n        model += dist_sq >= rhs_sq - M * (2 - alpha[i] - alpha[j])\n\nmodel.maximize(sum(alpha))\n\nif model.solve():\n    deployed = [int(alpha[i].value()) for i in range(n)]\n    locations = [(int(x[i].value()), int(y[i].value())) if deployed[i] else (-1, -1) for i in range(n)]\n    num_deployed = sum(deployed)\n    \n    result = {\n        \"deployed\": deployed,\n        \"locations\": locations,\n        \"num_deployed\": num_deployed\n    }\n    print(json.dumps(result))\nelse:\n    print(\"No solution found.\")",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    import math\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"deployed\", \"locations\", \"num_deployed\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        deployed = solution[\"deployed\"]\n        locations = solution[\"locations\"]\n        num_deployed = solution[\"num_deployed\"]\n        errors = []\n        \n        cx, cy, container_R = structured_data[\"zone\"]\n        radii = structured_data[\"module_footprints\"]\n        n = len(radii)\n        \n        for i in range(n):\n            if deployed[i] == 1:\n                x, y = locations[i]\n                r = radii[i]\n                dist = math.sqrt((x - cx)**2 + (y - cy)**2)\n                if dist > container_R - r:\n                    errors.append(f\"Module {i+1} exceeds zone boundary\")\n        \n        for i in range(n):\n            if deployed[i] == 1:\n                for j in range(i + 1, n):\n                    if deployed[j] == 1:\n                        x1, y1 = locations[i]\n                        x2, y2 = locations[j]\n                        r1, r2 = radii[i], radii[j]\n                        dist = math.sqrt((x1 - x2)**2 + (y1 - y2)**2)\n                        if dist < r1 + r2:\n                            errors.append(f\"Modules {i+1} and {j+1} overlap\")\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_value = reference_solution[\"num_deployed\"]\n            if optimal_value == 0:\n                optimality_score = 1.0 if num_deployed == 0 else 0.0\n            else:\n                gap = abs(optimal_value - num_deployed) / abs(optimal_value)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}