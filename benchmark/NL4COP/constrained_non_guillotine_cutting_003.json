{
  "problem_id": "constrained_non_guillotine_cutting_003",
  "metadata": {
    "problem_type": "Constrained Non-Guillotine Cutting Problem",
    "difficulty": "hard"
  },
  "problem_description": "Mike is organizing his storage room and needs to arrange various boxes on a 10x10 foot floor space. He has the following boxes to store:\n\n1. Box Type 1 (Long storage boxes): 5x2 feet, requires at least 1 but no more than 2, utility value 28 points\n2. Box Type 2 (Medium cubic boxes): 3x3 feet, can use up to 2, utility value 40 points\n3. Box Type 3 (Large square containers): 4x4 feet, can use up to 1, utility value 63 points\n4. Box Type 4 (Small organizing boxes): 2x2 feet, needs at least 1 but can use up to 4, utility value 13 points\n5. Box Type 5 (Standard rectangular boxes): 3x2 feet, can use up to 2, utility value 31 points\n6. Box Type 6 (Flat storage boxes): 4x1 feet, can use up to 1, utility value 10 points\n7. Box Type 7 (Medium storage bins): 4x3 feet, can use up to 1, utility value 44 points\n\nEach box can be placed either in its original orientation or rotated by 90 degrees. All boxes must be placed completely within the 10x10 foot floor space and cannot overlap with each other. Mike wants to know how to arrange these boxes to achieve the maximum total utility value while making the most efficient use of his available storage space.",
  "solution_format_description": "Print the following fields: - total_utility_value: total utility value of placed boxes. - box_placements: for each box, list placements with box type, x, y, rotation.",
  "structured_data": {
    "container_dimensions": [10, 10],
    "item_inventory": [
      [5, 2, 1, 2, 28],
      [3, 3, 0, 2, 40],
      [4, 4, 0, 1, 63],
      [2, 2, 1, 4, 13],
      [3, 2, 0, 2, 31],
      [4, 1, 0, 1, 10],
      [4, 3, 0, 1, 44]
    ]
  },
  "reference_solution": {
    "total_utility_value": 367, 
    "box_placements": [
      [3, 2, 4, 0], [6, 3, 0, 0], [7, 6, 2, 0], [2, 3, 1, 0], [5, 6, 5, 1], 
      [5, 7, 0, 0], [2, 0, 0, 0], [4, 4, 8, 0], [1, 8, 5, 1], [4, 6, 8, 0], 
      [4, 2, 8, 0], [1, 0, 3, 1], [4, 0, 8, 0]
    ]
  },
  "solver_code": "from cpmpy import *\nimport json\n\ncontainer_dimensions = [10, 10]\nitem_inventory = [\n    [5, 2, 1, 2, 28],\n    [3, 3, 0, 2, 40],\n    [4, 4, 0, 1, 63],\n    [2, 2, 1, 4, 13],\n    [3, 2, 0, 2, 31],\n    [4, 1, 0, 1, 10],\n    [4, 3, 0, 1, 44]\n]\n\ncontainer_length, container_width = container_dimensions\n\nmax_placements = sum(item[3] for item in item_inventory)\n\nmodel = Model()\n\nbox_types = intvar(1, len(item_inventory), shape=max_placements)\nx_coords = intvar(0, container_length, shape=max_placements)\ny_coords = intvar(0, container_width, shape=max_placements)\nrotations = boolvar(shape=max_placements)\nis_used = boolvar(shape=max_placements)\n\nfor idx in range(len(item_inventory)):\n    type_count = 0\n    for i in range(max_placements):\n        type_count += is_used[i] * (box_types[i] == idx + 1)\n    model += type_count >= item_inventory[idx][2]\n    model += type_count <= item_inventory[idx][3]\n\nfor i in range(max_placements):\n    for t in range(len(item_inventory)):\n        item = item_inventory[t]\n        length = item[0]\n        width = item[1]\n        \n        M = max(container_length, container_width)\n        type_match = (box_types[i] == t + 1)\n        \n        len_i = rotations[i] * width + (1 - rotations[i]) * length\n        wid_i = rotations[i] * length + (1 - rotations[i]) * width\n        \n        model += x_coords[i] + len_i <= container_length + M * (2 - is_used[i] - type_match)\n        model += y_coords[i] + wid_i <= container_width + M * (2 - is_used[i] - type_match)\n\nfor i in range(max_placements):\n    for j in range(i + 1, max_placements):\n        both_used = is_used[i] & is_used[j]\n        \n        len_i, wid_i = 0, 0\n        len_j, wid_j = 0, 0\n        \n        for t in range(len(item_inventory)):\n            item = item_inventory[t]\n            length, width = item[0], item[1]\n            \n            type_match_i = (box_types[i] == t + 1)\n            len_i += type_match_i * (rotations[i] * width + (1 - rotations[i]) * length)\n            wid_i += type_match_i * (rotations[i] * length + (1 - rotations[i]) * width)\n            \n            type_match_j = (box_types[j] == t + 1)\n            len_j += type_match_j * (rotations[j] * width + (1 - rotations[j]) * length)\n            wid_j += type_match_j * (rotations[j] * length + (1 - rotations[j]) * width)\n        \n        M = max(container_length, container_width)\n        no_overlap = (\n            (x_coords[i] + len_i <= x_coords[j]) |\n            (x_coords[j] + len_j <= x_coords[i]) |\n            (y_coords[i] + wid_i <= y_coords[j]) |\n            (y_coords[j] + wid_j <= y_coords[i])\n        )\n        \n        model += no_overlap | (~both_used)\n\ntotal_utility_value = 0\nfor i in range(max_placements):\n    for t in range(len(item_inventory)):\n        item_value = item_inventory[t][4]\n        type_match = (box_types[i] == t + 1)\n        total_utility_value += type_match * is_used[i] * item_value\n\nmodel.maximize(total_utility_value)\n\nif model.solve():\n    box_placements = []\n    total_utility_value_actual = 0\n    \n    for i in range(max_placements):\n        if is_used[i].value():\n            box_type = box_types[i].value()\n            x = x_coords[i].value()\n            y = y_coords[i].value()\n            r = int(rotations[i].value())\n            box_placements.append([box_type, x, y, r])\n            total_utility_value_actual += item_inventory[box_type - 1][4]\n    \n    result = {\n        \"total_utility_value\": total_utility_value_actual,\n        \"box_placements\": box_placements\n    }\n    \n    print(json.dumps(result))\nelse:\n    print(json.dumps({\"total_utility_value\": 0, \"box_placements\": []}))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"total_utility_value\", \"box_placements\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        total_utility_value = solution[\"total_utility_value\"]\n        box_placements = solution[\"box_placements\"]\n        floor_length = structured_data[\"floor_length\"]\n        floor_width = structured_data[\"floor_width\"]\n        boxes = structured_data[\"boxes\"]\n        errors = []\n        \n        if not isinstance(box_placements, list):\n            errors.append(\"Box placements must be a list\")\n            return {\"is_valid\": False, \"validation_errors\": errors, \"optimality_score\": 0.0}\n        \n        rects = []\n        counts = [0] * len(boxes)\n        \n        for idx, placement in enumerate(box_placements):\n            if not (isinstance(placement, (list, tuple)) and len(placement) == 4):\n                errors.append(f\"Placement at index {idx} is invalid; must be a 4-tuple\")\n                continue\n            \n            box_type, x, y, r = placement\n            \n            if not all(isinstance(val, int) for val in (box_type, x, y, r)):\n                errors.append(f\"All values in placement at index {idx} must be integers\")\n                continue\n            \n            if box_type < 1 or box_type > len(boxes):\n                errors.append(f\"Placement at index {idx} has an invalid box_type {box_type}\")\n                continue\n            \n            box = boxes[box_type - 1]\n            \n            if r == 0:\n                p_len = box[\"length\"]\n                p_wid = box[\"width\"]\n            elif r == 1:\n                p_len = box[\"width\"]\n                p_wid = box[\"length\"]\n            else:\n                errors.append(f\"Placement at index {idx} has an invalid rotation flag {r}\")\n                continue\n            \n            if x < 0 or y < 0 or (x + p_len) > floor_length or (y + p_wid) > floor_width:\n                errors.append(f\"Placement at index {idx} is out of floor boundaries\")\n                continue\n            \n            rects.append((x, y, x + p_len, y + p_wid))\n            counts[box_type - 1] += 1\n        \n        n = len(rects)\n        for i in range(n):\n            for j in range(i + 1, n):\n                a = rects[i]\n                b = rects[j]\n                if not (a[2] <= b[0] or b[2] <= a[0] or a[3] <= b[1] or b[3] <= a[1]):\n                    errors.append(f\"Placements at indices {i} and {j} overlap\")\n        \n        for i, box in enumerate(boxes):\n            if counts[i] < box[\"min_required\"] or counts[i] > box[\"max_allowed\"]:\n                errors.append(f\"Box type {i + 1} count {counts[i]} does not meet constraints \"\n                             f\"[min: {box['min_required']}, max: {box['max_allowed']}]\")\n        \n        calculated_value = 0\n        for placement in box_placements:\n            if len(placement) == 4:\n                box_type, x, y, r = placement\n                if 1 <= box_type <= len(boxes):\n                    calculated_value += boxes[box_type - 1][\"utility_value\"]\n        \n        if abs(calculated_value - total_utility_value) > 1e-6:\n            errors.append(f\"Value inconsistency: calculated {calculated_value}, declared {total_utility_value}\")\n        \n        if len(errors) > 0:\n            return {\n                \"is_valid\": False,\n                \"validation_errors\": errors,\n                \"optimality_score\": 0.0\n            }\n        \n        if len(errors) > 0:\n            return {\n                \"is_valid\": False,\n                \"validation_errors\": errors,\n                \"optimality_score\": 0.0\n            }\n        \n        optimal_value = reference_solution[\"total_utility_value\"]\n        if optimal_value == 0:\n            optimality_score = 1.0 if total_utility_value == 0 else 0.0\n        else:\n            gap = abs(optimal_value - total_utility_value) / abs(optimal_value)\n            optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": True,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}