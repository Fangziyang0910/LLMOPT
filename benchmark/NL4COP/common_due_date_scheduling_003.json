{
  "problem_id": "common_due_date_scheduling_003",
  "metadata": {
    "problem_type": "Single Machine Common Due Date Scheduling Problem",
    "difficulty": "hard"
  },
  "problem_description": "A software development team is planning the sequence of 15 tasks for their next sprint on a single developer workstation. To balance client expectations and resource allocation, they have identified a target completion date, calculated as 60% of the total estimated effort for all tasks. Finishing significantly before this date might lead to idle time or scope creep (earliness penalty), while finishing after it would disappoint clients (tardiness penalty). Each task has a specific estimated effort and associated penalties for deviating from the target date. The team wants to determine the optimal order to execute these tasks to minimize the total penalty. The details of the 15 tasks are as follows:\n1. Task 1: Effort 2d, Early Penalty $1/d, Late Penalty $3/d\n2. Task 2: Effort 4d, Early Penalty $2/d, Late Penalty $2/d\n3. Task 3: Effort 3d, Early Penalty $3/d, Late Penalty $1/d\n4. Task 4: Effort 5d, Early Penalty $1/d, Late Penalty $2/d\n5. Task 5: Effort 2d, Early Penalty $2/d, Late Penalty $3/d\n6. Task 6: Effort 4d, Early Penalty $3/d, Late Penalty $1/d\n7. Task 7: Effort 3d, Early Penalty $1/d, Late Penalty $2/d\n8. Task 8: Effort 5d, Early Penalty $2/d, Late Penalty $1/d\n9. Task 9: Effort 2d, Early Penalty $3/d, Late Penalty $2/d\n10. Task 10: Effort 4d, Early Penalty $1/d, Late Penalty $3/d\n11. Task 11: Effort 3d, Early Penalty $2/d, Late Penalty $1/d\n12. Task 12: Effort 5d, Early Penalty $3/d, Late Penalty $2/d\n13. Task 13: Effort 2d, Early Penalty $1/d, Late Penalty $3/d\n14. Task 14: Effort 4d, Early Penalty $2/d, Late Penalty $1/d\n15. Task 15: Effort 3d, Early Penalty $3/d, Late Penalty $2/d",
  "solution_format_description": "Print the following fields: - task_sequence: optimal execution order for tasks. - total_cost: total penalty cost for the schedule.",
  "structured_data": {
    "tasks": [
      [2, 1, 3],
      [4, 2, 2],
      [3, 3, 1],
      [5, 1, 2],
      [2, 2, 3],
      [4, 3, 1],
      [3, 1, 2],
      [5, 2, 1],
      [2, 3, 2],
      [4, 1, 3],
      [3, 2, 1],
      [5, 3, 2],
      [2, 1, 3],
      [4, 2, 1],
      [3, 3, 2]
    ],
    "target_date_factor": 0.6
  },
  "reference_solution": {
    "task_sequence": [4, 10, 7, 2, 13, 1, 12, 15, 5, 9, 11, 3, 14, 6, 8],
    "total_cost": 205.8
  },
  "solver_code": "from cpmpy import *\nimport json\n\ntasks = [\n    [2, 1, 3],\n    [4, 2, 2],\n    [3, 3, 1],\n    [5, 1, 2],\n    [2, 2, 3],\n    [4, 3, 1],\n    [3, 1, 2],\n    [5, 2, 1],\n    [2, 3, 2],\n    [4, 1, 3],\n    [3, 2, 1],\n    [5, 3, 2],\n    [2, 1, 3],\n    [4, 2, 1],\n    [3, 3, 2]\n]\ntarget_date_factor = 0.6\n\nnum_tasks = len(tasks)\n\nprocessing_times = [task[0] for task in tasks]\nearliness_penalties = [task[1] for task in tasks]\ntardiness_penalties = [task[2] for task in tasks]\n\ntotal_processing_time = sum(processing_times)\nscale = 10\nd = int(total_processing_time * target_date_factor * scale)\n\ntask_sequence = intvar(1, num_tasks, shape=num_tasks)\n\nmodel = Model()\n\nmodel += AllDifferent(task_sequence)\n\ntotal_penalty = intvar(0, 100000)\n\ncumulative_time_vars = [intvar(0, total_processing_time * scale) for _ in range(num_tasks)]\npenalty_terms = []\n\nfor i in range(num_tasks):\n    if i == 0:\n        task_id_at_pos_0 = task_sequence[0] - 1\n        processing_time_at_pos_0 = Element(processing_times, task_id_at_pos_0)\n        model += (cumulative_time_vars[0] == processing_time_at_pos_0 * scale)\n    else:\n        task_id_at_pos_i = task_sequence[i] - 1\n        processing_time_at_pos_i = Element(processing_times, task_id_at_pos_i)\n        model += (cumulative_time_vars[i] == cumulative_time_vars[i-1] + processing_time_at_pos_i * scale)\n    \n    task_id_at_pos_i = task_sequence[i] - 1\n    \n    earliness_coeff_at_pos_i = Element(earliness_penalties, task_id_at_pos_i)\n    tardiness_coeff_at_pos_i = Element(tardiness_penalties, task_id_at_pos_i)\n    \n    earliness_component = intvar(0, 10000)\n    tardiness_component = intvar(0, 10000)\n    \n    diff_earliness_helper = intvar(-total_processing_time * scale, total_processing_time * scale)\n    model += (diff_earliness_helper == d - cumulative_time_vars[i])\n    model += (earliness_component == earliness_coeff_at_pos_i * Maximum([0, diff_earliness_helper]))\n    \n    diff_tardiness_helper = intvar(-total_processing_time * scale, total_processing_time * scale)\n    model += (diff_tardiness_helper == cumulative_time_vars[i] - d)\n    model += (tardiness_component == tardiness_coeff_at_pos_i * Maximum([0, diff_tardiness_helper]))\n    \n    penalty_term = intvar(0, 20000)\n    model += (penalty_term == earliness_component + tardiness_component)\n    penalty_terms.append(penalty_term)\n\nmodel += (total_penalty == sum(penalty_terms))\n\nmodel.minimize(total_penalty)\n\nif model.solve():\n    solution_sequence = [task_sequence[i].value() for i in range(num_tasks)]\n    \n    cumulative_time = 0\n    total_cost = 0\n    \n    for i, task_id in enumerate(solution_sequence):\n        task_idx = task_id - 1\n        processing_time = processing_times[task_idx]\n        earliness_penalty = earliness_penalties[task_idx]\n        tardiness_penalty = tardiness_penalties[task_idx]\n        \n        cumulative_time += processing_time\n        \n        target_date = total_processing_time * target_date_factor\n        earliness = max(0, target_date - cumulative_time)\n        tardiness = max(0, cumulative_time - target_date)\n        \n        early_cost = earliness * earliness_penalty\n        late_cost = tardiness * tardiness_penalty\n        total_cost += early_cost + late_cost\n    \n    result = {\n        \"task_sequence\": solution_sequence,\n        \"total_cost\": total_cost\n    }\n    print(json.dumps(result))\nelse:\n    print(\"No solution found\")",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n\n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n\n    if not solution or \"task_sequence\" not in solution:\n        return {\"is_valid\": False, \"validation_errors\": [\"Missing required field: 'task_sequence'\"], \"optimality_score\": 0.0}\n\n    try:\n        task_sequence = solution[\"task_sequence\"]\n        tasks_data = structured_data[\"tasks\"]\n        \n        num_tasks = len(tasks_data)\n        errors = []\n\n        if len(task_sequence) != num_tasks:\n            errors.append(f\"Invalid sequence length: expected {num_tasks}, got {len(task_sequence)}\")\n            return {\"is_valid\": False, \"validation_errors\": errors, \"optimality_score\": 0.0}\n\n        expected_set = set(range(1, num_tasks + 1))\n        actual_set = set(task_sequence)\n        if actual_set != expected_set:\n             missing = expected_set - actual_set\n             extra = actual_set - expected_set\n             if missing:\n                 errors.append(f\"Missing task IDs: {sorted(list(missing))}\")\n             if extra:\n                 errors.append(f\"Extra task IDs: {sorted(list(extra))}\")\n             return {\"is_valid\": False, \"validation_errors\": errors, \"optimality_score\": 0.0}\n\n        if \"total_cost\" in solution:\n            total_candidate_penalty = solution[\"total_cost\"]\n        else:\n            return {\"is_valid\": False, \"validation_errors\": [\"Missing required field: 'total_cost'\"], \"optimality_score\": 0.0}\n\n        total_reference_penalty = reference_solution[\"total_cost\"]\n\n        if total_reference_penalty == 0:\n            if total_candidate_penalty == 0:\n                optimality_score = 1.0\n            else:\n                optimality_score = 0.0 \n        else:\n            gap = abs(total_candidate_penalty - total_reference_penalty) / abs(total_reference_penalty)\n            optimality_score = max(0, 1 - gap)\n\n        is_valid = (len(errors) == 0)\n        return {\n            \"is_valid\": is_valid,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n\n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Format error in solution data or an unexpected error occurred during evaluation: {str(e)}\"], \"optimality_score\": 0.0}"
}