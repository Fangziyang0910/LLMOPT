{
  "problem_id": "container_loading_003",
  "metadata": {
    "problem_type": "Container Loading Problem",
    "difficulty": "hard"
  },
  "problem_description": "A furniture manufacturer is preparing a shipment of various furniture items for a customer order. The items need to be packed into a standard shipping container for transport. The container has internal dimensions of 30 units in length, 15 units in width, and 12 units in height. The furniture items to be loaded are: 1. Standard wardrobes (Type ID: 1): Each wardrobe has dimensions 11 units (length) by 6 units (width) by 8 units (height). There are 2 of these wardrobes available. 2. Tall bookcases (Type ID: 2): Each bookcase has dimensions 9 units (length) by 5 units (width) by 15 units (height). There are 3 of these bookcases available. 3. Conference tables (Type ID: 3): Each table has dimensions 7 units (length) by 4 units (width) by 13 units (height). There are 2 of these tables available. 4. Large office desks (Type ID: 4): Each desk has dimensions 8 units (length) by 12 units (width) by 13 units (height). There are 4 of these desks available. 5. Small storage units (Type ID: 5): Each storage unit has dimensions 6 units (length) by 5 units (width) by 7 units (height). There are 2 of these storage units available. The items can be rotated in any orientation to fit into the container. The goal is to pack as many items as possible into the container to maximize the volume utilization ratio. Items must be placed so that they are fully inside the container and do not overlap with each other. The logistics manager wants to find the best arrangement of these furniture items to make the most efficient use of the available shipping space.",
  "solution_format_description": "Print the following fields: - placements: for each furniture item, list placement with type, x, y, z, oriented_length, oriented_width, oriented_height. - volume_utilization: ratio of used container volume to total volume.",
  "structured_data": {
    "container_dimensions": [30, 15, 12],
    "furniture_inventory": [
      [11, 6, 8, 2],
      [9, 5, 15, 3],
      [7, 4, 13, 2],
      [8, 12, 13, 4],
      [6, 5, 7, 2]
    ]
  },
  "reference_solution": {
    "placements": [
      [1, [5, 1, 1], [8, 6, 11]],
      [2, [21, 0, 0], [9, 15, 5]],
      [3, [21, 0, 5], [4, 13, 7]],
      [3, [25, 0, 5], [4, 13, 7]],
      [4, [0, 7, 0], [13, 8, 12]],
      [4, [13, 0, 0], [8, 13, 12]],
      [5, [0, 0, 6], [5, 7, 6]],
      [5, [0, 0, 0], [5, 7, 6]]
    ],
    "volume_utilization": 0.8975925925925926
  },
  "solver_code": "from cpmpy import *\nimport json\n\ncontainer_dimensions = [30, 15, 12]\nfurniture_inventory = [\n    [11, 6, 8, 2],\n    [9, 5, 15, 3],\n    [7, 4, 13, 2],\n    [8, 12, 13, 4],\n    [6, 5, 7, 2]\n]\n\ncontainer_length, container_width, container_height = container_dimensions\ncontainer_volume = container_length * container_width * container_height\n\nfurniture_items = []\nfor f_idx, furniture_data in enumerate(furniture_inventory):\n    length, width, height, available_count = furniture_data\n    for i in range(available_count):\n        furniture_items.append([f_idx + 1, length, width, height])\n\nnum_items = len(furniture_items)\n\nb = boolvar(shape=num_items)  \nx = intvar(0, container_length, shape=num_items)  \ny = intvar(0, container_width, shape=num_items)   \nz = intvar(0, container_height, shape=num_items)  \nv = intvar(0, 2, shape=num_items)  \nhswap = boolvar(shape=num_items)   \n\nmax_dim = max(container_length, container_width, container_height)\no_length = intvar(1, max_dim, shape=num_items)\no_width = intvar(1, max_dim, shape=num_items)\no_height = intvar(1, max_dim, shape=num_items)\n\nmodel = Model()\n\nfor i in range(num_items):\n    length, width, height = furniture_items[i][1], furniture_items[i][2], furniture_items[i][3]\n    \n    o_lengths = [width, height, length, height, length, width]\n    o_widths = [height, width, height, length, width, length]\n    o_heights = [length, length, width, width, height, height]\n    \n    orientation_index_expr = v[i] * 2 + hswap[i]\n    model += (o_length[i] == Element(o_lengths, orientation_index_expr))\n    model += (o_width[i] == Element(o_widths, orientation_index_expr))\n    model += (o_height[i] == Element(o_heights, orientation_index_expr))\n\n    model += (x[i] + o_length[i] <= container_length) | (b[i] == 0)\n    model += (y[i] + o_width[i] <= container_width) | (b[i] == 0)\n    model += (z[i] + o_height[i] <= container_height) | (b[i] == 0)\n\nfor i in range(num_items):\n    for j in range(i + 1, num_items):\n        no_x_overlap = (x[i] + o_length[i] <= x[j]) | (x[j] + o_length[j] <= x[i])\n        no_y_overlap = (y[i] + o_width[i] <= y[j]) | (y[j] + o_width[j] <= y[i])\n        no_z_overlap = (z[i] + o_height[i] <= z[j]) | (z[j] + o_height[j] <= z[i])\n        non_overlap = no_x_overlap | no_y_overlap | no_z_overlap\n        model += (b[i] == 0) | (b[j] == 0) | non_overlap\n\nfurniture_volumes = [furniture_items[i][1] * furniture_items[i][2] * furniture_items[i][3] for i in range(num_items)]\nmodel.maximize(sum(b[i] * furniture_volumes[i] for i in range(num_items)))\n\nif model.solve():\n    total_placed_volume = sum(furniture_volumes[i] for i in range(num_items) if b[i].value())\n    volume_utilization = total_placed_volume / container_volume if container_volume > 0 else 0.0\n    \n    placements = []\n    for i in range(num_items):\n        if b[i].value():\n            placements.append([\n                furniture_items[i][0],\n                [int(x[i].value()), int(y[i].value()), int(z[i].value())],\n                [int(o_length[i].value()), int(o_width[i].value()), int(o_height[i].value())]\n            ])\n            \n    result = {\n        \"placements\": placements,\n        \"volume_utilization\": volume_utilization\n    }\n    \n    print(json.dumps(result))\nelse:\n    print(json.dumps({\"placements\": [], \"volume_utilization\": 0.0}))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n\n    try:\n        if isinstance(candidate_solution, str):\n            solution = json.loads(candidate_solution)\n        else:\n            solution = candidate_solution\n    except Exception:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n\n    required_fields = [\"placements\", \"volume_utilization\"]\n    missing = [f for f in required_fields if f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n\n    try:\n        placements = solution[\"placements\"]\n        volume_utilization = solution[\"volume_utilization\"]\n        \n        shipping_container = structured_data[\"shipping_container\"]\n        container_length = shipping_container[\"length\"]\n        container_width = shipping_container[\"width\"]\n        container_height = shipping_container[\"height\"]\n        container_volume = container_length * container_width * container_height\n        \n        furniture_types_dict = {ft[\"furniture_type_id\"]: ft for ft in structured_data[\"furniture_types\"]}\n        \n        errors = []\n        total_placed_volume = 0\n        placed_counts = {}\n\n        def boxes_overlap(pos1, dims1, pos2, dims2):\n            x1, y1, z1 = pos1\n            w1, d1, h1 = dims1\n            x2, y2, z2 = pos2\n            w2, d2, h2 = dims2\n            if x1 + w1 <= x2 or x2 + w2 <= x1:\n                return False\n            if y1 + d1 <= y2 or y2 + d2 <= y1:\n                return False\n            if z1 + h1 <= z2 or z2 + h2 <= z1:\n                return False\n            return True\n\n        validated_items_for_overlap_check = []\n        \n        for i, placement in enumerate(placements):\n            if not (isinstance(placement, list) and len(placement) == 3):\n                errors.append(f\"Placement {i} must be a list of 3 elements: [furniture_type_id, [x, y, z], [oriented_length, oriented_width, oriented_height]]\")\n                continue\n\n            furniture_type_id, position, oriented_dims = placement\n            \n            if not isinstance(furniture_type_id, int):\n                errors.append(f\"Placement {i}: furniture_type_id must be an integer.\")\n                continue\n            if not isinstance(position, list) or len(position) != 3 or not all(isinstance(coord, int) for coord in position):\n                errors.append(f\"Placement {i}: position must be a list of 3 integers [x, y, z].\")\n                continue\n            if not isinstance(oriented_dims, list) or len(oriented_dims) != 3 or not all(isinstance(dim, int) for dim in oriented_dims):\n                 errors.append(f\"Placement {i}: oriented_dims must be a list of 3 integers [oriented_length, oriented_width, oriented_height].\")\n                 continue\n\n            x, y, z = position\n            o_length, o_width, o_height = oriented_dims\n\n            if furniture_type_id not in furniture_types_dict:\n                errors.append(f\"Placement {i}: Unknown furniture type ID {furniture_type_id}.\")\n                continue\n\n            original_dims = furniture_types_dict[furniture_type_id][\"dimensions\"]\n            if sorted(oriented_dims) != sorted(original_dims):\n                 errors.append(f\"Placement {i}: Oriented dimensions {oriented_dims} are not a valid rotation of original dimensions {original_dims} for type {furniture_type_id}.\")\n                 continue\n\n            if x < 0 or y < 0 or z < 0:\n                errors.append(f\"Placement {i}: Coordinates must be non-negative. Got {position}.\")\n                continue\n            if x + o_length > container_length:\n                errors.append(f\"Placement {i}: Item extends beyond container length. X={x}, O_Length={o_length}, Container_Length={container_length}.\")\n                continue\n            if y + o_width > container_width:\n                errors.append(f\"Placement {i}: Item extends beyond container width. Y={y}, O_Width={o_width}, Container_Width={container_width}.\")\n                continue\n            if z + o_height > container_height:\n                errors.append(f\"Placement {i}: Item extends beyond container height. Z={z}, O_Height={o_height}, Container_Height={container_height}.\")\n                continue\n            \n            current_pos = (x, y, z)\n            current_dims = (o_length, o_width, o_height)\n            \n            for prev_pos, prev_dims in validated_items_for_overlap_check:\n                if boxes_overlap(current_pos, current_dims, prev_pos, prev_dims):\n                    errors.append(f\"Overlap detected between item at {current_pos} (dims {current_dims}) and item at {prev_pos} (dims {prev_dims}).\")\n            \n            validated_items_for_overlap_check.append((current_pos, current_dims))\n            \n            item_volume = o_length * o_width * o_height\n            total_placed_volume += item_volume\n            placed_counts[furniture_type_id] = placed_counts.get(furniture_type_id, 0) + 1\n            \n        for f_type_id, count in placed_counts.items():\n             available = furniture_types_dict[f_type_id][\"available_count\"]\n             if count > available:\n                 errors.append(f\"Exceeded available count for furniture type {f_type_id}. Placed: {count}, Available: {available}.\")\n\n        calculated_utilization = total_placed_volume / container_volume if container_volume > 0 else 0.0\n        if abs(calculated_utilization - volume_utilization) > 1e-6:\n             errors.append(f\"Volume utilization inconsistency. Calculated: {calculated_utilization:.6f}, Declared: {volume_utilization:.6f}\")\n\n        is_valid = (len(errors) == 0)\n        \n        if is_valid:\n            optimal_value = reference_solution[\"volume_utilization\"]\n            if optimal_value == 0:\n                optimality_score = 1.0 if volume_utilization == 0 else 0.0\n            else:\n                gap = abs(optimal_value - volume_utilization) / abs(optimal_value)\n                optimality_score = max(0, 1 - gap)\n        else:\n            optimality_score = 0.0\n\n        return {\n            \"is_valid\": is_valid,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n\n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Error during solution validation: {str(e)}\"], \"optimality_score\": 0.0}"
}