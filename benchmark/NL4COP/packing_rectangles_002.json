{
  "problem_id": "packing_rectangles_002",
  "metadata": {
    "problem_type": "Rectangle Packing Problem",
    "difficulty": "medium"
  },
  "problem_description": "In a contemporary urban architecture firm, designers are planning an innovative rooftop garden installation for a luxury residential building. The garden will be situated within a circular terrace area with landscape coordinates centered at (43, 53) and a radius of 42 meters. Twelve distinct landscape modules require careful spatial arrangement: module 1 is a 12×22 meter herb garden section featuring culinary herbs and aromatic plants; module 2 encompasses a 32×12 meter meditation space with bamboo screening and zen garden elements; module 3 contains a 40×12 meter recreational zone with outdoor fitness equipment and yoga platforms; module 4 integrates a 45×11 meter water feature area with fountains and reflective pools; module 5 provides a 47×13 meter social gathering space with modular seating and fire pit arrangements; module 6 incorporates a 44×14 meter children's play area with safe, age-appropriate equipment; module 7 establishes a 13×46 meter vertical garden wall with climbing plants and automated irrigation; module 8 maintains a 17×38 meter outdoor dining pavilion with weather-resistant furniture; module 9 operates a 16×44 meter art installation space featuring rotating sculptures and exhibits; module 10 utilizes a 27×30 meter greenhouse structure for year-round plant cultivation; module 11 deploys a 37×23 meter wildlife habitat zone with native plant species and bird feeding stations; and module 12 contains a 23×37 meter multipurpose event lawn for small gatherings and ceremonies. Each module can be either included in the final design or deferred to future development phases, with partial implementation not permitted due to design integrity requirements. When included, a module must be positioned so that its entire area remains within the circular terrace boundary to maintain structural feasibility and aesthetic coherence. No two included modules may overlap to ensure proper circulation, maintenance access, and functional separation. The design team seeks to determine which modules to include and their optimal positioning to maximize the number of functional garden areas while creating a harmonious, sustainable rooftop environment. Positioning needs to follow the building's structural grid using whole number coordinates, each module's location is determined by its center point, and the specified orientations must be maintained to ensure proper sight lines and spatial flow throughout the garden.",
  "solution_format_description": "Print the following fields: - installed: for each installed module, list placement with module ID, x, y. - total_installed: total number of installed modules.",  
  "structured_data": {
    "terrace_center": [43, 53],
    "terrace_radius": 42,
    "module_dimensions": [[12, 22], [32, 12], [40, 12], [45, 11], [47, 13], [44, 14], [13, 46], [17, 38], [16, 44], [27, 30], [37, 23], [23, 37]]
  },
  "reference_solution": {
    "installed": [[0, 9, 52], [1, 28, 75], [2, 35, 63], [3, 38, 51], [4, 39, 39], [5, 42, 25], [6, 71, 53]],
    "total_installed": 7
  },
  "solver_code": "from cpmpy import *\nimport json\n\ncx, cy = 43, 53\nR = 42\nitems = [[12, 22], [32, 12], [40, 12], [45, 11], [47, 13], [44, 14], [13, 46], [17, 38], [16, 44], [27, 30], [37, 23], [23, 37]]\nn = len(items)\n\nmodel = Model()\nselected = boolvar(shape=n)\n\ndummy_x, dummy_y = cx + R + 100, cy + R + 100\n\nx_bounds = []\ny_bounds = []\nfor i in range(n):\n    l, w = items[i]\n    half_l, half_w = l // 2, w // 2\n\n    x_min = min(cx - R + half_l, dummy_x)\n    x_max = max(cx + R - half_l, dummy_x)\n    y_min = min(cy - R + half_w, dummy_y)  \n    y_max = max(cy + R - half_w, dummy_y)\n    x_bounds.append((x_min, x_max))\n    y_bounds.append((y_min, y_max))\n\nx = [intvar(x_bounds[i][0], x_bounds[i][1]) for i in range(n)]\ny = [intvar(y_bounds[i][0], y_bounds[i][1]) for i in range(n)]\n\nfor i in range(n):\n    l, w = items[i]\n    half_l, half_w = l // 2, w // 2\n    \n    model += (~selected[i]).implies(x[i] == dummy_x)\n    model += (~selected[i]).implies(y[i] == dummy_y)\n    \n    corners_x = [x[i] - half_l, x[i] - half_l, x[i] + half_l, x[i] + half_l]\n    corners_y = [y[i] - half_w, y[i] + half_w, y[i] - half_w, y[i] + half_w]\n    for cx_corner, cy_corner in zip(corners_x, corners_y):\n        dist_sq = (cx_corner - cx)**2 + (cy_corner - cy)**2\n        model += selected[i].implies(dist_sq <= R**2)\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        l1, w1 = items[i]\n        l2, w2 = items[j]\n        x1_min, x1_max = x[i] - l1//2, x[i] + l1//2\n        y1_min, y1_max = y[i] - w1//2, y[i] + w1//2\n        x2_min, x2_max = x[j] - l2//2, x[j] + l2//2\n        y2_min, y2_max = y[j] - w2//2, y[j] + w2//2\n        no_overlap = (x1_max <= x2_min) | (x2_max <= x1_min) | (y1_max <= y2_min) | (y2_max <= y1_min)\n        model += (selected[i] & selected[j]).implies(no_overlap)\n\nmodel.maximize(sum(selected))\n\nif model.solve():\n    installed = []\n    for i in range(n):\n        if selected[i].value():\n            installed.append([i, int(x[i].value()), int(y[i].value())])\n    result = {\"installed\": installed, \"total_installed\": len(installed)}\n    print(json.dumps(result))\nelse:\n    print(json.dumps({\"error\": \"No solution found\"}))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    import math\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"installed\", \"total_installed\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        installed = solution[\"installed\"]\n        total_installed = solution[\"total_installed\"]\n        errors = []\n        \n        cx, cy = structured_data[\"terrace_center\"][0], structured_data[\"terrace_center\"][1]\n        R = structured_data[\"terrace_radius\"]\n        items = structured_data[\"module_dimensions\"]\n        \n        for module_id, x, y in installed:\n            if module_id >= len(items):\n                errors.append(f\"Module {module_id} index out of range\")\n                continue\n                \n            w, h = items[module_id]\n            half_w, half_h = w // 2, h // 2\n            \n            corners = [(x - half_w, y - half_h), (x - half_w, y + half_h), \n                      (x + half_w, y - half_h), (x + half_w, y + half_h)]\n            for corner_x, corner_y in corners:\n                dist_sq = (corner_x - cx)**2 + (corner_y - cy)**2\n                if dist_sq > R**2:\n                    errors.append(f\"Module {module_id} exceeds terrace boundaries\")\n                    break\n        \n        for i, (module_id_i, x_i, y_i) in enumerate(installed):\n            if module_id_i >= len(items):\n                continue\n                \n            w_i, h_i = items[module_id_i]\n            \n            for j in range(i + 1, len(installed)):\n                module_id_j, x_j, y_j = installed[j]\n                if module_id_j >= len(items):\n                    continue\n                    \n                w_j, h_j = items[module_id_j]\n                \n                if not (x_i + w_i//2 <= x_j - w_j//2 or x_j + w_j//2 <= x_i - w_i//2 or\n                        y_i + h_i//2 <= y_j - h_j//2 or y_j + h_j//2 <= y_i - h_i//2):\n                    errors.append(f\"Modules {module_id_i} and {module_id_j} overlap\")\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_value = reference_solution[\"total_installed\"]\n            if optimal_value == 0:\n                optimality_score = 1.0 if total_installed == 0 else 0.0\n            else:\n                gap = abs(optimal_value - total_installed) / abs(optimal_value)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}