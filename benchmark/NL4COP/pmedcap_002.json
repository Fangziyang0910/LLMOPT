{
  "problem_id": "pmedcap_002",
  "metadata": {
    "problem_type": "Capacitated P-Median Problem",
    "difficulty": "medium"
  },
  "problem_description": "An advanced electromagnetic spectrum management infrastructure requires strategic deployment of four quantum-enhanced signal amplification nodes across a heterogeneous geographic topology to establish optimal information transmission networks that minimize cumulative wave propagation distance while adhering to stringent capacity utilization constraints and quantum coherence preservation protocols. The coordinate system employs a standardized geospatial reference framework with all positional measurements expressed in kilometers relative to established grid coordinates. Each amplification node can process a maximum of forty terabytes of quantum-encoded data per diurnal cycle. Every transmission tower exhibits unique bandwidth consumption patterns requiring specialized resource allocation ranging from one to ten terabytes per diurnal cycle, necessitating precise assignment optimization to ensure balanced operational efficiency and quantum entanglement stability. Geospatial distribution characteristics and bandwidth consumption profiles include: Transmission Node Alpha positioned ninety-two kilometers east and eighty kilometers north from grid origin and requires eight terabytes daily; Node Beta located seven kilometers east and sixty-nine kilometers north from grid origin and requires ten terabytes; Node Gamma situated ninety-six kilometers east and seventy-five kilometers north from grid origin and requires ten terabytes; Node Delta positioned forty-eight kilometers east and eighteen kilometers north from grid origin and requires seven terabytes; Node Epsilon located twenty kilometers east and ten kilometers north from grid origin and requires seven terabytes; Node Zeta situated eleven kilometers east and seventy-three kilometers north from grid origin and requires four terabytes; Node Eta positioned twenty-nine kilometers east and fifty-six kilometers north from grid origin and requires six terabytes; Node Theta located seventy kilometers east and fifty-three kilometers north from grid origin and requires two terabytes; Node Iota situated forty-seven kilometers east and ninety-two kilometers north from grid origin and requires seven terabytes; Node Kappa positioned six kilometers east and sixty-two kilometers north from grid origin and requires one terabyte; Node Lambda located seventy-six kilometers east and one kilometer north from grid origin and requires ten terabytes; Node Mu situated eighty-five kilometers east and eleven kilometers north from grid origin and requires five terabytes; Node Nu positioned twenty-four kilometers east and sixty-four kilometers north from grid origin and requires three terabytes; Node Xi located fifty-nine kilometers east and fifty-five kilometers north from grid origin and requires six terabytes; Node Omicron situated thirty-three kilometers east and ninety-five kilometers north from grid origin and requires one terabyte; Node Pi positioned twenty-eight kilometers east and twenty-seven kilometers north from grid origin and requires two terabytes; Node Rho located seventy-three kilometers east and thirty kilometers north from grid origin and requires six terabytes; Node Sigma situated thirty-one kilometers east and forty kilometers north from grid origin and requires three terabytes; Node Tau positioned eighty-eight kilometers east and twenty-nine kilometers north from grid origin and requires two terabytes; Node Upsilon located ninety-one kilometers east and ninety-three kilometers north from grid origin and requires five terabytes; Node Phi situated forty-four kilometers east and sixty-one kilometers north from grid origin and requires three terabytes; Node Chi positioned ninety-seven kilometers east and two kilometers north from grid origin and requires five terabytes; Node Psi located fourteen kilometers east and forty-seven kilometers north from grid origin and requires two terabytes; Node Omega situated thirty-seven kilometers east and seventy-seven kilometers north from grid origin and requires nine terabytes; and Node Alpha Prime positioned fifty-six kilometers east and thirty-six kilometers north from grid origin and requires one terabyte. Each quantum-enhanced amplification node must be co-located with an existing transmission tower and can serve multiple towers as long as the aggregate bandwidth consumption does not exceed forty terabytes per diurnal cycle.",
  "solution_format_description": "Print the following fields: - propagation_cost: total transportation distance. - quantum_node_positions: selected facility locations. - spectrum_allocation_matrix: assigned facility for each node.",
  "structured_data": {
    "amplification_node_count": 4,
    "quantum_capacity_threshold": 40,
    "electromagnetic_transmission_nodes": [
      [92, 80, 8],
      [7, 69, 10],
      [96, 75, 10],
      [48, 18, 7],
      [20, 10, 7],
      [11, 73, 4],
      [29, 56, 6],
      [70, 53, 2],
      [47, 92, 7],
      [6, 62, 1],
      [76, 1, 10],
      [85, 11, 5],
      [24, 64, 3],
      [59, 55, 6],
      [33, 95, 1],
      [28, 27, 2],
      [73, 30, 6],
      [31, 40, 3],
      [88, 29, 2],
      [91, 93, 5],
      [44, 61, 3],
      [97, 2, 5],
      [14, 47, 2],
      [37, 77, 9],
      [56, 36, 1]
    ]
  },
  "reference_solution": {
    "propagation_cost": 442.5234,
    "quantum_node_positions": [1, 12, 13, 25],
    "spectrum_allocation_matrix": [1, 13, 1, 25, 25, 13, 13, 25, 1, 13, 12, 12, 13, 25, 13, 25, 25, 25, 12, 1, 13, 12, 13, 13, 25]
  },
  "solver_code": "from cpmpy import *\nimport json\nimport math\n\namplification_node_count = 4\nquantum_capacity_threshold = 40\nelectromagnetic_transmission_nodes = [\n    [92, 80, 8],\n    [7, 69, 10],\n    [96, 75, 10],\n    [48, 18, 7],\n    [20, 10, 7],\n    [11, 73, 4],\n    [29, 56, 6],\n    [70, 53, 2],\n    [47, 92, 7],\n    [6, 62, 1],\n    [76, 1, 10],\n    [85, 11, 5],\n    [24, 64, 3],\n    [59, 55, 6],\n    [33, 95, 1],\n    [28, 27, 2],\n    [73, 30, 6],\n    [31, 40, 3],\n    [88, 29, 2],\n    [91, 93, 5],\n    [44, 61, 3],\n    [97, 2, 5],\n    [14, 47, 2],\n    [37, 77, 9],\n    [56, 36, 1]\n]\n\nn_nodes = len(electromagnetic_transmission_nodes)\nbandwidth_demands = [electromagnetic_transmission_nodes[i][2] for i in range(n_nodes)]\ncoordinates = [(electromagnetic_transmission_nodes[i][0], electromagnetic_transmission_nodes[i][1]) for i in range(n_nodes)]\n\nmodel = Model()\n\nis_amplification_node = boolvar(shape=n_nodes)\n\nassign = boolvar(shape=(n_nodes, n_nodes))\n\nmodel += sum(is_amplification_node) == amplification_node_count\n\nfor i in range(n_nodes):\n    model += sum(assign[i, j] for j in range(n_nodes)) == 1\n\nfor i in range(n_nodes):\n    for j in range(n_nodes):\n        model += assign[i, j] <= is_amplification_node[j]\n\nfor j in range(n_nodes):\n    total_bandwidth_to_j = sum(bandwidth_demands[i] * assign[i, j] for i in range(n_nodes))\n    model += total_bandwidth_to_j <= quantum_capacity_threshold * is_amplification_node[j]\n\ndistance_matrix = {}\nfor i in range(n_nodes):\n    for j in range(n_nodes):\n        xi, yi = coordinates[i]\n        xj, yj = coordinates[j]\n        dist = math.sqrt((xi - xj)**2 + (yi - yj)**2)\n        distance_matrix[(i, j)] = dist\n\ntotal_propagation_cost = sum(distance_matrix[(i, j)] * assign[i, j] for i in range(n_nodes) for j in range(n_nodes))\nmodel.minimize(total_propagation_cost)\n\nif model.solve():\n    quantum_node_positions = [j+1 for j in range(n_nodes) if is_amplification_node[j].value()]\n    \n    spectrum_allocation_matrix = [0] * n_nodes\n    for i in range(n_nodes):\n        for j in range(n_nodes):\n            if assign[i, j].value() == 1:\n                spectrum_allocation_matrix[i] = j+1\n                break\n\n    result = {\n        \"propagation_cost\": round(model.objective_value(), 4),\n        \"quantum_node_positions\": quantum_node_positions,\n        \"spectrum_allocation_matrix\": spectrum_allocation_matrix\n    }\n    print(json.dumps(result))\nelse:\n    print(\"No solution found.\")",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    import math\n\n    try:\n        if isinstance(candidate_solution, str):\n            solution = json.loads(candidate_solution)\n        else:\n            solution = candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n\n    required_fields = [\"propagation_cost\", \"quantum_node_positions\", \"spectrum_allocation_matrix\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n\n    try:\n        propagation_cost = solution[\"propagation_cost\"]\n        quantum_node_positions = solution[\"quantum_node_positions\"]\n        spectrum_allocation_matrix = solution[\"spectrum_allocation_matrix\"]\n        \n        amplification_node_count = structured_data[\"amplification_node_count\"]\n        quantum_capacity_threshold = structured_data[\"quantum_capacity_threshold\"]\n        electromagnetic_transmission_nodes = structured_data[\"electromagnetic_transmission_nodes\"]\n        n_nodes = len(electromagnetic_transmission_nodes)\n        \n        errors = []\n\n        if len(quantum_node_positions) != amplification_node_count:\n            errors.append(f\"Amplification node count mismatch: expected {amplification_node_count}, got {len(quantum_node_positions)}\")\n\n        if len(spectrum_allocation_matrix) != n_nodes:\n            errors.append(f\"Spectrum allocation count mismatch: expected {n_nodes}, got {len(spectrum_allocation_matrix)}\")\n        \n        for node in quantum_node_positions:\n            if node < 0 or node >= n_nodes:\n                errors.append(f\"Invalid quantum node position {node}, must be between 0 and {n_nodes-1}\")\n        \n        for allocation in spectrum_allocation_matrix:\n            if allocation not in quantum_node_positions:\n                errors.append(f\"Node assigned to {allocation} which is not in the list of selected quantum nodes.\")\n\n        capacity_usage = {}\n        for i, allocation in enumerate(spectrum_allocation_matrix):\n            bandwidth_demand = electromagnetic_transmission_nodes[i][2]\n            if allocation not in capacity_usage:\n                capacity_usage[allocation] = 0.0\n            capacity_usage[allocation] += bandwidth_demand\n            \n        for node, used in capacity_usage.items():\n            if used > quantum_capacity_threshold + 1e-6:\n                errors.append(\n                    f\"Quantum capacity exceeded for node {node}: used capacity {used:.4f} exceeds allowed threshold {quantum_capacity_threshold:.4f}.\")\n\n        recomputed_propagation_cost = 0\n        if not errors:\n            coordinates = [(electromagnetic_transmission_nodes[i][0], electromagnetic_transmission_nodes[i][1]) for i in range(n_nodes)]\n            for i, allocation in enumerate(spectrum_allocation_matrix):\n                try:\n                    tx, ty = coordinates[i]\n                except Exception as e:\n                    errors.append(f\"Error accessing data for transmission node index {i}: {e}\")\n                    break\n                \n                if allocation < 0 or allocation >= n_nodes:\n                    errors.append(f\"Assigned quantum node {allocation} for transmission node {i} not found.\")\n                    break\n\n                sx, sy = coordinates[allocation]\n                d = math.sqrt((tx - sx) ** 2 + (ty - sy) ** 2)\n                recomputed_propagation_cost += math.floor(d)\n\n            if abs(recomputed_propagation_cost - propagation_cost) > 1e-6:\n                errors.append(f\"Propagation cost inconsistency: reported {propagation_cost}, calculated {recomputed_propagation_cost}\")\n\n        if errors:\n            return {\n                \"is_valid\": False,\n                \"validation_errors\": errors,\n                \"optimality_score\": 0.0\n            }\n\n        optimal_value = reference_solution[\"propagation_cost\"]\n        if optimal_value == 0:\n            optimality_score = 1.0 if propagation_cost == 0 else 0.0\n        else:\n            gap = abs(optimal_value - propagation_cost) / abs(optimal_value)\n            optimality_score = max(0, 1 - gap)\n\n        return {\n            \"is_valid\": True,\n            \"validation_errors\": [],\n            \"optimality_score\": optimality_score\n        }\n\n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Format error in solution data or evaluation logic: {str(e)}\"], \"optimality_score\": 0.0}"
}