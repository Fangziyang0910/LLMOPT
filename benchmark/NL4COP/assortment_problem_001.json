{ 
  "problem_id": "assortment_problem_001", 
  "metadata": { 
    "problem_type": "Assortment Problem", 
    "difficulty": "simple" 
  }, 
  "problem_description": "Sarah is organizing a craft workshop and needs to cut various fabric pieces from two available bolts of fabric to minimize material waste. She has two fabric bolts available: one measuring 60x60 inches and another measuring 70x50 inches. The workshop requires the following fabric pieces: 1. Small decorative pieces: 20x10 inches each (need between 2 and 5 pieces) 2. Medium square pieces: 30x30 inches each (need between 3 and 6 pieces) 3. Large rectangular pieces: 25x15 inches each (need between 2 and 4 pieces). Each fabric piece must be cut entirely from one of the fabric bolts without overlapping other pieces. Sarah can use both types of fabric bolts but wants to minimize the total percentage of fabric wasted. She needs to determine how to arrange all the required pieces on the available fabric bolts to use as much fabric as possible.", 
  "solution_format_description": "Print the following fields: - waste_rate: percentage of fabric wasted. - fabric_instances: for each fabric_type, list placements with piece, x, y, orientation. - piece_counts: how many of each piece type are cut. - total_fabric_area: sum of all fabric areas used. - total_used_area: sum of all piece areas.", 
  "structured_data": {
    "fabric": [ 
      [60, 60],
      [70, 50] 
    ], 
    "pieces": [ 
      [20, 10, 2, 5],
      [30, 30, 3, 6],
      [25, 15, 2, 4] 
    ] 
  }, 
  "reference_solution": {
    "waste_rate": 0.014084507042253502,
    "fabric_instances": {
      "A": [
        {"piece": "medium", "x": 0, "y": 0, "orientation": "normal"},
        {"piece": "medium", "x": 0, "y": 30, "orientation": "normal"},
        {"piece": "medium", "x": 30, "y": 0, "orientation": "normal"},
        {"piece": "medium", "x": 30, "y": 30, "orientation": "normal"}
      ],
      "B": [
        {"piece": "small", "x": 0, "y": 0, "orientation": "normal"},
        {"piece": "small", "x": 0, "y": 10, "orientation": "normal"},
        {"piece": "small", "x": 0, "y": 20, "orientation": "rotated"},
        {"piece": "small", "x": 20, "y": 0, "orientation": "normal"},
        {"piece": "small", "x": 20, "y": 10, "orientation": "normal"},
        {"piece": "medium", "x": 10, "y": 20, "orientation": "normal"},
        {"piece": "large", "x": 40, "y": 25, "orientation": "rotated"},
        {"piece": "large", "x": 40, "y": 0, "orientation": "rotated"},
        {"piece": "large", "x": 55, "y": 0, "orientation": "rotated"},
        {"piece": "large", "x": 55, "y": 25, "orientation": "rotated"}
      ]
    },
    "piece_counts": {
      "small": 5,
      "medium": 5,
      "large": 4
    },
    "total_fabric_area": 7100,
    "total_used_area": 7000
  },
  "solver_code": "from cpmpy import *\nimport json\n\nnum_sheets = 2\nnum_panels = 3\n\nsheets = [\n    [60, 60],\n    [70, 50]\n]\n\npanels = [\n    [20, 10, 2, 5],\n    [30, 30, 3, 6],\n    [25, 15, 2, 4]\n]\n\nS = num_sheets\nT = num_panels\n\nsheet_dims = {}\nsheet_area = {}\nfor i, sheet in enumerate(sheets):\n    sheet_dims[i+1] = (sheet[0], sheet[1])\n    sheet_area[i+1] = sheet[0] * sheet[1]\n\npanel_width = [panel[0] for panel in panels]\npanel_height = [panel[1] for panel in panels]\npanel_min = [panel[2] for panel in panels]\npanel_max = [panel[3] for panel in panels]\npanel_area = [panel_width[i] * panel_height[i] for i in range(T)]\n\nmax_sheet_types_in_plan = 2\nM = sum(panel_max)\n\nplacements_per_type = panel_max[:]\ntotal_placements = sum(placements_per_type)\n\nmax_sheet_width = max(w for (w, h) in sheet_dims.values())\nmax_sheet_height = max(h for (w, h) in sheet_dims.values())\n\ntype_of_placement = []\nlocal_index_of_placement = []\nfor t in range(T):\n    for p in range(placements_per_type[t]):\n        type_of_placement.append(t)\n        local_index_of_placement.append(p)\n\nmodel = Model()\n\npanel_count = intvar(min(panel_min), max(panel_max), shape=T, name=\"panel_count\")\nfor i in range(T):\n    model += panel_count[i] >= panel_min[i]\n    model += panel_count[i] <= panel_max[i]\n\nsheet_instance_type = intvar(0, S, shape=M, name=\"sheet_instance_type\")\nnumber_of_sheets_of_type = intvar(0, M, shape=S, name=\"number_of_sheets_of_type\")\nsheet_type_used = boolvar(shape=S, name=\"sheet_type_used\")\n\nplacement_used = boolvar(shape=total_placements, name=\"placement_used\")\nsheet_index_of_placement = intvar(1, M, shape=total_placements, name=\"sheet_index_of_placement\")\nx = intvar(0, max_sheet_width, shape=total_placements, name=\"x\")\ny = intvar(0, max_sheet_height, shape=total_placements, name=\"y\")\norientation = boolvar(shape=total_placements, name=\"orientation\")\n\nplaced_width = intvar(0, max_sheet_width, shape=total_placements, name=\"placed_width\")\nplaced_height = intvar(0, max_sheet_height, shape=total_placements, name=\"placed_height\")\nplacement_area = intvar(0, max(panel_area), shape=total_placements, name=\"placement_area\")\n\nfor t in range(T):\n    indices = [k for k in range(total_placements) if type_of_placement[k] == t]\n    model += sum([placement_used[k] for k in indices]) == panel_count[t]\n\nfor s in range(1, S + 1):\n    model += number_of_sheets_of_type[s - 1] == sum([sheet_instance_type[i] == s for i in range(M)])\n    model += number_of_sheets_of_type[s - 1] >= sheet_type_used[s - 1]\n    model += number_of_sheets_of_type[s - 1] <= M * sheet_type_used[s - 1]\n\nmodel += sum(sheet_type_used) <= max_sheet_types_in_plan\n\nfor i in range(M - 1):\n    model += sheet_instance_type[i] >= sheet_instance_type[i + 1]\n\nnum_declared = intvar(0, M, name=\"num_declared\")\nmodel += num_declared == sum([sheet_instance_type[i] != 0 for i in range(M)])\nmodel += num_declared == sum(number_of_sheets_of_type)\n\nfor k in range(total_placements):\n    model += placement_used[k].implies(sheet_index_of_placement[k] <= num_declared)\n\nfor i in range(M):\n    model += (sheet_instance_type[i] != 0).implies(\n        sum([ (placement_used[k] & (sheet_index_of_placement[k] == i + 1)) for k in range(total_placements)]) >= 1\n    )\n\nwidth_list = [0] + [sheet_dims[s][0] for s in range(1, S+1)]\nheight_list = [0] + [sheet_dims[s][1] for s in range(1, S+1)]\nwidth_of_instance = [Element(width_list, sheet_instance_type[i]) for i in range(M)]\nheight_of_instance = [Element(height_list, sheet_instance_type[i]) for i in range(M)]\n\nfor k in range(total_placements):\n    t = type_of_placement[k]\n    pw = panel_width[t]\n    ph = panel_height[t]\n    model += placed_width[k] == pw + orientation[k] * (ph - pw)\n    model += placed_height[k] == ph + orientation[k] * (pw - ph)\n    model += placement_area[k] == placement_used[k] * panel_area[t]\n\n    for i in range(M):\n        model += (placement_used[k] & (sheet_index_of_placement[k] == i + 1)).implies(\n            x[k] + placed_width[k] <= width_of_instance[i]\n        )\n        model += (placement_used[k] & (sheet_index_of_placement[k] == i + 1)).implies(\n            y[k] + placed_height[k] <= height_of_instance[i]\n        )\n\nfor a in range(total_placements):\n    for b in range(a + 1, total_placements):\n        same_sheet_and_used = placement_used[a] & placement_used[b] & (sheet_index_of_placement[a] == sheet_index_of_placement[b])\n        no_overlap = (\n            (x[a] + placed_width[a] <= x[b])\n            | (x[b] + placed_width[b] <= x[a])\n            | (y[a] + placed_height[a] <= y[b])\n            | (y[b] + placed_height[b] <= y[a])\n        )\n        model += same_sheet_and_used.implies(no_overlap)\n\ntotal_sheet_area = intvar(0, sum(sheet_area.values()) * M, name=\"total_sheet_area\")\nmodel += total_sheet_area == sum([number_of_sheets_of_type[s] * sheet_area[s + 1] for s in range(S)])\ntotal_used_area = intvar(0, sum(panel_area) * M, name=\"total_used_area\")\nmodel += total_used_area == sum(placement_area)\n\nwaste_area = intvar(0, sum(sheet_area.values()) * M, name=\"waste_area\")\nmodel += waste_area == total_sheet_area - total_used_area\n\nmodel.minimize(waste_area)\n\nsolved = model.solve(time_limit=55)\n\nif not solved:\n    result = {\n        \"waste_rate\": 1.0,\n        \"sheet_instances\": [[1, []]],\n        \"panel_counts\": [panel[2] for panel in panels],\n        \"total_sheet_area\": sheets[0][0] * sheets[0][1],\n        \"total_used_area\": 0\n    }\n    print(json.dumps(result))\nelse:\n    panel_count_val = panel_count.value().tolist()\n    sheet_instance_type_val = sheet_instance_type.value().tolist()\n    placement_used_val = [int(b) for b in placement_used.value().tolist()]\n    sheet_index_of_placement_val = sheet_index_of_placement.value().tolist()\n    x_val = x.value().tolist()\n    y_val = y.value().tolist()\n    orientation_val = [int(b) for b in orientation.value().tolist()]\n\n    total_sheet_area_val = int(total_sheet_area.value())\n    total_used_area_val = int(total_used_area.value())\n    waste_area_val = int(waste_area.value())\n    waste_rate = (waste_area_val / total_sheet_area_val) if total_sheet_area_val > 0 else 0.0\n\n    sheet_instances_by_type = [[] for _ in range(S + 1)]\n    \n    for i in range(M):\n        stype = int(sheet_instance_type_val[i])\n        if stype == 0:\n            continue\n        for k in range(total_placements):\n            if placement_used_val[k] == 1 and sheet_index_of_placement_val[k] == i + 1:\n                piece_id = type_of_placement[k] + 1\n                placement = [piece_id, int(x_val[k]), int(y_val[k]), int(orientation_val[k])]\n                sheet_instances_by_type[stype].append(placement)\n    \n    sheet_instances = [placements for placements in sheet_instances_by_type[1:] if placements]\n\n    solution = {\n        \"waste_rate\": float(waste_rate),\n        \"fabric_instances\": sheet_instances,\n        \"piece_counts\": [int(c) for c in panel_count_val],\n        \"total_fabric_area\": total_sheet_area_val,\n        \"total_used_area\": total_used_area_val\n    }\n\n    print(json.dumps(solution))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n\n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n\n    required_fields = [\"waste_rate\", \"fabric_instances\", \"piece_counts\", \"total_fabric_area\", \"total_used_area\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n\n    try:\n        waste_rate = solution[\"waste_rate\"]\n        fabric_instances = solution[\"fabric_instances\"]\n        piece_counts = solution[\"piece_counts\"]\n        total_fabric_area = solution[\"total_fabric_area\"]\n        total_used_area = solution[\"total_used_area\"]\n        \n        fabric = structured_data[\"fabric\"]\n        pieces = structured_data[\"pieces\"]\n        errors = []\n        \n        if len(piece_counts) != len(pieces):\n            errors.append(f\"Piece counts length mismatch: expected {len(pieces)}, got {len(piece_counts)}\")\n        \n        for i, piece in enumerate(pieces):\n            count = piece_counts[i] if i < len(piece_counts) else 0\n            if count < piece[2] or count > piece[3]:\n                errors.append(f\"Piece count violation for piece type {i+1}: count = {count}, required min = {piece[2]}, max = {piece[3]}\")\n        \n        for instance in fabric_instances:\n            if not isinstance(instance, list):\n                errors.append(\"Invalid fabric instance structure\")\n                continue\n            \n            for placement in instance:\n                if len(placement) != 4:\n                    errors.append(\"Invalid placement structure\")\n                    continue\n                \n                piece_type = placement[0]\n                if not (1 <= piece_type <= len(pieces)):\n                    errors.append(f\"Invalid piece type in placement: {piece_type}\")\n                    continue\n        \n        optimal_waste_rate = reference_solution[\"waste_rate\"]\n        if optimal_waste_rate == 0:\n            optimality_score = 1.0 if waste_rate == 0 else 0.0\n        else:\n            gap = abs(optimal_waste_rate - waste_rate) / abs(optimal_waste_rate)\n            optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
} 
