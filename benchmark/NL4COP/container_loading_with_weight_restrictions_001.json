{
  "problem_id": "container_loading_with_weight_restrictions_001",
  "metadata": {
    "problem_type": "Container Loading with Weight Restrictions Problem",
    "difficulty": "simple"
  },
  "problem_description": "A warehouse manager needs to optimize the loading of boxes into a storage container measuring 200×100×150 cm. Available are Type 1 boxes (3 units available, each 80×60×40 cm, weighing 50 kg) and Type 2 boxes (4 units available, each 50×40×30 cm, weighing 30 kg). Each box can be placed in one of three orientations by rotating its dimensions. Boxes must be placed such that they do not extend beyond the container boundaries in any dimension. Additionally, boxes cannot overlap with each other in the container space. The objective is to maximize the total volume of boxes loaded into the container, thereby achieving the highest possible space utilization rate.",
  "solution_format_description": "Print the following fields: - box_placements: for each box, list placement with type, orientation, x, y, z. - space_utilization: ratio of used container space to total space. - total_volume_used: total volume of placed boxes. - container_volume: total container volume.",
  "structured_data": {
    "container_dimensions": [200, 100, 150],
    "box_inventory": [
      [80, 60, 40, 3, 50],
      [50, 40, 30, 4, 30]
    ]
  },
  "reference_solution": {
    "box_placements": [
      [2, 3, 11, 41, 112],
      [2, 2, 50, 70, 63],
      [2, 1, 13, 40, 62],
      [2, 1, 61, 40, 71],
      [1, 3, 0, 31, 22],
      [1, 1, 101, 40, 53],
      [1, 2, 52, 0, 71]
    ],
    "space_utilization": 0.272,
    "total_volume_used": 816000,
    "container_volume": 3000000
  },
  "solver_code": "from cpmpy import *\nimport json\n\ncontainer_dimensions = [200, 100, 150]\nbox_inventory = [\n    [80, 60, 40, 3, 50],\n    [50, 40, 30, 4, 30]\n]\n\ncontainer_length, container_width, container_height = container_dimensions\ncontainer_volume = container_length * container_width * container_height\n\nboxes = []\nfor box_idx, (length, width, height, available, weight) in enumerate(box_inventory):\n    for i in range(available):\n        boxes.append([box_idx + 1, length, width, height])\n\nnum_boxes = len(boxes)\n\nused = boolvar(shape=num_boxes)\nx = intvar(0, container_length, shape=num_boxes)\ny = intvar(0, container_width, shape=num_boxes)\nz = intvar(0, container_height, shape=num_boxes)\norientation = intvar(1, 3, shape=num_boxes)\n\no_length = intvar(1, max(container_length, container_width, container_height), shape=num_boxes)\no_width = intvar(1, max(container_length, container_width, container_height), shape=num_boxes)\no_height = intvar(1, max(container_length, container_width, container_height), shape=num_boxes)\n\nmodel = Model()\n\nfor i in range(num_boxes):\n    box_type, length, width, height = boxes[i]\n    \n    model += (orientation[i] == 1).implies(o_length[i] == length)\n    model += (orientation[i] == 1).implies(o_width[i] == width)\n    model += (orientation[i] == 1).implies(o_height[i] == height)\n    \n    model += (orientation[i] == 2).implies(o_length[i] == width)\n    model += (orientation[i] == 2).implies(o_width[i] == height)\n    model += (orientation[i] == 2).implies(o_height[i] == length)\n    \n    model += (orientation[i] == 3).implies(o_length[i] == height)\n    model += (orientation[i] == 3).implies(o_width[i] == length)\n    model += (orientation[i] == 3).implies(o_height[i] == width)\n    \n    model += used[i].implies(x[i] + o_length[i] <= container_length)\n    model += used[i].implies(y[i] + o_width[i] <= container_width)\n    model += used[i].implies(z[i] + o_height[i] <= container_height)\n\nfor i in range(num_boxes):\n    for j in range(i + 1, num_boxes):\n        no_x_overlap = (x[i] + o_length[i] <= x[j]) | (x[j] + o_length[j] <= x[i])\n        no_y_overlap = (y[i] + o_width[i] <= y[j]) | (y[j] + o_width[j] <= y[i])\n        no_z_overlap = (z[i] + o_height[i] <= z[j]) | (z[j] + o_height[j] <= z[i])\n        non_overlap = no_x_overlap | no_y_overlap | no_z_overlap\n        model += (used[i] & used[j]).implies(non_overlap)\n\nbox_volumes = [boxes[i][1] * boxes[i][2] * boxes[i][3] for i in range(num_boxes)]\nmodel.maximize(sum(used[i] * box_volumes[i] for i in range(num_boxes)))\n\nif model.solve():\n    total_volume_used = sum(box_volumes[i] for i in range(num_boxes) if used[i].value())\n    space_utilization = total_volume_used / container_volume\n    \n    box_placements = []\n    for i in range(num_boxes):\n        if used[i].value():\n            box_placements.append([\n                boxes[i][0],\n                int(orientation[i].value()),\n                int(x[i].value()),\n                int(y[i].value()),\n                int(z[i].value())\n            ])\n    \n    result = {\n        \"box_placements\": box_placements,\n        \"space_utilization\": round(space_utilization, 3),\n        \"total_volume_used\": total_volume_used,\n        \"container_volume\": container_volume\n    }\n    \n    print(json.dumps(result))\nelse:\n    print(\"No solution found.\")",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"box_placements\", \"space_utilization\", \"total_volume_used\", \"container_volume\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        placements = solution[\"box_placements\"]\n        space_utilization = solution[\"space_utilization\"]\n        total_volume_used = solution[\"total_volume_used\"]\n        container_volume = solution[\"container_volume\"]\n        \n        container = structured_data[\"container_dimensions\"]\n        box_inventory = structured_data[\"box_inventory\"]\n        \n        errors = []\n        \n        if container_volume != container[0] * container[1] * container[2]:\n            errors.append(f\"Container volume mismatch: expected {container[0] * container[1] * container[2]}, got {container_volume}\")\n        \n        box_type_to_index = {}\n        for idx, box in enumerate(box_inventory):\n            box_type_to_index[box[0]] = idx\n        \n        box_usage = [0] * len(box_inventory)\n        \n        for i, placement in enumerate(placements):\n            if len(placement) != 5:\n                errors.append(f\"Placement {i} format error\")\n                continue\n            \n            box_type, orientation, x, y, z = placement\n            \n            if box_type not in box_type_to_index:\n                errors.append(f\"Invalid box type {box_type} in placement {i}\")\n                continue\n            \n            box_idx = box_type_to_index[box_type]\n            box = box_inventory[box_idx]\n            _, length, width, height, available, _ = box\n            \n            box_usage[box_idx] += 1\n            \n            if box_usage[box_idx] > available:\n                errors.append(f\"Exceeded available quantity for box type {box_type}\")\n            \n            if orientation == 1:\n                o_length, o_width, o_height = width, height, length\n            elif orientation == 2:\n                o_length, o_width, o_height = length, height, width\n            else:\n                o_length, o_width, o_height = length, width, height\n            \n            if x < 0 or y < 0 or z < 0:\n                errors.append(f\"Negative coordinates in placement {i}\")\n            \n            if x + o_length > container[0]:\n                errors.append(f\"Box {i} exceeds container length: {x} + {o_length} > {container[0]}\")\n            \n            if y + o_width > container[1]:\n                errors.append(f\"Box {i} exceeds container width: {y} + {o_width} > {container[1]}\")\n            \n            if z + o_height > container[2]:\n                errors.append(f\"Box {i} exceeds container height: {z} + {o_height} > {container[2]}\")\n        \n        for i in range(len(placements)):\n            for j in range(i + 1, len(placements)):\n                if boxes_overlap(placements[i], placements[j], box_inventory, box_type_to_index):\n                    errors.append(f\"Boxes {i} and {j} overlap\")\n        \n        calc_volume = 0\n        for placement in placements:\n            box_type = placement[0]\n            if box_type in box_type_to_index:\n                box_idx = box_type_to_index[box_type]\n                box = box_inventory[box_idx]\n                _, length, width, height, _, _ = box\n                calc_volume += length * width * height\n        \n        if abs(calc_volume - total_volume_used) > 1e-6:\n            errors.append(f\"Volume calculation mismatch: calculated {calc_volume}, declared {total_volume_used}\")\n        \n        calc_utilization = calc_volume / container_volume if container_volume > 0 else 0\n        if abs(calc_utilization - space_utilization) > 1e-6:\n            errors.append(f\"Utilization calculation mismatch: calculated {calc_utilization}, declared {space_utilization}\")\n        \n        optimal_volume = reference_solution[\"total_volume_used\"]\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            if optimal_volume == 0:\n                optimality_score = 1.0 if total_volume_used == 0 else 0.0\n            else:\n                gap = abs(optimal_volume - total_volume_used) / abs(optimal_volume)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}\n\ndef boxes_overlap(placement1, placement2, box_inventory, box_type_to_index):\n    box_type1, orientation1, x1, y1, z1 = placement1\n    box_type2, orientation2, x2, y2, z2 = placement2\n    \n    box1 = box_inventory[box_type_to_index[box_type1]]\n    box2 = box_inventory[box_type_to_index[box_type2]]\n    \n    _, length1, width1, height1, _, _ = box1\n    _, length2, width2, height2, _, _ = box2\n    \n    if orientation1 == 1:\n        l1, w1, h1 = width1, height1, length1\n    elif orientation1 == 2:\n        l1, w1, h1 = length1, height1, width1\n    else:\n        l1, w1, h1 = length1, width1, height1\n    \n    if orientation2 == 1:\n        l2, w2, h2 = width2, height2, length2\n    elif orientation2 == 2:\n        l2, w2, h2 = length2, height2, width2\n    else:\n        l2, w2, h2 = length2, width2, height2\n    \n    if x1 + l1 <= x2 or x2 + l2 <= x1:\n        return False\n    \n    if y1 + w1 <= y2 or y2 + w2 <= y1:\n        return False\n    \n    if z1 + h1 <= z2 or z2 + h2 <= z1:\n        return False\n    \n    return True"
}