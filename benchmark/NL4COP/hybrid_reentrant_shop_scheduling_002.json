{
  "problem_id": "hybrid_reentrant_shop_scheduling_002",
  "metadata": {
    "problem_type": "Hybrid Reentrant Shop Scheduling Problem",
    "difficulty": "medium"
  },
  "problem_description": "A specialized biomedical research laboratory operates with two identical experimental processing stations and must complete a sophisticated three-phase treatment protocol for eight biological samples designated BS-Alpha through BS-Hotus. Each sample must undergo a precisely orchestrated treatment sequence encompassing initial cellular preparation, followed by targeted molecular modification at a single dedicated genetic sequencing workstation, and concluding with final biological analysis on the same processing station where the initial preparation was originally performed. The treatment protocol requires that each sample undergo preliminary cellular preparation requiring exactly 1 hour at whichever processing station becomes available first, with the assignment of samples to stations determined through sequential arrival-based scheduling. Upon completion of initial preparation, each sample must be transferred to the exclusive genetic sequencing workstation for targeted molecular modification, where the processing duration exhibits sample-specific variability: BS-Alpha requires 15 hours for molecular modification, BS-Beta necessitates 14 hours, BS-Gamma demands 12 hours, BS-Delta requires 8 hours, BS-Epsilon needs 13 hours, BS-Zeta requires 13 hours, BS-Eta requires 14 hours, and BS-Theta requires 6 hours. The genetic sequencing workstation maintains strict operational exclusivity, processing only one sample at any given moment, which necessitates careful consideration of the optimal processing sequence for all samples. Following the completion of molecular modification, each sample must be returned to the identical processing station where its initial cellular preparation was conducted to undergo final biological analysis, with phase-specific processing requirements that vary by sample: BS-Alpha requires 17 hours for biological analysis, BS-Beta needs 15 hours, BS-Gamma demands 20 hours, BS-Delta requires 23 hours, BS-Epsilon needs 21 hours, BS-Zeta requires 18 hours, BS-Eta requires 23 hours, and BS-Theta necessitates 22 hours. The treatment workflow follows essential operational principles where each processing station can handle only one sample at any given time, the genetic sequencing workstation works exclusively with one sample at a time, samples must finish each phase completely before moving to the next phase, each sample must return to the same processing station for final analysis where it received its initial preparation, and no overlapping work is allowed within any processing station during both preparation and analysis phases. The research laboratory management aims to determine the best sample sequence for the genetic sequencing workstation and the most effective assignment of samples to processing stations to minimize the total treatment completion time, which will maximize research efficiency and reduce the time until the final sample completes its biological analysis phase.",
  "solution_format_description": "Print the following fields: - genetic_sequencing_sequence: processing order for samples at genetic sequencing workstation. - total_treatment_time: total time to complete all treatments.",
  "structured_data": {
    "num_samples": 8,
    "num_processing_stations": 2,
    "cellular_preparation_time": 1,
    "molecular_modification_times": [15, 14, 12, 8, 13, 13, 14, 6],
    "biological_analysis_times": [17, 15, 20, 23, 21, 18, 23, 22]
  },
  "reference_solution": {
    "genetic_sequencing_sequence": [5, 7, 4, 3, 6, 1, 8, 2],
    "total_treatment_time": 111
  },
  "solver_code": "from cpmpy import *\nimport json\n\nnum_samples = 8\nnum_processing_stations = 2\ncellular_preparation_time = 1\nmolecular_modification_times = [15, 14, 12, 8, 13, 13, 14, 6]\nbiological_analysis_times = [17, 15, 20, 23, 21, 18, 23, 22]\n\nhorizon = 400\n\nmodel = Model()\n\nassign = boolvar(shape=(num_samples, num_processing_stations))\nsample_station_assignment = intvar(1, num_processing_stations, shape=num_samples)\ngenetic_sequencing_sequence = intvar(1, num_samples, shape=num_samples)\n\npreparation_start = intvar(0, horizon - cellular_preparation_time, shape=num_samples)\npreparation_end = intvar(0, horizon, shape=num_samples)\n\nmodification_start = intvar(0, horizon, shape=num_samples)\nmodification_end = intvar(0, horizon, shape=num_samples)\n\nanalysis_start = intvar(0, horizon, shape=num_samples)\nanalysis_end = intvar(0, horizon, shape=num_samples)\n\nmakespan = intvar(0, horizon)\n\nfor i in range(num_samples):\n    model += (sum(assign[i, :]) == 1)\n    model += (sample_station_assignment[i] == sum([(s + 1) * assign[i, s] for s in range(num_processing_stations)]))\n\nfor i in range(num_samples):\n    model += (preparation_end[i] == preparation_start[i] + cellular_preparation_time)\n    model += (modification_end[i] == modification_start[i] + molecular_modification_times[i])\n    model += (analysis_end[i] == analysis_start[i] + biological_analysis_times[i])\n\nfor i in range(num_samples):\n    model += (preparation_end[i] <= modification_start[i])\n    model += (modification_end[i] <= analysis_start[i])\n\nmodel += AllDifferent(genetic_sequencing_sequence)\n\nfor p in range(num_samples - 1):\n    idx_prev = genetic_sequencing_sequence[p] - 1\n    idx_next = genetic_sequencing_sequence[p + 1] - 1\n    model += Element(modification_start, idx_next) >= Element(modification_end, idx_prev)\n\nfor s in range(num_processing_stations):\n    for i in range(num_samples):\n        for j in range(i + 1, num_samples):\n            both_assigned = assign[i, s] & assign[j, s]\n            c1 = preparation_end[i] <= preparation_start[j]\n            c2 = preparation_end[j] <= preparation_start[i]\n            model += both_assigned.implies((c1) | (c2))\n            c3 = analysis_end[i] <= analysis_start[j]\n            c4 = analysis_end[j] <= analysis_start[i]\n            model += both_assigned.implies((c3) | (c4))\n\nfor i in range(num_samples):\n    for s in range(num_processing_stations):\n        station_match = (sample_station_assignment[i] == s + 1)\n        model += station_match.implies(analysis_start[i] >= modification_end[i])\n\nmodel += makespan == max(analysis_end)\n\nmodel.minimize(makespan)\n\nif model.solve():\n    result = {\n        \"genetic_sequencing_sequence\": [int(genetic_sequencing_sequence[i].value()) for i in range(num_samples)],\n        \"total_treatment_time\": int(makespan.value())\n    }\n    print(json.dumps(result))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"genetic_sequencing_sequence\", \"total_treatment_time\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        genetic_sequencing_sequence = solution[\"genetic_sequencing_sequence\"]\n        total_treatment_time = solution[\"total_treatment_time\"]\n        num_samples = structured_data[\"num_samples\"]\n        num_processing_stations = structured_data[\"num_processing_stations\"]\n        cellular_preparation_time = structured_data[\"cellular_preparation_time\"]\n        molecular_modification_times = structured_data[\"molecular_modification_times\"]\n        biological_analysis_times = structured_data[\"biological_analysis_times\"]\n        errors = []\n        \n        if len(genetic_sequencing_sequence) != num_samples:\n            errors.append(f\"Sequence length mismatch: expected {num_samples}, got {len(genetic_sequencing_sequence)}\")\n        \n        if sorted(genetic_sequencing_sequence) != list(range(1, num_samples + 1)):\n            errors.append(\"Invalid permutation: sequence must contain all samples from 1 to n exactly once\")\n        \n        if total_treatment_time <= 0:\n            errors.append(\"Total treatment time must be positive\")\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_time = reference_solution[\"total_treatment_time\"]\n            if optimal_time == 0:\n                optimality_score = 1.0 if total_treatment_time == 0 else 0.0\n            else:\n                gap = abs(optimal_time - total_treatment_time) / abs(optimal_time)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}