{
  "problem_id": "capacitated_vehicle_routing_001",
  "metadata": {
    "problem_type": "Capacitated Vehicle Routing Problem",
    "difficulty": "simple"
  },
  "problem_description": "A local delivery company needs to distribute packages to 10 customers from their central warehouse using 3 delivery trucks, each with a capacity of 50 tons. All locations are directly accessible by road, with coordinates measured in kilometers using the city center as the origin point (0, 0). The warehouse is at coordinates (50, 50), and customer locations and demands are: Customer 1 at (25, 85) needs 8 tons, Customer 2 at (35, 25) needs 12 tons, Customer 3 at (85, 75) needs 15 tons, Customer 4 at (15, 15) needs 10 tons, Customer 5 at (75, 35) needs 18 tons, Customer 6 at (65, 85) needs 7 tons, Customer 7 at (45, 65) needs 9 tons, Customer 8 at (65, 25) needs 14 tons, Customer 9 at (35, 45) needs 11 tons, and Customer 10 at (85, 15) needs 13 tons. Trucks depart from the central warehouse and return after delivering all packages. Each customer must be served by exactly one truck. How should the company plan the routes to minimize total travel distance without exceeding the truck capacity?",
  "solution_format_description": "Print the following fields: - routes: customer visiting sequence for each vehicle. - total_distance: total travel distance across all routes.",
  "structured_data": {
    "num_vehicles": 3,
    "vehicle_capacity": 50,
    "depot": [50, 50],
    "customers": [
      [25, 85, 8],
      [35, 25, 12],
      [85, 75, 15],
      [15, 15, 10],
      [75, 35, 18],
      [65, 85, 7],
      [45, 65, 9],
      [65, 25, 14],
      [35, 45, 11],
      [85, 15, 13]
    ]
  },
  "reference_solution": {
    "routes": [
      [8, 10, 5], 
      [9, 4, 2], 
      [3, 6, 1, 7]
    ],
    "total_distance": 355.88
  },
  "solver_code": "from cpmpy import *\nimport json\nimport math\n\ndata = {\n    \"num_vehicles\": 3,\n    \"vehicle_capacity\": 50,\n    \"depot\": [50, 50],\n    \"customers\": [\n        [25, 85, 8],\n        [35, 25, 12],\n        [85, 75, 15],\n        [15, 15, 10],\n        [75, 35, 18],\n        [65, 85, 7],\n        [45, 65, 9],\n        [65, 25, 14],\n        [35, 45, 11],\n        [85, 15, 13]\n    ]\n}\n\nnum_vehicles = data[\"num_vehicles\"]\nvehicle_capacity = data[\"vehicle_capacity\"]\ndepot = data[\"depot\"]\ncustomers = data[\"customers\"]\nnum_customers = len(customers)\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\nlocations = [depot] + [[c[0], c[1]] for c in customers]\ndist_matrix = [[distance(locations[i], locations[j]) for j in range(len(locations))] for i in range(len(locations))]\n\nx = boolvar(shape=(num_customers + 1, num_customers + 1, num_vehicles))\ny = boolvar(shape=(num_customers + 1, num_vehicles))\norder = intvar(0, num_customers, shape=(num_customers + 1, num_vehicles))\n\nmodel = Model()\n\nfor i in range(1, num_customers + 1):\n    model += sum(y[i][k] for k in range(num_vehicles)) == 1\n\nfor k in range(num_vehicles):\n    total_demand = sum(customers[i-1][2] * y[i][k] for i in range(1, num_customers + 1))\n    model += total_demand <= vehicle_capacity\n\nfor i in range(1, num_customers + 1):\n    for k in range(num_vehicles):\n        model += sum(x[j][i][k] for j in range(num_customers + 1) if j != i) == y[i][k]\n        model += sum(x[i][j][k] for j in range(num_customers + 1) if j != i) == y[i][k]\n\nfor k in range(num_vehicles):\n    model += sum(x[0][j][k] for j in range(1, num_customers + 1)) <= 1\n\nfor k in range(num_vehicles):\n    model += sum(x[i][0][k] for i in range(1, num_customers + 1)) <= 1\n\nfor k in range(num_vehicles):\n    leaves_depot = sum(x[0][j][k] for j in range(1, num_customers + 1))\n    returns_to_depot = sum(x[i][0][k] for i in range(1, num_customers + 1))\n    model += leaves_depot == returns_to_depot\n\nfor k in range(num_vehicles):\n    for i in range(1, num_customers + 1):\n        for j in range(1, num_customers + 1):\n            if i != j:\n                model += order[i][k] + 1 <= order[j][k] + num_customers * (1 - x[i][j][k])\n\nfor k in range(num_vehicles):\n    for i in range(1, num_customers + 1):\n        model += order[i][k] <= num_customers * y[i][k]\n\nfor k in range(num_vehicles):\n    for i in range(num_customers + 1):\n        model += x[i][i][k] == 0\n\ntotal_distance = sum(dist_matrix[i][j] * x[i][j][k] \n                   for i in range(num_customers + 1) \n                   for j in range(num_customers + 1) \n                   for k in range(num_vehicles))\n\nmodel.minimize(total_distance)\n\nif model.solve():\n    routes = []\n    x_val = x.value()\n    \n    for k in range(num_vehicles):\n        route = []\n        current = 0\n        \n        while True:\n            found = False\n            for j in range(1, num_customers + 1):\n                if x_val[current][j][k]:\n                    route.append(j)\n                    current = j\n                    found = True\n                    break\n            \n            if not found or current == 0:\n                break\n        \n        if route:\n            routes.append(route)\n    \n    actual_distance = 0\n    for k, route in enumerate(routes):\n        if route:\n            actual_distance += dist_matrix[0][route[0]]\n            \n            for i in range(len(route) - 1):\n                actual_distance += dist_matrix[route[i]][route[i + 1]]\n            \n            actual_distance += dist_matrix[route[-1]][0]\n    \n    result = {\n        \"routes\": routes,\n        \"total_distance\": round(actual_distance, 2)\n    }\n    \n    print(json.dumps(result, indent=2))\nelse:\n    print(\"No solution found\")",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"routes\", \"total_distance\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        routes = solution[\"routes\"]\n        total_distance = solution[\"total_distance\"]\n        customers = structured_data[\"customers\"]\n        vehicle_capacity = structured_data[\"vehicle_capacity\"]\n        num_vehicles = structured_data[\"num_vehicles\"]\n        num_customers = len(customers)\n        errors = []\n        \n        if len(routes) > num_vehicles:\n            errors.append(f\"Too many routes: expected max {num_vehicles}, got {len(routes)}\")\n        \n        visited_customers = set()\n        for route in routes:\n            for customer_id in route:\n                if customer_id < 1 or customer_id > num_customers:\n                    errors.append(f\"Invalid customer ID: {customer_id}\")\n                elif customer_id in visited_customers:\n                    errors.append(f\"Customer {customer_id} visited multiple times\")\n                else:\n                    visited_customers.add(customer_id)\n        \n        if len(visited_customers) != num_customers:\n            errors.append(f\"Not all customers visited: missing {set(range(1, num_customers + 1)) - visited_customers}\")\n        \n        for i, route in enumerate(routes):\n            if route:\n                route_demand = sum(customers[cust_id - 1][2] for cust_id in route)\n                if route_demand > vehicle_capacity:\n                    errors.append(f\"Route {i+1} exceeds capacity: {route_demand} > {vehicle_capacity}\")\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_distance = reference_solution[\"total_distance\"]\n            if optimal_distance == 0:\n                optimality_score = 1.0 if total_distance == 0 else 0.0\n            else:\n                gap = abs(optimal_distance - total_distance) / abs(optimal_distance)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}