{
  "problem_id": "unconstrained_non_guillotine_cutting_003",
  "metadata": {
    "problem_type": "Unconstrained Non-Guillotine Cutting Problem",
    "difficulty": "hard"
  },
  "problem_description": "An advanced textile manufacturing enterprise is confronting a sophisticated spatial allocation optimization challenge involving non-sequential fabric arrangement on a rectangular cutting table measuring 25 by 18 centimeters. This non-guillotine cutting paradigm enables fabric pieces to be positioned arbitrarily throughout the cutting table without conforming to any predetermined cutting trajectory or sequential arrangement protocol. The manufacturing inventory encompasses five distinct fabric categories: Category 1 fabrics with length 7 centimeters and width 5 centimeters, valuation of 35 hundred dollars, and maximum allowable quantity of 3 pieces; Category 2 fabrics with length 6 centimeters and width 4 centimeters, valuation of 24 hundred dollars, and maximum allowable quantity of 3 pieces; Category 3 fabrics with length 5 centimeters and width 5 centimeters, valuation of 25 hundred dollars, and maximum allowable quantity of 3 pieces; Category 4 fabrics with length 8 centimeters and width 3 centimeters, valuation of 24 hundred dollars, and maximum allowable quantity of 3 pieces; Category 5 fabrics with length 4 centimeters and width 6 centimeters, valuation of 24 hundred dollars, and maximum allowable quantity of 3 pieces. Each fabric permits 90-degree rotational adjustment and can be positioned at any coordinate within the cutting table boundaries, provided that spatial overlapping is avoided and complete containment within the perimeter is maintained. Manufacturing engineers must determine how to arrange the fabric pieces to achieve maximum total value, with no constraints on placement order or cutting sequence.",
  "solution_format_description": "Print the following fields: - placements: for each piece, list placement with type, x, y, rotation. - total_value: total value of placed pieces.",
  "structured_data": {
    "table_dimensions": [25, 18],
    "fabric_types": [
      [7, 5, 35, 3], 
      [6, 4, 24, 3], 
      [5, 5, 25, 3], 
      [8, 3, 24, 3], 
      [4, 6, 24, 3]
    ]
  },
  "reference_solution": {
    "placements": [
      [0, 15, 11, 1], 
      [0, 11, 0, 1], 
      [0, 16, 0, 0], 
      [1, 21, 5, 1], 
      [1, 9, 11, 0], 
      [1, 5, 7, 1], 
      [2, 20, 11, 1], 
      [2, 0, 8, 1], 
      [2, 16, 5, 1], 
      [3, 0, 0, 1], 
      [3, 3, 4, 0], 
      [3, 6, 15, 0], 
      [4, 0, 14, 1], 
      [4, 5, 0, 1], 
      [4, 10, 7, 1]
    ],
    "total_value": 396
  },
  "solver_code": "from cpmpy import *\nimport json\n\ntable_dimensions = [25, 18]\nfabric_types = [[7, 5, 35, 3], [6, 4, 24, 3], [5, 5, 25, 3], [8, 3, 24, 3], [4, 6, 24, 3]]\nallow_rotation = 1\n\nplacements = []\nfor fabric_type_idx in range(len(fabric_types)):\n    for idx in range(fabric_types[fabric_type_idx][3]):\n        used = boolvar(name=f\"used_{fabric_type_idx}_{idx}\")\n        x = intvar(0, table_dimensions[0], name=f\"x_{fabric_type_idx}_{idx}\")\n        y = intvar(0, table_dimensions[1], name=f\"y_{fabric_type_idx}_{idx}\")\n        orientation = boolvar(name=f\"orientation_{fabric_type_idx}_{idx}\")\n        placements.append((fabric_type_idx, idx, used, x, y, orientation))\n\nmodel = Model()\n\nfor fabric_type_idx, idx, used, x, y, orientation in placements:\n    width, height, value, max_pieces = fabric_types[fabric_type_idx]\n    \n    if allow_rotation and width != height:\n        orig_fits = (orientation == 0) & (x + width <= table_dimensions[0]) & (y + height <= table_dimensions[1])\n        rot_fits = (orientation == 1) & (x + height <= table_dimensions[0]) & (y + width <= table_dimensions[1])\n        model += used.implies(orig_fits | rot_fits)\n    else:\n        model += used.implies((x + width <= table_dimensions[0]) & (y + height <= table_dimensions[1]))\n        if not allow_rotation:\n            model += used.implies(orientation == 0)\n\nfor i in range(len(placements)):\n    for j in range(i + 1, len(placements)):\n        ft1, idx1, used1, x1, y1, orient1 = placements[i]\n        ft2, idx2, used2, x2, y2, orient2 = placements[j]\n        \n        w1, h1, v1, max1 = fabric_types[ft1]\n        w2, h2, v2, max2 = fabric_types[ft2]\n        \n        width1 = w1 * (1 - orient1) + h1 * orient1\n        height1 = h1 * (1 - orient1) + w1 * orient1\n        width2 = w2 * (1 - orient2) + h2 * orient2\n        height2 = h2 * (1 - orient2) + w2 * orient2\n        \n        no_overlap = (x1 + width1 <= x2) | (x2 + width2 <= x1) | (y1 + height1 <= y2) | (y2 + height2 <= y1)\n        model += (used1 & used2).implies(no_overlap)\n\nfabric_type_counts = []\nfor fabric_type_idx in range(len(fabric_types)):\n    fabric_type_counts.append([])\n    \nfor fabric_type_idx, idx, used, x, y, orientation in placements:\n    fabric_type_counts[fabric_type_idx].append(used)\n    \nfor fabric_type_idx in range(len(fabric_types)):\n    used_count = sum(fabric_type_counts[fabric_type_idx])\n    model += used_count <= fabric_types[fabric_type_idx][3]\n\ntotal_value_expr = 0\nfor fabric_type_idx, idx, used, x, y, orientation in placements:\n    total_value_expr += used * fabric_types[fabric_type_idx][2]\n\nmodel.maximize(total_value_expr)\n\nif model.solve():\n    result = {\"placements\": [], \"total_value\": 0}\n    \n    for fabric_type_idx, idx, used, x, y, orientation in placements:\n        if used.value():\n            width, height, value, max_pieces = fabric_types[fabric_type_idx]\n            if orientation.value() == 0:\n                actual_width, actual_height = width, height\n            else:\n                actual_width, actual_height = height, width\n            \n            result[\"placements\"].append([fabric_type_idx, x.value(), y.value(), int(orientation.value())])\n            result[\"total_value\"] += value\n    \n    print(json.dumps(result))\nelse:\n    print(json.dumps({\"placements\": [], \"total_value\": 0}))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"placements\", \"total_value\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        placements = solution[\"placements\"]\n        total_value = solution[\"total_value\"]\n        table_dimensions = structured_data[\"table_dimensions\"]\n        fabric_types = structured_data[\"fabric_types\"]\n        allow_rotation = 1\n        \n        errors = []\n        \n        fabric_usage = [0] * len(fabric_types)\n        \n        for idx, placement in enumerate(placements):\n            if not isinstance(placement, list) or len(placement) != 4:\n                errors.append(f\"Placement {idx} must be an array with 4 elements [fabric_type, x, y, orientation]\")\n                continue\n            \n            fabric_type_idx = placement[0]\n            x = placement[1]\n            y = placement[2]\n            orientation = placement[3]\n            \n            if not isinstance(fabric_type_idx, int) or fabric_type_idx < 0 or fabric_type_idx >= len(fabric_types):\n                errors.append(f\"Placement {idx} has invalid fabric type index {fabric_type_idx}\")\n                continue\n            \n            if not all(isinstance(val, int) for val in [x, y]):\n                errors.append(f\"Placement {idx} has invalid coordinate values\")\n                continue\n            \n            if not isinstance(orientation, int) or orientation not in [0, 1]:\n                errors.append(f\"Placement {idx} has invalid orientation {orientation}\")\n                continue\n            \n            fabric_usage[fabric_type_idx] += 1\n            if fabric_usage[fabric_type_idx] > fabric_types[fabric_type_idx][3]:\n                errors.append(f\"Fabric type {fabric_type_idx} usage exceeds maximum available\")\n            \n            width, height, value, max_pieces = fabric_types[fabric_type_idx]\n            \n            if orientation == 0:\n                actual_width, actual_height = width, height\n            else:\n                if not allow_rotation:\n                    errors.append(f\"Placement {idx} uses rotation but rotation is not allowed\")\n                    continue\n                actual_width, actual_height = height, width\n            \n            if x < 0 or y < 0 or x + actual_width > table_dimensions[0] or y + actual_height > table_dimensions[1]:\n                errors.append(f\"Placement {idx} is out of table boundaries\")\n        \n        n = len(placements)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if i >= len(placements) or j >= len(placements):\n                    break\n                    \n                p1 = placements[i]\n                p2 = placements[j]\n                \n                x1, y1 = p1[1], p1[2]\n                x2, y2 = p2[1], p2[2]\n                ft1 = p1[0]\n                ft2 = p2[0]\n                \n                w1, h1, v1, max1 = fabric_types[ft1]\n                w2, h2, v2, max2 = fabric_types[ft2]\n                \n                width1 = w1 * (1 - p1[3]) + h1 * p1[3]\n                height1 = h1 * (1 - p1[3]) + w1 * p1[3]\n                width2 = w2 * (1 - p2[3]) + h2 * p2[3]\n                height2 = h2 * (1 - p2[3]) + w2 * p2[3]\n                \n                if not (x1 + width1 <= x2 or x2 + width2 <= x1 or y1 + height1 <= y2 or y2 + height2 <= y1):\n                    errors.append(f\"Placements {i} and {j} overlap\")\n        \n        calculated_value = 0\n        for placement in placements:\n            fabric_type_idx = placement[0]\n            calculated_value += fabric_types[fabric_type_idx][2]\n        \n        if abs(calculated_value - total_value) > 1e-6:\n            errors.append(f\"Total value inconsistency: calculated {calculated_value}, declared {total_value}\")\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_value = reference_solution[\"total_value\"]\n            if optimal_value == 0:\n                optimality_score = 1.0 if total_value == 0 else 0.0\n            else:\n                gap = abs(optimal_value - total_value) / abs(optimal_value)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}