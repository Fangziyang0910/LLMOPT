{
  "problem_id": "packing_unequal_rectangles_and_squares_003",
  "metadata": {
    "problem_type": "Packing unequal rectangles and squares",
    "difficulty": "hard"
  },
  "problem_description": "MegaStorage Logistics operates a massive circular storage facility spanning 94 meters in radius, with the yard's center located at coordinates (94.0, 94.0) in their facility management system. The logistics team faces a complex optimization challenge involving forty-one distinct rectangular storage containers that must be strategically arranged to maximize the number of containers that can be successfully accommodated within the circular boundary. The inventory consists of various container types designed for different storage needs: three compact square containers of 1.0 by 1.0 meters for small items, two rectangular containers of 1.2 by 0.8 meters for medium goods, two containers of 0.9 by 1.1 meters for specialized equipment, two containers of 1.1 by 1.3 meters for bulk materials, two containers of 1.4 by 1.2 meters for oversized items, two square containers of 1.5 by 1.5 meters for standard pallets, two larger square containers of 1.6 by 1.6 meters for industrial equipment, two containers of 1.3 by 1.3 meters for fragile goods, two square containers of 1.4 by 1.4 meters for heavy machinery, one premium square container of 1.7 by 1.7 meters for high-value items, one rectangular container of 1.8 by 1.5 meters for long products, one container of 1.2 by 1.8 meters for tall equipment, one container of 1.9 by 1.1 meters for narrow items, one container of 1.6 by 1.4 meters for medium machinery, one container of 1.3 by 1.7 meters for irregular shapes, one container of 1.5 by 1.2 meters for compact storage, one large square container of 1.8 by 1.8 meters for industrial use, one container of 1.1 by 1.5 meters for specialized storage, one container of 1.4 by 1.6 meters for custom items, one container of 1.7 by 1.3 meters for unique products, one container of 1.2 by 1.4 meters for standard goods, one oversized square container of 1.9 by 1.9 meters for bulk storage, one container of 1.6 by 1.8 meters for large equipment, one container of 1.5 by 1.7 meters for irregular cargo, one container of 1.3 by 1.5 meters for medium-sized products, one container of 1.8 by 1.2 meters for compact industrial goods, one container of 1.4 by 1.1 meters for specialized materials, one container of 1.7 by 1.6 meters for heavy-duty storage, one container of 1.5 by 1.9 meters for specialized materials, one container of 1.2 by 1.3 meters for heavy-duty storage, and one final container of 1.3 by 1.7 meters for oversized equipment. Each container can be positioned either in its standard orientation or rotated by ninety degrees to optimize space utilization, which is particularly important for the irregular-shaped containers and those with extreme aspect ratios. The storage operations team must ensure that every selected container fits completely within the circular boundary of the storage facility, with no portion extending beyond the facility's perimeter. Additionally, containers cannot overlap with each other - their spatial footprints must remain distinctly separate to maintain safety and accessibility standards.",  
  "solution_format_description": "Print the following fields: - placements: for each item, list placement with x, y, rotation angle. - total_count: total number of placed items.",
  "structured_data": {
    "platform_center": [94, 94],
    "platform_radius": 94,
    "cargo_items": [
      [1, 1],
      [1, 1],
      [1, 1],
      [1.2, 0.8],
      [1.2, 0.8],
      [0.9, 1.1],
      [0.9, 1.1],
      [1.1, 1.3],
      [1.1, 1.3],
      [1.4, 1.2],
      [1.4, 1.2],
      [1.5, 1.5],
      [1.5, 1.5],
      [1.6, 1.6],
      [1.6, 1.6],
      [1.3, 1.3],
      [1.3, 1.3],
      [1.4, 1.4],
      [1.4, 1.4],
      [1.7, 1.7],
      [1.8, 1.5],
      [1.2, 1.8],
      [1.9, 1.1],
      [1.6, 1.4],
      [1.3, 1.7],
      [1.5, 1.2],
      [1.8, 1.8],
      [1.1, 1.5],
      [1.4, 1.6],
      [1.7, 1.3],
      [1.2, 1.4],
      [1.9, 1.9],
      [1.6, 1.8],
      [1.5, 1.7],
      [1.3, 1.5],
      [1.8, 1.2],
      [1.4, 1.1],
      [1.7, 1.6],
      [1.5, 1.9],
      [1.2, 1.3],
      [1.3, 1.7]
    ]
  },
  "reference_solution": {
    "placements": [
      [87.14, 0.26, 0], 
      [183.7, 95.5, 0], 
      [92.46, 1.04, 0], 
      [82.23, 84.87, 0], 
      [102.66, 97.3, 0], 
      [96.35, 0.06, 0], 
      [102.57, 90.99, 0], 
      [91.19, 89.33, 90], 
      [94.96, 0.09, 0], 
      [98.45, 0.17, 90], 
      [97.25, 2.2, 90], 
      [90.64, 95.8, 0], 
      [92.75, 184.99, 0], 
      [79.54, 90.43, 0], 
      [82.22, 1.99, 0], 
      [80.94, 87.57, 0], 
      [82.64, 0.69, 0], 
      [81.14, 3.59, 0], 
      [79.36, 3.96, 0], 
      [85.44, 0.51, 0], 
      [80.44, 95.27, 0], 
      [103.47, 2.03, 0], 
      [81.13, 4.99, 90], 
      [86.56, 95.28, 90], 
      [77.96, 1.38, 0], 
      [104.67, 1.26, 0], 
      [90.64, 94.0, 0], 
      [93.46, 0.94, 90], 
      [87.95, 88.89, 90], 
      [80.95, 93.97, 0], 
      [101.17, 1.2, 90], 
      [80.75, 92.07, 0], 
      [83.82, 97.3, 0], 
      [83.94, 0.7, 0], 
      [89.34, 85.66, 0], 
      [88.14, 0.24, 90], 
      [80.82, 0.93, 0], 
      [0.37, 85.69, 90], 
      [81.15, 85.67, 0], 
      [91.26, 0.09, 0], 
      [89.89, 0.09, 0]
    ], 
    "total_count": 41
  },
  "solver_code": "from cpmpy import *\nimport json\n\nplatform_center = [94.0, 94.0]\nplatform_radius = 94.0\ncargo_items = [\n    [1, 1],\n    [1, 1],\n    [1, 1],\n    [1.2, 0.8],\n    [1.2, 0.8],\n    [0.9, 1.1],\n    [0.9, 1.1],\n    [1.1, 1.3],\n    [1.1, 1.3],\n    [1.4, 1.2],\n    [1.4, 1.2],\n    [1.5, 1.5],\n    [1.5, 1.5],\n    [1.6, 1.6],\n    [1.6, 1.6],\n    [1.3, 1.3],\n    [1.3, 1.3],\n    [1.4, 1.4],\n    [1.4, 1.4],\n    [1.7, 1.7],\n    [1.8, 1.5],\n    [1.2, 1.8],\n    [1.9, 1.1],\n    [1.6, 1.4],\n    [1.3, 1.7],\n    [1.5, 1.2],\n    [1.8, 1.8],\n    [1.1, 1.5],\n    [1.4, 1.6],\n    [1.7, 1.3],\n    [1.2, 1.4],\n    [1.9, 1.9],\n    [1.6, 1.8],\n    [1.5, 1.7],\n    [1.3, 1.5],\n    [1.8, 1.2],\n    [1.4, 1.1],\n    [1.7, 1.6],\n    [1.5, 1.9],\n    [1.2, 1.3],\n    [1.3, 1.7]\n]\n\nn = len(cargo_items)\nscale = 100\n\nplatform_center_x_scaled = int(platform_center[0] * scale)\nplatform_center_y_scaled = int(platform_center[1] * scale)\nplatform_radius_scaled = int(platform_radius * scale)\ncargo_items_scaled = [\n    [int(item[0] * scale), int(item[1] * scale)] for item in cargo_items\n]\n\nplaced = boolvar(shape=n)\nx = intvar(-scale, 2 * platform_center_x_scaled + scale, shape=n)\ny = intvar(-scale, 2 * platform_center_y_scaled + scale, shape=n)\nrotated = boolvar(shape=n)\n\nmodel = Model()\n\nfor i in range(n):\n    model += (placed[i] == 0).implies((x[i] == -scale) & (y[i] == -scale))\n\nwidths = []\nheights = []\nfor i in range(n):\n    w, h = cargo_items_scaled[i]\n    widths.append(intvar(min(w, h), max(w, h), name=f\"width_{i}\"))\n    heights.append(intvar(min(w, h), max(w, h), name=f\"height_{i}\"))\n    \n    model += (rotated[i] == 0).implies(widths[i] == w)\n    model += (rotated[i] == 0).implies(heights[i] == h)\n    model += (rotated[i] == 1).implies(widths[i] == h)\n    model += (rotated[i] == 1).implies(heights[i] == w)\n\nfor i in range(n):\n    for j in range(i + 1, n):\n        no_overlap = ((x[i] + widths[i] <= x[j]) | \n                     (x[j] + widths[j] <= x[i]) | \n                     (y[i] + heights[i] <= y[j]) | \n                     (y[j] + heights[j] <= y[i]))\n        \n        model += (placed[i] & placed[j]).implies(no_overlap)\n\nfor i in range(n):\n    corners = [\n        (x[i], y[i]),                    \n        (x[i] + widths[i], y[i]),        \n        (x[i], y[i] + heights[i]),        \n        (x[i] + widths[i], y[i] + heights[i])  \n    ]\n    \n    for corner_x, corner_y in corners:\n        dx = corner_x - platform_center_x_scaled\n        dy = corner_y - platform_center_y_scaled\n        model += (placed[i] == 1).implies(dx * dx + dy * dy <= platform_radius_scaled * platform_radius_scaled)\n\nmodel.maximize(sum(placed[i] for i in range(n)))\n\nif model.solve():\n    placements = []\n    total_count = 0\n    for i in range(n):\n        if placed[i].value():\n            center_x = x[i].value() / scale\n            center_y = y[i].value() / scale\n            theta = 90 if rotated[i].value() else 0\n            placements.append([round(center_x, 2), round(center_y, 2), theta])\n            total_count += 1\n        else:\n            placements.append([-1, -1, 0])\n    \n    result = {\"placements\": placements, \"total_count\": total_count}\n    print(json.dumps(result))\nelse:\n    print(json.dumps({\"placements\": [], \"total_count\": 0}))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    import math\n\n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n\n    required_fields = [\"placements\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n\n    try:\n        placements = solution[\"placements\"]\n        items = structured_data[\"cargo_items\"]\n        platform_center = structured_data[\"platform_center\"]\n        platform_cx, platform_cy = platform_center[0], platform_center[1]\n        platform_R = structured_data[\"platform_radius\"]\n        \n        errors = []\n        tol = 1e-5\n\n        if not isinstance(placements, list) or len(placements) != len(items):\n            errors.append(f\"Array length mismatch: expected {len(items)}, got {len(placements)}\")\n            return {\"is_valid\": False, \"validation_errors\": errors, \"optimality_score\": 0.0}\n\n        packed_count = 0\n        placed_items = []\n        total_area = 0\n\n        for idx, placement in enumerate(placements):\n            if not isinstance(placement, list) or len(placement) != 3:\n                errors.append(f\"Placement {idx} must be a list of [x, y, theta].\")\n                continue\n            \n            x, y, theta = placement\n\n            if x == -1 and y == -1:\n                continue\n\n            packed_count += 1\n\n            if not (math.isclose(theta, 0, abs_tol=1e-3) or math.isclose(theta, 90, abs_tol=1e-3)):\n                errors.append(f\"Item {idx}: rotation angle must be 0 or 90 degrees.\")\n\n            L, W = items[idx][0], items[idx][1]\n\n            if math.isclose(theta, 90, abs_tol=1e-3):\n                eff_L, eff_W = W, L\n            else:\n                eff_L, eff_W = L, W\n\n            half_L = eff_L / 2.0\n            half_W = eff_W / 2.0\n\n            if not (isinstance(x, (int, float)) and isinstance(y, (int, float))):\n                 errors.append(f\"Item {idx}: coordinates must be numbers.\")\n                 continue\n\n            corners = [\n                (x - half_L, y - half_W),\n                (x + half_L, y - half_W),\n                (x - half_L, y + half_W),\n                (x + half_L, y + half_W)\n            ]\n\n            for corner_x, corner_y in corners:\n                dist = math.hypot(corner_x - platform_cx, corner_y - platform_cy)\n                if dist > platform_R + tol:\n                    errors.append(f\"Item {idx}: corner ({corner_x:.2f}, {corner_y:.2f}) lies outside the circular boundary.\")\n\n            xmin = x - half_L\n            xmax = x + half_L\n            ymin = y - half_W\n            ymax = y + half_W\n            current_rect = (xmin, xmax, ymin, ymax, idx)\n            total_area += eff_L * eff_W\n\n            for other_rect in placed_items:\n                oxmin, oxmax, oymin, oymax, oidx = other_rect\n                if not (xmax <= oxmin + tol or xmin >= oxmax - tol or\n                        ymax <= oymin + tol or ymin >= oymax - tol):\n                    errors.append(f\"Item {idx} overlaps with item {oidx}.\")\n\n            placed_items.append(current_rect)\n\n        is_solution_valid = (len(errors) == 0)\n        \n        if not is_solution_valid:\n            return {\n                \"is_valid\": False,\n                \"validation_errors\": errors,\n                \"optimality_score\": 0.0\n            }\n        else:\n            optimal_area = reference_solution.get(\"total_area\", 0)\n            if optimal_area == 0:\n                optimality_score = 1.0 if total_area == 0 else 0.0\n            else:\n                gap = abs(optimal_area - total_area) / abs(optimal_area)\n                optimality_score = max(0, 1 - gap)\n\n            return {\n                \"is_valid\": True,\n                \"validation_errors\": [],\n                \"optimality_score\": optimality_score\n            }\n\n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality\": 0.0}"
}