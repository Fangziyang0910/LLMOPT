{
  "problem_id": "k_shortest_paths_003",
  "metadata": {
    "problem_type": "k-Shortest Paths Problem",
    "difficulty": "hard"
  },
  "problem_description": "A national water supply company operates a pipeline network with 30 pumping stations: a main water treatment plant, 28 intermediate pumping stations, and a major metropolitan area. The network contains 50 directed pipeline connections with varying pressure loss rates. From the main plant, lines connect to stations 1, 2, and 3 with losses of 3%, 5%, and 2% respectively. The first tier of stations 1, 2, and 3 each connect to two second-tier stations: station 1 connects to stations 4 and 5 with 4% and 3% loss, station 2 connects to stations 6 and 7 with 2% and 6% loss, and station 3 connects to stations 8 and 9 with 3% and 4% loss. The second tier continues branching: station 4 connects to stations 10 and 11 with 2% and 5% loss, station 5 connects to stations 12 and 13 with 3% and 4% loss, station 6 connects to stations 14 and 15 with 2% and 3% loss, and station 7 connects to stations 16 and 17 with 4% and 5% loss. The third tier expands further: station 8 connects to stations 18 and 19 with 3% and 2% loss, station 9 connects to stations 20 and 21 with 4% and 3% loss, station 10 connects to stations 22 and 23 with 2% and 5% loss, station 11 connects to stations 24 and 25 with 3% and 4% loss, station 12 connects to stations 26 and 27 with 2% and 3% loss, and station 13 connects to station 28 with 4% loss and directly to the metropolitan area with 2% loss. Cross-connections exist between different tiers: station 14 connects to station 22 with 3% loss, station 15 connects to station 23 with 4% loss, station 16 connects to station 24 with 2% loss, station 17 connects to station 25 with 5% loss, station 18 connects to station 26 with 3% loss, station 19 connects to station 27 with 4% loss, station 20 connects to station 28 with 2% loss, station 21 connects directly to the metropolitan area with 3% loss, station 22 connects to station 26 with 4% loss, station 23 connects to station 27 with 2% loss, station 24 connects to station 28 with 3% loss, and station 25 connects to the metropolitan area with 4% loss. Additional backup connections include station 1 to station 6 with 5% loss, station 2 to station 8 with 4% loss, station 3 to station 7 with 3% loss, station 4 to station 12 with 6% loss, station 5 to station 13 with 2% loss, station 14 to station 18 with 3% loss, station 15 to station 19 with 4% loss, station 16 to station 20 with 2% loss, station 17 to station 21 with 5% loss, station 22 to station 28 with 3% loss, station 23 to the metropolitan area with 4% loss. Each valid distribution route must follow the water flow direction, start at the main plant, end at the metropolitan area, and visit each station at most once. The company needs to find exactly 10 distinct distribution routes ranked from lowest to highest total pressure loss to ensure reliable water supply and provide backup options.",  
  "solution_format_description": "Print the following fields: - paths: water distribution routes from treatment plant to metropolitan area. - total_pressure_losses: total pressure loss percentage for each route.",
  "structured_data": {
    "pipe_connections": [
      [0, 1, 3],
      [0, 2, 5],
      [0, 3, 2],
      [1, 4, 4],
      [1, 5, 3],
      [2, 6, 2],
      [2, 7, 6],
      [3, 8, 3],
      [3, 9, 4],
      [4, 10, 2],
      [4, 11, 5],
      [5, 12, 3],
      [5, 13, 4],
      [6, 14, 2],
      [6, 15, 3],
      [7, 16, 4],
      [7, 17, 5],
      [8, 18, 3],
      [8, 19, 2],
      [9, 20, 4],
      [9, 21, 3],
      [10, 22, 2],
      [10, 23, 5],
      [11, 24, 3],
      [11, 25, 4],
      [12, 26, 2],
      [12, 27, 3],
      [13, 28, 4],
      [13, 29, 2],
      [14, 22, 3],
      [15, 23, 4],
      [16, 24, 2],
      [17, 25, 5],
      [18, 26, 3],
      [19, 27, 4],
      [20, 28, 2],
      [21, 29, 3],
      [22, 26, 4],
      [23, 27, 2],
      [24, 28, 3],
      [25, 29, 4],
      [1, 6, 5],
      [2, 8, 4],
      [3, 7, 3],
      [4, 12, 6],
      [5, 13, 2],
      [14, 18, 3],
      [15, 19, 4],
      [16, 20, 2],
      [17, 21, 5],
      [22, 28, 3],
      [23, 29, 4]
    ],
    "required_routes": 10
  },
  "reference_solution": {
    "paths": [
      [0, 1, 5, 13, 29],
      [0, 3, 9, 21, 29],
      [0, 1, 4, 10, 23, 29],
      [0, 2, 6, 15, 23, 29],
      [0, 3, 7, 17, 21, 29],
      [0, 1, 6, 15, 23, 29],
      [0, 3, 7, 17, 25, 29],
      [0, 1, 4, 11, 25, 29],
      [0, 2, 7, 17, 21, 29],
      [0, 2, 7, 17, 25, 29]
    ],
    "total_pressure_losses": [10, 12, 18, 18, 18, 19, 19, 20, 24, 25]
  },
  "solver_code": "",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"paths\", \"total_pressure_losses\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        paths = solution[\"paths\"]\n        total_pressure_losses = solution[\"total_pressure_losses\"]\n        pipe_connections = structured_data[\"pipe_connections\"]\n        required_routes = structured_data[\"required_routes\"]\n        errors = []\n        \n        if len(paths) != len(total_pressure_losses):\n            errors.append(f\"Paths and losses length mismatch: {len(paths)} vs {len(total_pressure_losses)}\")\n        \n        if len(paths) > required_routes:\n            errors.append(f\"Too many paths: {len(paths)}, maximum allowed: {required_routes}\")\n        \n        adj = {}\n        for u, v, loss in pipe_connections:\n            if u not in adj:\n                adj[u] = {}\n            adj[u][v] = loss\n        \n        for i, path in enumerate(paths):\n            if len(path) == 0:\n                errors.append(f\"Path {i} is empty\")\n                continue\n                \n            if path[0] != 0:\n                errors.append(f\"Path {i} does not start at source node 0: starts at {path[0]}\")\n            \n            if path[-1] != 29:\n                errors.append(f\"Path {i} does not end at target node 29: ends at {path[-1]}\")\n            \n            actual_loss = 0\n            for j in range(len(path) - 1):\n                u, v = path[j], path[j + 1]\n                if u not in adj or v not in adj[u]:\n                    errors.append(f\"Path {i} has invalid segment: {u} -> {v} (no direct connection)\")\n                    break\n                actual_loss += adj[u][v]\n            \n            if i < len(total_pressure_losses):\n                if abs(actual_loss - total_pressure_losses[i]) > 1e-6:\n                    errors.append(f\"Path {i} loss mismatch: calculated {actual_loss}, declared {total_pressure_losses[i]}\")\n            \n            if len(path) != len(set(path)):\n                errors.append(f\"Path {i} is not a simple path: contains repeated nodes\")\n        \n        unique_paths = []\n        for i, path in enumerate(paths):\n            path_tuple = tuple(path)\n            if path_tuple in unique_paths:\n                errors.append(f\"Path {i} is a duplicate of another path\")\n            else:\n                unique_paths.append(path_tuple)\n        \n        if not errors and len(paths) > 0:\n            optimal_losses = reference_solution[\"total_pressure_losses\"]\n            candidate_losses = total_pressure_losses[:len(optimal_losses)]\n            \n            total_optimal = sum(optimal_losses)\n            total_candidate = sum(candidate_losses)\n            \n            if total_optimal == 0:\n                optimality_score = 1.0 if total_candidate == 0 else 0.0\n            else:\n                gap = abs(total_optimal - total_candidate) / total_optimal\n                optimality_score = max(0, 1 - gap)\n        else:\n            optimality_score = 0.0\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}