{
  "problem_id": "constrained_non_guillotine_cutting_001",
  "metadata": {
    "problem_type": "Constrained Non-Guillotine Cutting Problem",
    "difficulty": "simple"
  },
  "problem_description": "A local community center is setting up a 10x10 foot exhibition booth for a craft fair and needs to arrange display tables of different sizes to showcase various handmade products. They have three types of display tables available:\n\n1. Standard craft tables: 4x3 feet, must include at least 1 but can set up up to 3, display value 15 points (ideal for pottery and ceramics)\n2. Long vendor tables: 5x2 feet, optional but can use up to 2, display value 12 points (perfect for textiles and fabrics)\n3. Square demonstration tables: 3x3 feet, needs at least 1 but no more than 2, display value 9 points (great for live craft demonstrations)\n\nEach table can be positioned either in its original orientation or rotated by 90 degrees. All tables must fit completely within the 10x10 foot booth space and cannot overlap with each other. The event organizer wants to determine the best arrangement of tables to achieve the maximum total display value while ensuring optimal visitor flow and accessibility throughout the booth.",
  "solution_format_description": "Print the following fields: - total_utility_value: total utility value of placed tables. - table_placements: for each table, list placements with table type, x, y, rotation.",
  "structured_data": {
    "container_dimensions": [10, 10],
    "item_inventory": [
      [4, 3, 1, 3, 15],
      [5, 2, 0, 2, 12],
      [3, 3, 1, 2, 9]
    ]
  },
  "reference_solution": {
    "total_utility_value": 87,
    "table_placements": [
      [2, 0, 0, 1],
      [3, 5, 7, 1],
      [1, 0, 5, 0],
      [1, 7, 3, 1],
      [1, 2, 1, 1],
      [3, 5, 0, 0],
      [2, 0, 8, 0]
    ]
  },
  "solver_code": "from cpmpy import *\nimport json\n\ncontainer_dimensions = [10, 10]\nitem_inventory = [\n    [4, 3, 1, 3, 15],\n    [5, 2, 0, 2, 12],\n    [3, 3, 1, 2, 9]\n]\n\ncontainer_length, container_width = container_dimensions\n\nmax_placements = sum(item[3] for item in item_inventory)\n\nmodel = Model()\n\npiece_types = intvar(1, len(item_inventory), shape=max_placements)\nx_coords = intvar(0, container_length, shape=max_placements)\ny_coords = intvar(0, container_width, shape=max_placements)\nrotations = boolvar(shape=max_placements)\nis_used = boolvar(shape=max_placements)\n\nfor idx in range(len(item_inventory)):\n    type_count = 0\n    for i in range(max_placements):\n        type_count += is_used[i] * (piece_types[i] == idx + 1)\n    model += type_count >= item_inventory[idx][2]\n    model += type_count <= item_inventory[idx][3]\n\nfor i in range(max_placements):\n    for t in range(len(item_inventory)):\n        item = item_inventory[t]\n        length = item[0]\n        width = item[1]\n        \n        M = max(container_length, container_width)\n        type_match = (piece_types[i] == t + 1)\n        \n        len_i = rotations[i] * width + (1 - rotations[i]) * length\n        wid_i = rotations[i] * length + (1 - rotations[i]) * width\n        \n        model += x_coords[i] + len_i <= container_length + M * (2 - is_used[i] - type_match)\n        model += y_coords[i] + wid_i <= container_width + M * (2 - is_used[i] - type_match)\n\nfor i in range(max_placements):\n    for j in range(i + 1, max_placements):\n        M = max(container_length, container_width)\n        \n        for ti in range(len(item_inventory)):\n            for tj in range(len(item_inventory)):\n                type_i_match = (piece_types[i] == ti + 1)\n                type_j_match = (piece_types[j] == tj + 1)\n                \n                len_i = rotations[i] * item_inventory[ti][1] + (1 - rotations[i]) * item_inventory[ti][0]\n                wid_i = rotations[i] * item_inventory[ti][0] + (1 - rotations[i]) * item_inventory[ti][1]\n                len_j = rotations[j] * item_inventory[tj][1] + (1 - rotations[j]) * item_inventory[tj][0]\n                wid_j = rotations[j] * item_inventory[tj][0] + (1 - rotations[j]) * item_inventory[tj][1]\n                \n                no_overlap_left = x_coords[i] + len_i <= x_coords[j] + M * (2 - is_used[i] - is_used[j] - type_i_match - type_j_match + 2)\n                no_overlap_right = x_coords[j] + len_j <= x_coords[i] + M * (2 - is_used[i] - is_used[j] - type_i_match - type_j_match + 2)\n                no_overlap_bottom = y_coords[i] + wid_i <= y_coords[j] + M * (2 - is_used[i] - is_used[j] - type_i_match - type_j_match + 2)\n                no_overlap_top = y_coords[j] + wid_j <= y_coords[i] + M * (2 - is_used[i] - is_used[j] - type_i_match - type_j_match + 2)\n                \n                model += no_overlap_left + no_overlap_right + no_overlap_bottom + no_overlap_top >= 1\n\ntotal_utility_value = 0\nfor i in range(max_placements):\n    for t in range(len(item_inventory)):\n        total_utility_value += is_used[i] * (piece_types[i] == t + 1) * item_inventory[t][4]\n\nmodel.maximize(total_utility_value)\n\nif model.solve():\n    result = {\n        \"total_utility_value\": total_utility_value.value(),\n        \"table_placements\": []\n    }\n    \n    for i in range(max_placements):\n        if is_used[i].value():\n            result[\"table_placements\"].append([\n                piece_types[i].value(),\n                x_coords[i].value(),\n                y_coords[i].value(),\n                int(rotations[i].value())\n            ])\n    \n    print(json.dumps(result))\nelse:\n    print(json.dumps({\"total_utility_value\": 0, \"table_placements\": []}))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"total_utility_value\", \"table_placements\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        total_utility_value = solution[\"total_utility_value\"]\n        table_placements = solution[\"table_placements\"]\n        booth_length = structured_data[\"booth_length\"]\n        booth_width = structured_data[\"booth_width\"]\n        tables = structured_data[\"table\"]\n        errors = []\n        \n        if not isinstance(table_placements, list):\n            errors.append(\"table_placements must be a list\")\n            return {\"is_valid\": False, \"validation_errors\": errors, \"optimality_score\": 0.0}\n        \n        table_counts = [0] * len(tables)\n        \n        valid_placements = []\n        for i, placement in enumerate(table_placements):\n            if not isinstance(placement, list) or len(placement) != 4:\n                errors.append(f\"Placement {i} must be a list of 4 elements\")\n                continue\n                \n            table_type, x, y, rotation = placement\n            \n            if not isinstance(table_type, int) or table_type < 1 or table_type > len(tables):\n                errors.append(f\"Placement {i}: invalid table type {table_type}\")\n                continue\n                \n            table_idx = table_type - 1\n            table_counts[table_idx] += 1\n            \n            table_info = tables[table_idx]\n            length = table_info[\"length\"]\n            width = table_info[\"width\"]\n            \n            if rotation:\n                length, width = width, length\n            \n            if x < 0 or y < 0:\n                errors.append(f\"Placement {i}: negative coordinates ({x}, {y})\")\n                \n            if x + length > booth_length:\n                errors.append(f\"Placement {i}: exceeds booth length ({x} + {length} > {booth_length})\")\n                \n            if y + width > booth_width:\n                errors.append(f\"Placement {i}: exceeds booth width ({y} + {width} > {booth_width})\")\n                \n            valid_placements.append((table_type, x, y, length, width))\n        \n        for i, table_info in enumerate(tables):\n            count = table_counts[i]\n            min_required = table_info[\"min_required\"]\n            max_allowed = table_info[\"max_allowed\"]\n            \n            if count < min_required:\n                errors.append(f\"Table type {i+1}: below minimum required ({count} < {min_required})\")\n                \n            if count > max_allowed:\n                errors.append(f\"Table type {i+1}: exceeds maximum allowed ({count} > {max_allowed})\")\n        \n        for i in range(len(valid_placements)):\n            for j in range(i + 1, len(valid_placements)):\n                table_type1, x1, y1, length1, width1 = valid_placements[i]\n                table_type2, x2, y2, length2, width2 = valid_placements[j]\n                \n                if not (x1 + length1 <= x2 or x2 + length2 <= x1 or y1 + width1 <= y2 or y2 + width2 <= y1):\n                    errors.append(f\"Overlap between placement {i} and {j}\")\n        \n        calculated_utility = 0\n        for placement in table_placements:\n            if len(placement) == 4:\n                table_type = placement[0]\n                if 1 <= table_type <= len(tables):\n                    table_idx = table_type - 1\n                    table_info = tables[table_idx]\n                    length = table_info[\"length\"]\n                    width = table_info[\"width\"]\n                    x, y = placement[1], placement[2]\n                    rotation = placement[3]\n                    \n                    if rotation:\n                        length, width = width, length\n                    \n                    if (x >= 0 and y >= 0 and \n                        x + length <= booth_length and \n                        y + width <= booth_width):\n                        calculated_utility += tables[table_type - 1][\"utility_value\"]\n        \n        if abs(calculated_utility - total_utility_value) > 1e-6:\n            errors.append(f\"Utility value inconsistency: calculated {calculated_utility}, declared {total_utility_value}\")\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_value = reference_solution[\"total_utility_value\"]\n            if optimal_value == 0:\n                optimality_score = 1.0 if total_utility_value == 0 else 0.0\n            else:\n                gap = abs(optimal_value - total_utility_value) / abs(optimal_value)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}