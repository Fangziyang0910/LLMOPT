{
  "problem_id": "assortment_problem_003",
  "metadata": {
    "problem_type": "Assortment Problem",
    "difficulty": "hard"
  },
  "problem_description": "A glass factory needs to cut smaller rectangular glass panels from two available standard sheet sizes to fulfill a custom order. The factory has two types of standard glass sheets: 1) Wide sheets of 95 cm by 80 cm; 2) Narrow sheets of 70 cm by 65 cm. They need to produce five types of smaller panels for a display project:\n1. Large panels: 45 cm by 30 cm, they need at least 2 and at most 4 of these.\n2. Medium panels: 35 cm by 25 cm, they need at least 2 and at most 5 of these.\n3. Square panels: 22 cm by 22 cm, they need at least 1 and at most 3 of these.\n4. Small panels: 18 cm by 12 cm, they need at least 2 and at most 4 of these.\n5. Extra large panels: 50 cm by 40 cm, they need at least 2 and at most 3 of these.\n\nThe factory wants to determine how to cut these panels from the standard sheets to minimize material waste. They can use as many sheets of each type as needed, but they want to limit themselves to using at most two different sheet types in their cutting plan. Each panel can be cut with its original orientation or rotated by 90 degrees. All panels must fit completely within the sheets, and no panels can overlap on the same sheet.",
  "solution_format_description": "Print the following fields: - waste_rate: percentage of fabric wasted. - sheet_instances: for each sheet_type, list placements with piece, x, y, orientation. - panel_counts: how many of each panel type are cut. - total_sheet_area: sum of all sheet areas used. - total_used_area: sum of all panel areas.",
  "structured_data": {
    "num_sheets": 2,
    "num_panels": 5,
    "sheets": [
      [95, 80],
      [70, 65]
    ],
    "panels": [
      [45, 30, 2, 4],
      [35, 25, 2, 5],
      [22, 22, 1, 3],
      [18, 12, 2, 4],
      [50, 40, 2, 3]
    ]
  },
  "reference_solution": {
    "waste_rate": 0.027489711934156377,
    "sheet_instances": [
      [
        [1, 0, 35, 1],
        [1, 25, 0, 0],
        [2, 0, 0, 1],
        [2, 70, 23, 1],
        [3, 70, 58, 0],
        [3, 70, 1, 0],
        [5, 30, 30, 1]
      ],
      [
        [2, 35, 40, 0],
        [2, 0, 40, 0],
        [4, 0, 0, 0],
        [4, 0, 12, 0],
        [4, 0, 24, 0],
        [5, 18, 0, 0]
      ]
    ],
    "panel_counts": [2, 4, 2, 3, 2],
    "total_sheet_area": 12150,
    "total_used_area": 11816
  },
  "solver_code": "from cpmpy import *\nimport json\n\nnum_sheets = 2\nnum_panels = 5\n\nsheets = [\n    [95, 80],\n    [70, 65]\n]\n\npanels = [\n    [45, 30, 2, 4],\n    [35, 25, 2, 5],\n    [22, 22, 1, 3],\n    [18, 12, 2, 4],\n    [50, 40, 2, 3]\n]\n\nnum_panels = len(panels)\nnum_sheet_types = len(sheets)\n\nsheet_types = list(range(num_sheet_types))\nsheet_width_cm = {i: sheets[i][0] for i in sheet_types}\nsheet_height_cm = {i: sheets[i][1] for i in sheet_types}\nsheet_area_cm2 = {s: sheet_width_cm[s] * sheet_height_cm[s] for s in sheet_types}\n\nmax_sheet_types_used = 2\n\npanel_types = list(range(num_panels))\nitem_width_cm_type = {p: panels[p][0] for p in panel_types}\nitem_height_cm_type = {p: panels[p][1] for p in panel_types}\nitem_area_cm2_type = {p: item_width_cm_type[p] * item_height_cm_type[p] for p in panel_types}\nmin_count_type = {p: panels[p][2] for p in panel_types}\nmax_count_type = {p: panels[p][3] for p in panel_types}\n\nP_t = {}\nP_index_to_type = []\nfor t in panel_types:\n    count = max_count_type[t]\n    P_t[t] = list(range(len(P_index_to_type), len(P_index_to_type) + count))\n    for _ in range(count):\n        P_index_to_type.append(t)\nP = list(range(len(P_index_to_type)))\nP_count = len(P)\n\nitem_width_cm = {p: item_width_cm_type[P_index_to_type[p]] for p in P}\nitem_height_cm = {p: item_height_cm_type[P_index_to_type[p]] for p in P}\nitem_area_cm2 = {p: item_area_cm2_type[P_index_to_type[p]] for p in P}\nitem_type_of_p = {p: P_index_to_type[p] for p in P}\n\ntotal_max_panel_area_cm2 = sum(max_count_type[t] * item_area_cm2_type[t] for t in panel_types)\nK_s = {s: (total_max_panel_area_cm2 + sheet_area_cm2[s] - 1) // sheet_area_cm2[s] for s in sheet_types}\n\nsheet_instances = []\nfor s in sheet_types:\n    for k in range(K_s[s]):\n        sheet_instances.append((s, k))\nK = list(range(len(sheet_instances)))\nK_count = len(K)\n\ninst_sheet_type = [sheet_instances[j][0] for j in K]\ninst_sheet_k = [sheet_instances[j][1] for j in K]\ninst_width = [sheet_width_cm[inst_sheet_type[j]] for j in K]\ninst_height = [sheet_height_cm[inst_sheet_type[j]] for j in K]\ninst_area = [sheet_area_cm2[inst_sheet_type[j]] for j in K]\n\nmax_sheet_width_cm = max(sheet_width_cm.values())\nmax_sheet_height_cm = max(sheet_height_cm.values())\nMx = max_sheet_width_cm\nMy = max_sheet_height_cm\n\nmodel = Model()\n\nproduce = boolvar(shape=P_count, name=\"produce\")\nr = boolvar(shape=P_count, name=\"r\")\nassign = boolvar(shape=(P_count, K_count), name=\"assign\")\nx = intvar(0, max_sheet_width_cm, shape=P_count, name=\"x\")\ny = intvar(0, max_sheet_height_cm, shape=P_count, name=\"y\")\ny_sheet = boolvar(shape=K_count, name=\"y_sheet\")\ny_type = {s: boolvar(name=f\"y_type_{s}\") for s in sheet_types}\n\nmax_total_sheet_area = sum(inst_area)\ntotal_sheet_area_cm2 = intvar(0, max_total_sheet_area, name=\"total_sheet_area_cm2\")\ntotal_used_area_cm2 = intvar(0, total_max_panel_area_cm2, name=\"total_used_area_cm2\")\nwaste_area_cm2 = intvar(0, max_total_sheet_area, name=\"waste_area_cm2\")\n\nfor p in P:\n    model += (sum(assign[p, :]) == produce[p])\n\nfor p in P:\n    for j in K:\n        model += (assign[p, j] <= produce[p])\n\nfor p in P:\n    model += (r[p] <= produce[p])\n\nwidth_expr = {}\nheight_expr = {}\nfor p in P:\n    w = item_width_cm[p]\n    h = item_height_cm[p]\n    width_expr[p] = w + r[p] * (h - w)\n    height_expr[p] = h + r[p] * (w - h)\n\nfor p in P:\n    for j in K:\n        Wj = inst_width[j]\n        Hj = inst_height[j]\n        model += (x[p] + width_expr[p] <= Wj + Mx * (1 - assign[p, j]))\n        model += (y[p] + height_expr[p] <= Hj + My * (1 - assign[p, j]))\n\nfor j in K:\n    for p in range(P_count):\n        for q in range(p + 1, P_count):\n            both_assigned = assign[p, j] & assign[q, j]\n            no_overlap = (\n                (x[p] + width_expr[p] <= x[q]) |\n                (x[q] + width_expr[q] <= x[p]) |\n                (y[p] + height_expr[p] <= y[q]) |\n                (y[q] + height_expr[q] <= y[p])\n            )\n            model += both_assigned.implies(no_overlap)\n\nfor j in K:\n    model += (sum(assign[:, j]) >= y_sheet[j])\n    model += (sum(assign[:, j]) <= P_count * y_sheet[j])\n    for p in P:\n        model += (assign[p, j] <= y_sheet[j])\n\nfor s in sheet_types:\n    related_instances = [j for j in K if inst_sheet_type[j] == s]\n    for j in related_instances:\n        model += (y_type[s] >= y_sheet[j])\n    if related_instances:\n        model += (y_type[s] <= sum([y_sheet[j] for j in related_instances]))\n\nmodel += (sum([y_type[s] for s in sheet_types]) <= max_sheet_types_used)\n\nfor t in panel_types:\n    indices = P_t[t]\n    model += (sum([produce[p] for p in indices]) >= min_count_type[t])\n    model += (sum([produce[p] for p in indices]) <= max_count_type[t])\n\nmodel += (total_sheet_area_cm2 == sum([y_sheet[j] * inst_area[j] for j in K]))\nmodel += (total_sheet_area_cm2 >= 1)\nmodel += (total_used_area_cm2 == sum([produce[p] * item_area_cm2[p] for p in P]))\nmodel += (waste_area_cm2 == total_sheet_area_cm2 - total_used_area_cm2)\nmodel += (waste_area_cm2 >= 0)\n\nmodel.minimize(waste_area_cm2)\n\nsolved = model.solve(time_limit=30)\n\nif solved:\n    produce_val = produce.value().astype(int).tolist()\n    r_val = r.value().astype(int).tolist()\n    assign_val = assign.value().astype(int).tolist()\n    x_val = x.value().tolist()\n    y_val = y.value().tolist()\n    y_sheet_val = y_sheet.value().astype(int).tolist()\n    total_sheet_area_val = int(total_sheet_area_cm2.value())\n    total_used_area_val = int(total_used_area_cm2.value())\n    waste_area_val = int(waste_area_cm2.value())\n    waste_rate = 0.0\n    if total_sheet_area_val > 0:\n        waste_rate = waste_area_val / total_sheet_area_val\n\n    sheet_instances_by_type = [[] for _ in range(num_sheet_types + 1)]\n    for j in K:\n        if y_sheet_val[j] == 1:\n            s = inst_sheet_type[j] + 1\n            for p in P:\n                if assign_val[p][j] == 1:\n                    placement = [int(item_type_of_p[p]) + 1, int(x_val[p]), int(y_val[p]), int(r_val[p])]\n                    sheet_instances_by_type[s].append(placement)\n    \n    sheet_instances = [placements for placements in sheet_instances_by_type[1:] if placements]\n\n    panel_counts = []\n    for t in panel_types:\n        cnt = sum(produce_val[p] for p in P_t[t])\n        panel_counts.append(int(cnt))\n\n    result = {\n        \"waste_rate\": float(waste_rate),\n        \"sheet_instances\": sheet_instances,\n        \"panel_counts\": panel_counts,\n        \"total_sheet_area\": int(total_sheet_area_val),\n        \"total_used_area\": int(total_used_area_val)\n    }\n    \n    print(json.dumps(result))\n\nelse:\n    result = {\n        \"waste_rate\": 1.0,\n        \"sheet_instances\": [[]],\n        \"panel_counts\": [p[2] for p in panels],\n        \"total_sheet_area\": sheets[0][0] * sheets[0][1],\n        \"total_used_area\": 0\n    }\n    print(json.dumps(result))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n\n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n\n    required_fields = [\"waste_rate\", \"sheet_instances\", \"panel_counts\", \"total_sheet_area\", \"total_used_area\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n\n    try:\n        waste_rate = solution[\"waste_rate\"]\n        sheet_instances = solution[\"sheet_instances\"]\n        panel_counts = solution[\"panel_counts\"]\n        total_sheet_area = solution[\"total_sheet_area\"]\n        total_used_area = solution[\"total_used_area\"]\n        \n        sheets = structured_data[\"sheets\"]\n        panels = structured_data[\"panels\"]\n        errors = []\n        \n        if len(panel_counts) != len(panels):\n            errors.append(f\"Panel counts length mismatch: expected {len(panels)}, got {len(panel_counts)}\")\n        \n        for i, panel in enumerate(panels):\n            count = panel_counts[i] if i < len(panel_counts) else 0\n            if count < panel[2] or count > panel[3]:\n                errors.append(f\"Panel count violation for panel type {i+1}: count = {count}, required min = {panel[2]}, max = {panel[3]}\")\n        \n        for instance in sheet_instances:\n            if not isinstance(instance, list):\n                errors.append(\"Invalid sheet instance structure\")\n                continue\n            \n            for placement in instance:\n                if len(placement) != 4:\n                    errors.append(\"Invalid placement structure\")\n                    continue\n                \n                panel_type = placement[0]\n                if not (1 <= panel_type <= len(panels)):\n                    errors.append(f\"Invalid panel type in placement: {panel_type}\")\n        \n        optimal_waste_rate = reference_solution[\"waste_rate\"]\n        if optimal_waste_rate == 0:\n            optimality_score = 1.0 if waste_rate == 0 else 0.0\n        else:\n            gap = abs(optimal_waste_rate - waste_rate) / abs(optimal_waste_rate)\n            optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}