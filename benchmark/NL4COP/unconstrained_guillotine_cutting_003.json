{
  "problem_id": "unconstrained_guillotine_cutting_003",
  "metadata": {
    "problem_type": "unconstrained guillotine cutting problem",
    "difficulty": "hard"
  },
  "problem_description": "An interior design studio needs to cut rectangular panels from a large sheet measuring 1000 centimeters by 1000 centimeters. The cutting process uses straight edge-to-edge cuts that go completely across the material from one side to the other. The designer can make these cuts in any order and organize them freely without restrictions. The studio has 30 different panel types available, each with specific dimensions and aesthetic values based on design importance and material efficiency. Some panels have fixed orientation requirements due to pattern direction or material grain, while others can be rotated 90 degrees to better fit the available space. The designer can choose any combination of panels, but they must not overlap and must be completely contained within the sheet boundaries. Available panels include: Panel 1: 572 cm long, 665 cm wide, aesthetic value 380380 (Fixed orientation); Panel 2: 482 cm long, 640 cm wide, aesthetic value 308480 (Fixed orientation); Panel 3: 264 cm long, 594 cm wide, aesthetic value 156816 (Fixed orientation); Panel 4: 349 cm long, 566 cm wide, aesthetic value 197534 (Fixed orientation); Panel 5: 276 cm long, 660 cm wide, aesthetic value 182160 (Fixed orientation); Panel 6: 745 cm long, 422 cm wide, aesthetic value 314390 (Fixed orientation); Panel 7: 434 cm long, 622 cm wide, aesthetic value 269948 (Fixed orientation); Panel 8: 446 cm long, 433 cm wide, aesthetic value 193118 (Fixed orientation); Panel 9: 668 cm long, 506 cm wide, aesthetic value 338008 (Fixed orientation); Panel 10: 405 cm long, 635 cm wide, aesthetic value 257175 (Fixed orientation); Panel 11: 290 cm long, 605 cm wide, aesthetic value 175450 (Can be rotated); Panel 12: 321 cm long, 520 cm wide, aesthetic value 166920 (Can be rotated); Panel 13: 543 cm long, 290 cm wide, aesthetic value 157470 (Can be rotated); Panel 14: 599 cm long, 269 cm wide, aesthetic value 161131 (Can be rotated); Panel 15: 467 cm long, 679 cm wide, aesthetic value 317093 (Can be rotated); Panel 16: 583 cm long, 421 cm wide, aesthetic value 245443 (Can be rotated); Panel 17: 729 cm long, 723 cm wide, aesthetic value 527067 (Can be rotated); Panel 18: 465 cm long, 590 cm wide, aesthetic value 274350 (Can be rotated); Panel 19: 614 cm long, 585 cm wide, aesthetic value 359190 (Can be rotated); Panel 20: 446 cm long, 327 cm wide, aesthetic value 145842 (Can be rotated); Panel 21: 277 cm long, 426 cm wide, aesthetic value 118002 (Can be rotated); Panel 22: 254 cm long, 685 cm wide, aesthetic value 173990 (Can be rotated); Panel 23: 483 cm long, 532 cm wide, aesthetic value 256956 (Can be rotated); Panel 24: 678 cm long, 414 cm wide, aesthetic value 280692 (Can be rotated); Panel 25: 546 cm long, 590 cm wide, aesthetic value 322140 (Can be rotated); Panel 26: 716 cm long, 640 cm wide, aesthetic value 458240 (Can be rotated); Panel 27: 542 cm long, 400 cm wide, aesthetic value 216800 (Can be rotated); Panel 28: 634 cm long, 596 cm wide, aesthetic value 377864 (Can be rotated); Panel 29: 497 cm long, 696 cm wide, aesthetic value 345912 (Can be rotated); Panel 30: 417 cm long, 300 cm wide, aesthetic value 125100 (Can be rotated). How should the designer arrange these panels using guillotine cutting to maximize the total aesthetic value?",
  "solution_format_description": "Print the following fields: - placements: for each panel, list placement with index, x, y, rotation. - total_aesthetic_value: total value of placed panels.",  
  "structured_data": {
    "sheet_dimensions": [1000, 1000],
    "design_panels": [
      [572, 665, 380380, 1], 
      [482, 640, 308480, 1], 
      [264, 594, 156816, 1], 
      [349, 566, 197534, 1], 
      [276, 660, 182160, 1], 
      [745, 422, 314390, 1], 
      [434, 622, 269948, 1], 
      [446, 433, 193118, 1], 
      [668, 506, 338008, 1], 
      [405, 635, 257175, 1], 
      [290, 605, 175450, 0], 
      [321, 520, 166920, 0], 
      [543, 290, 157470, 0], 
      [599, 269, 161131, 0], 
      [467, 679, 317093, 0], 
      [583, 421, 245443, 0], 
      [729, 723, 527067, 0], 
      [465, 590, 274350, 0], 
      [614, 585, 359190, 0], 
      [446, 327, 145842, 0], 
      [277, 426, 118002, 0], 
      [254, 685, 173990, 0], 
      [483, 532, 256956, 0], 
      [678, 414, 280692, 0], 
      [546, 590, 322140, 0], 
      [716, 640, 458240, 0], 
      [542, 400, 216800, 0], 
      [634, 596, 377864, 0], 
      [497, 696, 345912, 0], 
      [417, 300, 125100, 0]
    ]
  },
  "reference_solution": {
    "placements": [
      [0, 0, 0, 0], 
      [11, 468, 678, 1], 
      [19, 22, 665, 0], 
      [23, 572, 0, 1]
    ],
    "total_aesthetic_value": 973834
  },
  "solver_code": "from cpmpy import *\nimport json\n\nsheet_dimensions = [1000, 1000]\ndesign_panels = [\n    [572, 665, 380380, 1], \n    [482, 640, 308480, 1], \n    [264, 594, 156816, 1], \n    [349, 566, 197534, 1], \n    [276, 660, 182160, 1], \n    [745, 422, 314390, 1], \n    [434, 622, 269948, 1], \n    [446, 433, 193118, 1], \n    [668, 506, 338008, 1], \n    [405, 635, 257175, 1], \n    [290, 605, 175450, 0], \n    [321, 520, 166920, 0], \n    [543, 290, 157470, 0], \n    [599, 269, 161131, 0], \n    [467, 679, 317093, 0], \n    [583, 421, 245443, 0], \n    [729, 723, 527067, 0], \n    [465, 590, 274350, 0], \n    [614, 585, 359190, 0], \n    [446, 327, 145842, 0], \n    [277, 426, 118002, 0], \n    [254, 685, 173990, 0], \n    [483, 532, 256956, 0], \n    [678, 414, 280692, 0], \n    [546, 590, 322140, 0], \n    [716, 640, 458240, 0], \n    [542, 400, 216800, 0], \n    [634, 596, 377864, 0], \n    [497, 696, 345912, 0], \n    [417, 300, 125100, 0]\n]\nnum_panels = len(design_panels)\n\nx = intvar(0, sheet_dimensions[0], shape=num_panels)\ny = intvar(0, sheet_dimensions[1], shape=num_panels)\norientation = boolvar(shape=num_panels)\nselected = boolvar(shape=num_panels)\n\nconstraints = []\n\nfor i in range(num_panels):\n    length, width, aesthetic_value, fixed_orientation = design_panels[i]\n    \n    if fixed_orientation == 1:\n        constraints += [orientation[i] == 0]\n        \n    eff_length = length * (1 - orientation[i]) + width * orientation[i]\n    eff_width = width * (1 - orientation[i]) + length * orientation[i]\n        \n    constraints += [selected[i].implies(x[i] + eff_length <= sheet_dimensions[0])]\n    constraints += [selected[i].implies(y[i] + eff_width <= sheet_dimensions[1])]\n    \n    for j in range(i + 1, num_panels):\n        length_j, width_j, aesthetic_value_j, fixed_orientation_j = design_panels[j]\n        \n        if fixed_orientation_j == 1:\n            constraints += [orientation[j] == 0]\n            \n        eff_length_j = length_j * (1 - orientation[j]) + width_j * orientation[j]\n        eff_width_j = width_j * (1 - orientation[j]) + length_j * orientation[j]\n            \n        constraints += [(selected[i] & selected[j]).implies(\n            (x[i] + eff_length <= x[j]) | (x[j] + eff_length_j <= x[i]) | (y[i] + eff_width <= y[j]) | (y[j] + eff_width_j <= y[i])\n        )]\n\nobjective = sum(selected[i] * design_panels[i][2] for i in range(num_panels))\n\nmodel = Model(constraints)\nmodel.maximize(objective)\n\nif model.solve():\n    placements = []\n    total_aesthetic_value = 0\n    for i in range(num_panels):\n        if selected[i].value() == 1:\n            orient = int(orientation[i].value())\n            placements.append([i, int(x[i].value()), int(y[i].value()), orient])\n            total_aesthetic_value += design_panels[i][2]\n    \n    result = {\"placements\": placements, \"total_aesthetic_value\": total_aesthetic_value}\n    print(json.dumps(result))\nelse:\n    print(json.dumps({\"placements\": [], \"total_aesthetic_value\": 0}))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        if isinstance(candidate_solution, str):\n            solution = json.loads(candidate_solution)\n        else:\n            solution = candidate_solution\n    except Exception:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n\n    required_fields = [\"placements\", \"total_aesthetic_value\"]\n    missing = [f for f in required_fields if f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n\n    try:\n        placements = solution[\"placements\"]\n        total_aesthetic_value = solution[\"total_aesthetic_value\"]\n        design_panels = structured_data[\"design_panels\"]\n        sheet_dimensions = structured_data[\"sheet_dimensions\"]\n        errors = []\n\n        placed_indices = [p[0] for p in placements]\n        if len(placed_indices) != len(set(placed_indices)):\n            errors.append(\"Duplicate panel placements detected.\")\n\n        placed_rects = []\n        calculated_total_value = 0\n        for placement in placements:\n            panel_idx, x, y, orientation = placement\n            \n            if not (0 <= panel_idx < len(design_panels)):\n                errors.append(f\"Panel index {panel_idx} is invalid.\")\n                continue\n            \n            if not (isinstance(x, int) and isinstance(y, int)):\n                errors.append(f\"Coordinates for panel {panel_idx} must be integers.\")\n                continue\n\n            if orientation not in [0, 1]:\n                errors.append(f\"Invalid orientation {orientation} for panel {panel_idx}; must be 0 or 1.\")\n                continue\n                \n            length, width, aesthetic_value, fixed_orientation = design_panels[panel_idx]\n            \n            if fixed_orientation == 1 and orientation != 0:\n                errors.append(f\"Panel {panel_idx} has fixed orientation and must be placed with orientation 0.\")\n\n            if orientation == 0:\n                p_length = length\n                p_width = width\n            else:\n                p_length = width\n                p_width = length\n\n            if x < 0 or y < 0 or (x + p_length) > sheet_dimensions[0] or (y + p_width) > sheet_dimensions[1]:\n                errors.append(f\"Placement of panel {panel_idx} is out of sheet boundaries.\")\n\n            placed_rects.append([x, y, x + p_length, y + p_width, panel_idx])\n            calculated_total_value += aesthetic_value\n\n        for i in range(len(placed_rects)):\n            for j in range(i + 1, len(placed_rects)):\n                r1 = placed_rects[i]\n                r2 = placed_rects[j]\n                if not (r1[2] <= r2[0] or r2[2] <= r1[0] or r1[3] <= r2[1] or r2[3] <= r1[1]):\n                    errors.append(f\"Overlapping detected between panel {r1[4]} and panel {r2[4]}.\")\n\n        if calculated_total_value != total_aesthetic_value:\n            errors.append(f\"Total aesthetic value inconsistency: calculated {calculated_total_value}, declared {total_aesthetic_value}\")\n\n        is_valid_solution = (len(errors) == 0)\n        \n        if is_valid_solution:\n            optimal_value = reference_solution[\"total_aesthetic_value\"]\n            if optimal_value == 0:\n                optimality_score = 1.0 if total_aesthetic_value == 0 else 0.0\n            else:\n                gap = abs(optimal_value - total_aesthetic_value) / abs(optimal_value)\n                optimality_score = max(0, 1 - gap)\n        else:\n            optimality_score = 0.0\n\n        return {\n            \"is_valid\": is_valid_solution,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n\n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data or evaluation logic\"], \"optimality_score\": 0.0}"
}