{
  "problem_id": "chinese_postman_001",
  "metadata": {
    "problem_type": "Chinese Postman Problem",
    "difficulty": "simple"
  },
  "problem_description": "A city maintenance department needs to plan an efficient route for a street cleaning vehicle that must cover all streets in a residential neighborhood. The neighborhood has 7 intersections connected by 8 street segments. The vehicle needs to clean every street at least once and return to where it started to complete the cleaning route. The specific street information is the street connecting intersections 1 and 2 is 5.39 kilometers long and requires 15.0 minutes to clean, the street connecting intersections 2 and 5 is 7.62 kilometers long and requires 20.0 minutes to clean, the street connecting intersections 5 and 0 is 3.61 kilometers long and requires 12.0 minutes to clean, the street connecting intersections 0 and 3 is 7.21 kilometers long and requires 18.0 minutes to clean, the street connecting intersections 3 and 4 is 5.83 kilometers long and requires 16.0 minutes to clean, the street connecting intersections 4 and 6 is 2.83 kilometers long and requires 10.0 minutes to clean, the street connecting intersections 6 and 0 is 7.07 kilometers long and requires 19.0 minutes to clean, and the street connecting intersections 0 and 1 is 8.0 kilometers long and requires 22.0 minutes to clean. Each street must be cleaned completely when first traversed, and the vehicle may need to traverse some streets multiple times (without additional cleaning) to complete an efficient closed route. How should the department plan the route to minimize the total cost of travel distance and cleaning time?",
  "solution_format_description": "Print the following fields: - route: sequence of intersections visited. - total_cost: total distance and cleaning time cost.",
  "structured_data": {
    "num_intersections": 7,
    "streets": [
      [1, 2, 5.39, 15.0],
      [2, 5, 7.62, 20.0],
      [5, 0, 3.61, 12.0],
      [0, 3, 7.21, 18.0],
      [3, 4, 5.83, 16.0],
      [4, 6, 2.83, 10.0],
      [6, 0, 7.07, 19.0],
      [0, 1, 8.0, 22.0]
    ]
  },
  "reference_solution": {
    "route": [0, 1, 2, 5, 0, 6, 4, 3, 0],
    "total_cost": 179.56
  },
  "solver_code": "",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"route\", \"total_cost\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        route = solution[\"route\"]\n        total_cost = solution[\"total_cost\"]\n        streets = structured_data[\"streets\"]\n        num_intersections = structured_data[\"num_intersections\"]\n        errors = []\n        \n        if not isinstance(route, list) or len(route) < 2:\n            errors.append(\"Route must be a non-empty list\")\n        \n        if route[0] != route[-1]:\n            errors.append(\"Route must start and end at the same intersection\")\n        \n        for node in route:\n            if not isinstance(node, int) or node < 0 or node >= num_intersections:\n                errors.append(f\"Invalid intersection: {node}\")\n        \n        covered_streets = set()\n        for i in range(len(route) - 1):\n            u = route[i]\n            v = route[i + 1]\n            \n            found = False\n            for j, (su, sv, _, _) in enumerate(streets):\n                if (su == u and sv == v) or (su == v and sv == u):\n                    covered_streets.add(j)\n                    found = True\n                    break\n            \n            if not found:\n                errors.append(f\"No street connects {u} and {v}\")\n        \n        if len(covered_streets) != len(streets):\n            errors.append(f\"Not all streets covered: {len(covered_streets)}/{len(streets)}\")\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        else:\n            optimal_cost = reference_solution[\"total_cost\"]\n            if optimal_cost == 0:\n                optimality_score = 1.0 if total_cost == 0 else 0.0\n            else:\n                gap = abs(optimal_cost - total_cost) / abs(optimal_cost)\n                optimality_score = max(0, 1 - gap)\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}