{
  "problem_id": "mkp_001",
  "metadata": {
    "problem_type": "Multidimensional Knapsack Problem",
    "difficulty": "simple"
  },
  "problem_description": "In a classified archaeological operation within the temporal anomaly zone beneath ancient Mesopotamian ruins, researchers have discovered a containment field holding ten artifacts with quantum-resonant properties. Each artifact possesses four measurable characteristics: historical significance value (in archaeological significance points, ASP), mass in kilograms, spatial volume in cubic decimeters, and quantum instability measured in temporal instability units (TIU). The extraction system operates under strict dimensional constraints: maximum mass capacity of 20 kg, volume limit of 15 dm\u9c81, and quantum instability threshold of 10 TIU. The artifacts exhibit the following specifications: 1. Chronometric Vessel: significance 100 ASP, mass 5 kg, volume 3 dm\u9c81, instability 2 TIU. 2. Auric Effigy: significance 80 ASP, mass 4 kg, volume 2 dm\u9c81, instability 1 TIU. 3. Crystalline Ocular: significance 90 ASP, mass 6 kg, volume 4 dm\u9c81, instability 3 TIU. 4. Metallocene Barrier: significance 70 ASP, mass 3 kg, volume 2 dm\u9c81, instability 1 TIU. 5. Gematria Diadem: significance 110 ASP, mass 7 kg, volume 5 dm\u9c81, instability 4 TIU. 6. Argentine Blade: significance 60 ASP, mass 2 kg, volume 1 dm\u9c81, instability 1 TIU. 7. Carbon Allotrope Chain: significance 120 ASP, mass 8 kg, volume 6 dm\u9c81, instability 5 TIU. 8. Ferrous Access Mechanism: significance 50 ASP, mass 1 kg, volume 1 dm\u9c81, instability 1 TIU. 9. Beryl Inscription Matrix: significance 130 ASP, mass 9 kg, volume 7 dm\u9c81, instability 6 TIU. 10. Xylic Anthropomorphic Form: significance 40 ASP, mass 2 kg, volume 1 dm\u9c81, instability 1 TIU. Each artifact can either be extracted (selection value 1) or left behind (selection value 0). Which combination of artifacts should be extracted to achieve maximum total historical significance while respecting all dimensional constraints?",
  "solution_format_description": "Print the following fields: - selected: extraction status for each artifact. - total_significance: total historical significance. - total_mass: total mass. - total_volume: total volume. - total_instability: total quantum instability.",
  "structured_data": {
    "artifacts": [
      [100, 5, 3, 2], 
      [80, 4, 2, 1], 
      [90, 6, 4, 3], 
      [70, 3, 2, 1], 
      [110, 7, 5, 4], 
      [60, 2, 1, 1], 
      [120, 8, 6, 5], 
      [50, 1, 1, 1], 
      [130, 9, 7, 6], 
      [40, 2, 1, 1]
    ],
    "constraints": [20, 15, 10]
  },
  "reference_solution": {
    "selected": [1, 0, 0, 1, 1, 1, 0, 1, 0, 1],
    "total_significance": 430,
    "total_mass": 20,
    "total_volume": 13,
    "total_instability": 10
  },
  "solver_code": "from cpmpy import *\nimport json\n\nartifacts = [\n    [100, 5, 3, 2],\n    [80, 4, 2, 1],\n    [90, 6, 4, 3],\n    [70, 3, 2, 1],\n    [110, 7, 5, 4],\n    [60, 2, 1, 1],\n    [120, 8, 6, 5],\n    [50, 1, 1, 1],\n    [130, 9, 7, 6],\n    [40, 2, 1, 1]\n]\n\nconstraints = [20, 15, 10]\nmax_mass = constraints[0]\nmax_volume = constraints[1]\nmax_instability = constraints[2]\n\nnum_artifacts = len(artifacts)\n\nx = boolvar(shape=num_artifacts)\n\nmodel = Model()\n\nmodel += sum(artifacts[i][1] * x[i] for i in range(num_artifacts)) <= max_mass\nmodel += sum(artifacts[i][2] * x[i] for i in range(num_artifacts)) <= max_volume\nmodel += sum(artifacts[i][3] * x[i] for i in range(num_artifacts)) <= max_instability\n\nmodel.maximize(sum(artifacts[i][0] * x[i] for i in range(num_artifacts)))\n\nif model.solve():\n    selected = [int(x[i].value()) for i in range(num_artifacts)]\n    total_significance = sum(artifacts[i][0] * selected[i] for i in range(num_artifacts))\n    total_mass = sum(artifacts[i][1] * selected[i] for i in range(num_artifacts))\n    total_volume = sum(artifacts[i][2] * selected[i] for i in range(num_artifacts))\n    total_instability = sum(artifacts[i][3] * selected[i] for i in range(num_artifacts))\n    \n    result = {\n        \"selected\": selected,\n        \"total_significance\": total_significance,\n        \"total_mass\": total_mass,\n        \"total_volume\": total_volume,\n        \"total_instability\": total_instability\n    }\n    print(json.dumps(result))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"selected\", \"total_significance\", \"total_mass\", \"total_volume\", \"total_instability\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        selected = solution[\"selected\"]\n        total_mass = solution[\"total_mass\"]\n        total_volume = solution[\"total_volume\"]\n        total_instability = solution[\"total_instability\"]\n        \n        artifacts = structured_data[\"artifacts\"]\n        constraints = structured_data[\"constraints\"]\n        num_artifacts = len(artifacts)\n        errors = []\n        \n        if len(selected) != num_artifacts:\n            errors.append(f\"Selection array length mismatch: expected {num_artifacts}, got {len(selected)}\")\n            return {\"is_valid\": False, \"validation_errors\": errors, \"optimality_score\": 0.0}\n        \n        for i in range(num_artifacts):\n            if selected[i] not in [0, 1]:\n                errors.append(f\"Invalid selection value at index {i}: {selected[i]} (must be 0 or 1)\")\n        \n        if total_mass > constraints[0]:\n            errors.append(f\"Mass constraint violated: {total_mass} > {constraints[0]}\")\n        \n        if total_volume > constraints[1]:\n            errors.append(f\"Volume constraint violated: {total_volume} > {constraints[1]}\")\n        \n        if total_instability > constraints[2]:\n            errors.append(f\"Instability constraint violated: {total_instability} > {constraints[2]}\")\n        \n        if len(errors) == 0:\n            optimal_significance = reference_solution[\"total_significance\"]\n            if optimal_significance == 0:\n                optimality_score = 1.0 if solution[\"total_significance\"] == 0 else 0.0\n            else:\n                gap = abs(optimal_significance - solution[\"total_significance\"]) / abs(optimal_significance)\n                optimality_score = max(0, 1 - gap)\n        else:\n            optimality_score = 0.0\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}