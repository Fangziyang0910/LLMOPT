{
  "problem_id": "pmed_uncap_003",
  "metadata": {
    "problem_type": "P-Median Problem",
    "difficulty": "hard"
  },
  "problem_description": "An advanced molecular quantum computing architecture requires strategic deployment of four quantum entanglement stabilization nodes across a ten-qubit processing array to establish optimal coherence preservation pathways that minimize cumulative quantum decoherence rates while adhering to strict superposition constraints and quantum error correction protocols. The quantum topology employs a sophisticated coherence matrix where each connection represents bidirectional quantum tunneling pathways with associated decoherence susceptibility coefficients measured in inverse femtoseconds. The objective is to identify optimal node placement configurations that minimize the aggregate quantum state degradation across all processing segments while maintaining entanglement fidelity above established threshold parameters. Quantum connection characteristics and decoherence susceptibility coefficients include: bidirectional quantum tunneling pathway between node one and node two exhibits susceptibility coefficient two; pathway between node one and node three demonstrates coefficient four; pathway connecting node one and node four shows coefficient one; pathway linking node one and node five reveals coefficient five; pathway between node one and node six exhibits coefficient three; pathway connecting node one and node seven demonstrates coefficient six; pathway linking node one and node eight shows coefficient seven; pathway between node one and node nine exhibits coefficient eight; pathway connecting node one and node ten reveals coefficient nine; pathway between node two and node three demonstrates coefficient one; pathway connecting node two and node four shows coefficient three; pathway between node two and node five exhibits coefficient two; pathway connecting node two and node six reveals coefficient four; pathway between node two and node seven demonstrates coefficient five; pathway connecting node two and node eight shows coefficient six; pathway between node two and node nine reveals coefficient seven; pathway connecting node two and node ten demonstrates coefficient eight; pathway between node three and node four exhibits coefficient two; pathway connecting node three and node five shows coefficient three; pathway between node three and node six demonstrates coefficient one; pathway connecting node three and node seven reveals coefficient four; pathway connecting node three and node eight shows coefficient five; pathway connecting node three and node nine exhibits coefficient six; pathway connecting node three and node ten reveals coefficient seven; pathway connecting node four and node five exhibits coefficient four; pathway between node four and node six shows coefficient two; pathway connecting node four and node seven demonstrates coefficient three; pathway connecting node four and node eight exhibits coefficient four; pathway connecting node four and node nine reveals coefficient five; pathway connecting node four and node ten shows coefficient six; pathway connecting node five and node six exhibits coefficient three; pathway between node five and node seven demonstrates coefficient two; pathway connecting node five and node eight reveals coefficient three; pathway connecting node five and node nine shows coefficient four; pathway connecting node five and node ten exhibits coefficient five; pathway between node six and node seven demonstrates coefficient one; pathway connecting node six and node eight reveals coefficient two; pathway connecting node six and node nine shows coefficient three; pathway connecting node six and node ten exhibits coefficient four; pathway between node seven and node eight demonstrates coefficient one; pathway connecting node seven and node nine reveals coefficient two; pathway connecting node seven and node ten shows coefficient three; pathway between node eight and node nine demonstrates coefficient one; pathway connecting node eight and node ten reveals coefficient two; and pathway between node nine and node ten demonstrates coefficient one. Each quantum processing node must establish connectivity with exactly one quantum entanglement stabilization node, and the quantum decoherence rate from any node to its assigned stabilization node represents the minimum achievable coherence degradation through available quantum tunneling pathways utilizing optimal error correction protocols.",
  "solution_format_description": "Print the following fields: - quantum_entanglement_stabilization_nodes: selected facility locations. - total_quantum_decoherence_rate: total distance cost. - quantum_coherence_assignments: for each node, list assignment with facility, pathway, cost.",
  "structured_data": {
    "quantum_processing_node_count": 10,
    "quantum_entanglement_stabilization_node_count": 4,
    "quantum_tunneling_pathways": [
      [1, 2, 2],
      [1, 3, 4],
      [1, 4, 1],
      [1, 5, 5],
      [1, 6, 3],
      [1, 7, 6],
      [1, 8, 7],
      [1, 9, 8],
      [1, 10, 9],
      [2, 3, 1],
      [2, 4, 3],
      [2, 5, 2],
      [2, 6, 4],
      [2, 7, 5],
      [2, 8, 6],
      [2, 9, 7],
      [2, 10, 8],
      [3, 4, 2],
      [3, 5, 3],
      [3, 6, 1],
      [3, 7, 4],
      [3, 8, 5],
      [3, 9, 6],
      [3, 10, 7],
      [4, 5, 4],
      [4, 6, 2],
      [4, 7, 3],
      [4, 8, 4],
      [4, 9, 5],
      [4, 10, 6],
      [5, 6, 3],
      [5, 7, 2],
      [5, 8, 3],
      [5, 9, 4],
      [5, 10, 5],
      [6, 7, 1],
      [6, 8, 2],
      [6, 9, 3],
      [6, 10, 4],
      [7, 8, 1],
      [7, 9, 2],
      [7, 10, 3],
      [8, 9, 1],
      [8, 10, 2],
      [9, 10, 1]
    ]
  },
  "reference_solution": {
    "quantum_entanglement_stabilization_nodes": [3, 4, 5, 9],
    "total_quantum_decoherence_rate": 7,
    "quantum_coherence_assignments": [
      [4, [1, 4], 1],
      [3, [2, 3], 1],
      [3, [3], 0],
      [4, [4], 0],
      [5, [5], 0],
      [3, [6, 3], 1],
      [9, [7, 9], 2],
      [9, [8, 7, 9], 2],
      [9, [9], 0],
      [9, [10, 9], 1]
    ]
  },
  "solver_code": "from cpmpy import *\nimport json\n\nquantum_processing_node_count = 10\nquantum_entanglement_stabilization_node_count = 4\nquantum_tunneling_pathways = [\n    [1, 2, 2],\n    [1, 3, 4],\n    [1, 4, 1],\n    [1, 5, 5],\n    [1, 6, 3],\n    [1, 7, 6],\n    [1, 8, 7],\n    [1, 9, 8],\n    [1, 10, 9],\n    [2, 3, 1],\n    [2, 4, 3],\n    [2, 5, 2],\n    [2, 6, 4],\n    [2, 7, 5],\n    [2, 8, 6],\n    [2, 9, 7],\n    [2, 10, 8],\n    [3, 4, 2],\n    [3, 5, 3],\n    [3, 6, 1],\n    [3, 7, 4],\n    [3, 8, 5],\n    [3, 9, 6],\n    [3, 10, 7],\n    [4, 5, 4],\n    [4, 6, 2],\n    [4, 7, 3],\n    [4, 8, 4],\n    [4, 9, 5],\n    [4, 10, 6],\n    [5, 6, 3],\n    [5, 7, 2],\n    [5, 8, 3],\n    [5, 9, 4],\n    [5, 10, 5],\n    [6, 7, 1],\n    [6, 8, 2],\n    [6, 9, 3],\n    [6, 10, 4],\n    [7, 8, 1],\n    [7, 9, 2],\n    [7, 10, 3],\n    [8, 9, 1],\n    [8, 10, 2],\n    [9, 10, 1]\n]\n\nINF = float('inf')\ndist = [[INF] * quantum_processing_node_count for _ in range(quantum_processing_node_count)]\nnext_node = [[-1] * quantum_processing_node_count for _ in range(quantum_processing_node_count)]\n\nfor i in range(quantum_processing_node_count):\n    dist[i][i] = 0\n    for j in range(quantum_processing_node_count):\n        if i == j:\n            next_node[i][j] = j\n\nfor pathway in quantum_tunneling_pathways:\n    i = pathway[0] - 1\n    j = pathway[1] - 1\n    decoherence_rate = pathway[2]\n    if decoherence_rate < dist[i][j]:\n        dist[i][j] = decoherence_rate\n        dist[j][i] = decoherence_rate\n        next_node[i][j] = j\n        next_node[j][i] = i\n\nfor k in range(quantum_processing_node_count):\n    for i in range(quantum_processing_node_count):\n        for j in range(quantum_processing_node_count):\n            if dist[i][k] + dist[k][j] < dist[i][j]:\n                dist[i][j] = dist[i][k] + dist[k][j]\n                next_node[i][j] = next_node[i][k]\n\ndef get_quantum_pathway(i, j):\n    if dist[i][j] == INF:\n        return []\n    pathway = [i]\n    while i != j:\n        i = next_node[i][j]\n        pathway.append(i)\n    return pathway\n\nquantum_entanglement_stabilization_node = boolvar(shape=quantum_processing_node_count)\nassign = intvar(shape=(quantum_processing_node_count, quantum_processing_node_count), lb=0, ub=1)\n\nmodel = Model()\nmodel += sum(quantum_entanglement_stabilization_node) == quantum_entanglement_stabilization_node_count\n\nfor i in range(quantum_processing_node_count):\n    model += sum(assign[i][j] for j in range(quantum_processing_node_count)) == 1\n\nfor i in range(quantum_processing_node_count):\n    for j in range(quantum_processing_node_count):\n        model += assign[i][j] <= quantum_entanglement_stabilization_node[j]\n\ntotal_quantum_decoherence_rate = sum(dist[i][j] * assign[i][j] for i in range(quantum_processing_node_count) for j in range(quantum_processing_node_count))\nmodel.minimize(total_quantum_decoherence_rate)\n\nif model.solve():\n    selected_quantum_entanglement_stabilization_nodes = [i+1 for i in range(quantum_processing_node_count) if quantum_entanglement_stabilization_node[i].value()]\n    \n    quantum_coherence_assignments = []\n    for i in range(quantum_processing_node_count):\n        for j in range(quantum_processing_node_count):\n            if assign[i][j].value():\n                pathway = get_quantum_pathway(i, j)\n                pathway_1_indexed = [node+1 for node in pathway]\n                decoherence_rate = dist[i][j]\n                quantum_coherence_assignments.append([j+1, pathway_1_indexed, decoherence_rate])\n    \n    result = {\n        \"quantum_entanglement_stabilization_nodes\": selected_quantum_entanglement_stabilization_nodes,\n        \"total_quantum_decoherence_rate\": total_quantum_decoherence_rate.value(),\n        \"quantum_coherence_assignments\": quantum_coherence_assignments\n    }\n    print(json.dumps(result))\nelse:\n    print(\"No solution found\")",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    is_valid = False\n    validation_errors = []\n    optimality_score = 0.0\n\n    try:\n        if isinstance(candidate_solution, str):\n            solution = json.loads(candidate_solution)\n        else:\n            solution = candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n\n    required_fields = [\"quantum_entanglement_stabilization_nodes\", \"total_quantum_decoherence_rate\", \"quantum_coherence_assignments\"]\n    missing = [f for f in required_fields if f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n\n    try:\n        quantum_entanglement_stabilization_nodes = solution[\"quantum_entanglement_stabilization_nodes\"]\n        total_quantum_decoherence_rate = solution[\"total_quantum_decoherence_rate\"]\n        quantum_coherence_assignments = solution[\"quantum_coherence_assignments\"]\n        \n        quantum_processing_node_count = structured_data[\"quantum_processing_node_count\"]\n        quantum_entanglement_stabilization_node_count = structured_data[\"quantum_entanglement_stabilization_node_count\"]\n        quantum_tunneling_pathways = structured_data[\"quantum_tunneling_pathways\"]\n\n        if not isinstance(quantum_entanglement_stabilization_nodes, list) or len(quantum_entanglement_stabilization_nodes) != quantum_entanglement_stabilization_node_count:\n            validation_errors.append(f\"Quantum entanglement stabilization nodes must be a list of exactly {quantum_entanglement_stabilization_node_count} distinct integers.\")\n        elif len(set(quantum_entanglement_stabilization_nodes)) != quantum_entanglement_stabilization_node_count:\n            validation_errors.append(\"Quantum entanglement stabilization node locations must be distinct.\")\n        elif any(not isinstance(h, int) or h < 1 or h > quantum_processing_node_count for h in quantum_entanglement_stabilization_nodes):\n            validation_errors.append(f\"Each quantum entanglement stabilization node must be an integer in the range [1, {quantum_processing_node_count}].\")\n\n        if not isinstance(quantum_coherence_assignments, list) or len(quantum_coherence_assignments) != quantum_processing_node_count:\n            validation_errors.append(f\"Quantum coherence assignments must be a list of exactly {quantum_processing_node_count} arrays.\")\n        else:\n            assigned_nodes = set()\n            for idx, assignment in enumerate(quantum_coherence_assignments):\n                if not isinstance(assignment, list) or len(assignment) != 3:\n                    validation_errors.append(f\"Quantum coherence assignment {idx+1} must be an array of [stabilization_node, quantum_pathway, decoherence_rate].\")\n                    continue\n                    \n                stabilization_node = assignment[0]\n                quantum_pathway = assignment[1]\n                decoherence_rate = assignment[2]\n                \n                if not isinstance(stabilization_node, int) or stabilization_node < 1 or stabilization_node > quantum_processing_node_count:\n                     validation_errors.append(f\"Stabilization node number must be an integer in the range [1, {quantum_processing_node_count}].\")\n                if not isinstance(quantum_pathway, list) or len(quantum_pathway) < 1:\n                     validation_errors.append(f\"Quantum pathway must be a non-empty list of node indices.\")\n                if not isinstance(decoherence_rate, (int, float)) or decoherence_rate < 0:\n                     validation_errors.append(f\"Decoherence rate must be a non-negative number.\")\n                if stabilization_node not in quantum_entanglement_stabilization_nodes:\n                    validation_errors.append(f\"Node {idx+1} is assigned to stabilization node {stabilization_node}, which is not in the selected quantum entanglement stabilization nodes list.\")\n                if quantum_pathway[0] != idx+1 or quantum_pathway[-1] != stabilization_node:\n                    validation_errors.append(f\"Quantum pathway for node {idx+1} must start at {idx+1} and end at stabilization node {stabilization_node}.\")\n\n        INF = float('inf')\n        dist = [[INF] * quantum_processing_node_count for _ in range(quantum_processing_node_count)]\n        for i in range(quantum_processing_node_count):\n            dist[i][i] = 0\n\n        for pathway in quantum_tunneling_pathways:\n            u = pathway[0] - 1\n            v = pathway[1] - 1\n            decoherence_rate = pathway[2]\n            dist[u][v] = min(dist[u][v], decoherence_rate)\n            dist[v][u] = min(dist[v][u], decoherence_rate)\n\n        for k in range(quantum_processing_node_count):\n            for i in range(quantum_processing_node_count):\n                for j in range(quantum_processing_node_count):\n                    if dist[i][k] + dist[k][j] < dist[i][j]:\n                        dist[i][j] = dist[i][k] + dist[k][j]\n        \n        calc_decoherence_rate = 0\n        cost_verification_passed = True\n        for idx, assignment in enumerate(quantum_coherence_assignments):\n            if not isinstance(assignment, list) or len(assignment) != 3:\n                continue\n            i = idx  # 0-based index for current node\n            j = assignment[0] - 1  # stabilization node index (convert to 0-based)\n            declared_decoherence_rate = assignment[2]\n            actual_decoherence_rate = dist[i][j]\n            \n            if abs(declared_decoherence_rate - actual_decoherence_rate) > 1e-6:\n                validation_errors.append(f\"Decoherence rate mismatch for node {idx+1}: declared {declared_decoherence_rate}, actual {actual_decoherence_rate}\")\n            \n            calc_decoherence_rate += actual_decoherence_rate\n                \n        if cost_verification_passed and abs(calc_decoherence_rate - total_quantum_decoherence_rate) > 1e-6:\n            validation_errors.append(f\"Total quantum decoherence rate inconsistency: calculated {calc_decoherence_rate}, declared {total_quantum_decoherence_rate}\")\n\n        is_valid = (len(validation_errors) == 0)\n        \n        if is_valid:\n            try:\n                optimal_value = reference_solution[\"total_quantum_decoherence_rate\"]\n                candidate_value = total_quantum_decoherence_rate\n                \n                if optimal_value == 0:\n                    optimality_score = 1.0 if candidate_value == 0 else 0.0\n                else:\n                    gap = abs(optimal_value - candidate_value) / abs(optimal_value)\n                    optimality_score = max(0, 1 - gap)\n            except (KeyError, TypeError, ZeroDivisionError):\n                optimality_score = 0.0\n        \n        return {\n            \"is_valid\": is_valid,\n            \"validation_errors\": validation_errors,\n            \"optimality_score\": optimality_score\n        }\n\n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}