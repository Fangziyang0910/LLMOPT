{
  "problem_id": "constrained_guillotine_cutting_002",
  "metadata": {
    "problem_type": "Constrained Guillotine Cutting Problem",
    "difficulty": "medium"
  },
  "problem_description": "A furniture manufacturer has a wooden board measuring 35 feet by 25 feet and needs to cut it into smaller rectangular pieces for various furniture components using a guillotine cutting process. The manufacturer wants to maximize the total value of the pieces obtained from this board. In guillotine cutting, each cut must be a straight line that goes completely from one edge to another without cutting through any placed piece, and this property must hold recursively for all resulting subregions. The pieces must be placed with their edges parallel to the board edges (no 90-degree rotation allowed) and must fit entirely within the board without overlapping. Each piece type has a maximum quantity limit that cannot be exceeded.\n\nHere are the details of the furniture pieces needed:\n1. Furniture Type 1: Size 10ft x 8ft, Value 80, Up to 2 pieces can be cut\n2. Furniture Type 2: Size 12ft x 6ft, Value 72, Up to 2 pieces can be cut\n3. Furniture Type 3: Size 8ft x 8ft, Value 64, Up to 3 pieces can be cut\n4. Furniture Type 4: Size 6ft x 10ft, Value 60, Up to 2 pieces can be cut\n5. Furniture Type 5: Size 15ft x 5ft, Value 75, Up to 1 piece can be cut",
  "solution_format_description": "Print the following fields: - total_value: total value of placed pieces. - placements: for each piece, list placements with piece type, x, y, length, width, orientation.",
  "structured_data": {
    "container_dimensions": [35, 25],
    "item_inventory": [
      [10, 8, 2, 80],
      [12, 6, 2, 72],
      [8, 8, 3, 64],
      [6, 10, 2, 60],
      [15, 5, 1, 75]
    ]
  },
  "reference_solution": {
    "total_value": 691, 
    "placements": [
      [5, 12, 8, 15, 5, 0], [1, 3, 17, 10, 8, 0], 
      [2, 0, 11, 12, 6, 0], [1, 25, 16, 10, 8, 0], 
      [4, 0, 0, 6, 10, 0], [3, 12, 0, 8, 8, 0], 
      [4, 6, 0, 6, 10, 0], [3, 20, 0, 8, 8, 0], 
      [2, 13, 14, 12, 6, 0], [3, 27, 8, 8, 8, 0]
    ]
  },
  "solver_code": "from cpmpy import *\nimport json\n\ncontainer_dimensions = [35, 25]\nitem_inventory = [\n    [10, 8, 2, 80],\n    [12, 6, 2, 72],\n    [8, 8, 3, 64],\n    [6, 10, 2, 60],\n    [15, 5, 1, 75]\n]\n\ncontainer_length, container_width = container_dimensions\nm = len(item_inventory)\nmax_placements = sum(item[2] for item in item_inventory)\n\npiece_types_vars = [intvar(1, m, name=f\"p_type_{i}\") for i in range(max_placements)]\nx_vars = [intvar(0, container_length, name=f\"x_{i}\") for i in range(max_placements)]\ny_vars = [intvar(0, container_width, name=f\"y_{i}\") for i in range(max_placements)]\nplaced_vars = [boolvar(name=f\"placed_{i}\") for i in range(max_placements)]\n\nmodel = Model()\n\nfor i in range(max_placements):\n    for p in range(m):\n        item = item_inventory[p]\n        model += ((piece_types_vars[i] == p+1) & placed_vars[i]).implies(\n            (x_vars[i] + item[0] <= container_length) & \n            (y_vars[i] + item[1] <= container_width)\n        )\n\nfor i in range(max_placements):\n    for j in range(i+1, max_placements):\n        p1_type, x1, y1, placed1 = piece_types_vars[i], x_vars[i], y_vars[i], placed_vars[i]\n        p2_type, x2, y2, placed2 = piece_types_vars[j], x_vars[j], y_vars[j], placed_vars[j]\n        \n        p1_len = 0\n        p1_wid = 0\n        for p in range(m):\n            p1_len += (p1_type == p+1) * item_inventory[p][0]\n            p1_wid += (p1_type == p+1) * item_inventory[p][1]\n        \n        p2_len = 0\n        p2_wid = 0\n        for p in range(m):\n            p2_len += (p2_type == p+1) * item_inventory[p][0]\n            p2_wid += (p2_type == p+1) * item_inventory[p][1]\n        \n        model += (placed1 & placed2).implies(\n            (x1 + p1_len <= x2) | (x2 + p2_len <= x1) |\n            (y1 + p1_wid <= y2) | (y2 + p2_wid <= y1)\n        )\n\nfor p in range(m):\n    count = 0\n    for i in range(max_placements):\n        count += (piece_types_vars[i] == p+1) & placed_vars[i]\n    model += count <= item_inventory[p][2]\n\ntotal_value = 0\nfor i in range(max_placements):\n    item_value = 0\n    for p in range(m):\n        item_value += (piece_types_vars[i] == p+1) * item_inventory[p][3]\n    total_value += placed_vars[i] * item_value\n\nmodel.maximize(total_value)\n\nif model.solve():\n    solution_placements = []\n    solution_value = 0\n    \n    for i in range(max_placements):\n        if placed_vars[i].value():\n            p_idx = piece_types_vars[i].value() - 1\n            item = item_inventory[p_idx]\n            solution_placements.append([\n                piece_types_vars[i].value(), \n                x_vars[i].value(),           \n                y_vars[i].value(),          \n                item[0],             \n                item[1],              \n                0                           \n            ])\n            solution_value += item[3]\n    \n    result = {\n        \"total_value\": solution_value,\n        \"placements\": solution_placements\n    }\n    print(json.dumps(result))\nelse:\n    print(json.dumps({\"total_value\": 0, \"placements\": []}))",
  "evaluation_function": "def evaluate(candidate_solution, structured_data, reference_solution):\n    import json\n    \n    try:\n        solution = json.loads(candidate_solution) if isinstance(candidate_solution, str) else candidate_solution\n    except:\n        return {\"is_valid\": False, \"validation_errors\": [\"Invalid JSON format\"], \"optimality_score\": 0.0}\n    \n    required_fields = [\"placements\", \"total_value\"]\n    missing = [f for f in required_fields if solution is None or f not in solution]\n    if missing:\n        return {\"is_valid\": False, \"validation_errors\": [f\"Missing fields: {missing}\"], \"optimality_score\": 0.0}\n    \n    try:\n        placements = solution[\"placements\"]\n        total_value = solution[\"total_value\"]\n        board_length = structured_data[0][\"board_length\"]\n        board_width = structured_data[0][\"board_width\"]\n        furniture = structured_data[0][\"furniture\"]\n        errors = []\n        \n        used_positions = []\n        component_counts = {}\n        calc_value = 0\n        \n        for i, placement in enumerate(placements):\n            if len(placement) != 6:\n                errors.append(f\"Placement {i} must have 6 values [piece_type_id, x, y, length, width, orientation]\")\n                continue\n            \n            piece_type_id, x, y, length, width, orientation = placement\n            \n            if piece_type_id < 1 or piece_type_id > len(furniture):\n                errors.append(f\"Placement {i} has invalid piece type ID: {piece_type_id}\")\n                continue\n            \n            item = furniture[piece_type_id - 1]\n            \n            if orientation == 0:\n                expected_length, expected_width = item[\"length\"], item[\"width\"]\n            else:\n                expected_length, expected_width = item[\"width\"], item[\"length\"]\n            \n            if length != expected_length or width != expected_width:\n                errors.append(f\"Placement {i} dimensions mismatch: expected {expected_length}x{expected_width}, got {length}x{width}\")\n                continue\n            \n            if x < 0 or y < 0:\n                errors.append(f\"Placement {i} has negative coordinates: ({x}, {y})\")\n            \n            if x + length > board_length:\n                errors.append(f\"Placement {i} exceeds board length: {x} + {length} > {board_length}\")\n            \n            if y + width > board_width:\n                errors.append(f\"Placement {i} exceeds board width: {y} + {width} > {board_width}\")\n            \n            for j, prev_placement in enumerate(used_positions):\n                prev_piece_type_id, prev_x, prev_y, prev_length, prev_width, prev_orientation = prev_placement\n                \n                if not (x + length <= prev_x or prev_x + prev_length <= x or\n                        y + width <= prev_y or prev_y + prev_width <= y):\n                    errors.append(f\"Placement {i} overlaps with placement {j}\")\n            \n            used_positions.append(placement)\n            component_counts[piece_type_id - 1] = component_counts.get(piece_type_id - 1, 0) + 1\n            calc_value += item[\"value\"]\n        \n        for i, item in enumerate(furniture):\n            max_quantity = item[\"max\"]\n            used_count = component_counts.get(i, 0)\n            \n            if used_count > max_quantity:\n                errors.append(f\"Furniture item {i+1} exceeds maximum quantity: {used_count} > {max_quantity}\")\n        \n        if abs(calc_value - total_value) > 1e-6:\n            errors.append(f\"Value inconsistency: calculated {calc_value}, declared {total_value}\")\n        \n        optimal_value = reference_solution[\"total_value\"]\n        if optimal_value == 0:\n            optimality_score = 1.0 if total_value == 0 else 0.0\n        else:\n            gap = abs(optimal_value - total_value) / abs(optimal_value)\n            optimality_score = max(0, 1 - gap)\n        \n        if len(errors) > 0:\n            optimality_score = 0.0\n        \n        return {\n            \"is_valid\": len(errors) == 0,\n            \"validation_errors\": errors,\n            \"optimality_score\": optimality_score\n        }\n        \n    except Exception as e:\n        return {\"is_valid\": False, \"validation_errors\": [\"Format error in solution data\"], \"optimality_score\": 0.0}"
}